/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		2:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({"0":"countries","1":"kitchen_sink"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(3);
	__webpack_require__(2);
	__webpack_require__(6);
	module.exports = __webpack_require__(110);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v1.11.3
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:19Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper window is present,
			// execute the factory and get jQuery
			// For environments that do not inherently posses a window with a document
			// (such as Node.js), expose a jQuery-making factory as module.exports
			// This accentuates the need for the creation of a real window
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Can't do this because several apps including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	// Support: Firefox 18+
	//
	
	var deletedIds = [];
	
	var slice = deletedIds.slice;
	
	var concat = deletedIds.concat;
	
	var push = deletedIds.push;
	
	var indexOf = deletedIds.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		version = "1.11.3",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1, IE<9
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor(null);
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: deletedIds.sort,
		splice: deletedIds.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var src, copyIsArray, copy, name, options, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}
	
		// extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},
	
		isArray: Array.isArray || function( obj ) {
			return jQuery.type(obj) === "array";
		},
	
		isWindow: function( obj ) {
			/* jshint eqeqeq: false */
			return obj != null && obj == obj.window;
		},
	
		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		isPlainObject: function( obj ) {
			var key;
	
			// Must be an Object.
			// Because of IE, we also have to check the presence of the constructor property.
			// Make sure that DOM nodes and window objects don't pass through, as well
			if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			try {
				// Not own constructor property must be Object
				if ( obj.constructor &&
					!hasOwn.call(obj, "constructor") &&
					!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
					return false;
				}
			} catch ( e ) {
				// IE8,9 Will throw exceptions on certain host objects #9897
				return false;
			}
	
			// Support: IE<9
			// Handle iteration over inherited properties before own properties.
			if ( support.ownLast ) {
				for ( key in obj ) {
					return hasOwn.call( obj, key );
				}
			}
	
			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.
			for ( key in obj ) {}
	
			return key === undefined || hasOwn.call( obj, key );
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		// Workarounds based on findings by Jim Driscoll
		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
		globalEval: function( data ) {
			if ( data && jQuery.trim( data ) ) {
				// We use execScript on Internet Explorer
				// We use an anonymous function so that context is window
				// rather than jQuery in Firefox
				( window.execScript || function( data ) {
					window[ "eval" ].call( window, data );
				} )( data );
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );
	
			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				}
	
			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1, IE<9
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			var len;
	
			if ( arr ) {
				if ( indexOf ) {
					return indexOf.call( arr, elem, i );
				}
	
				len = arr.length;
				i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
	
				for ( ; i < len; i++ ) {
					// Skip accessing in sparse arrays
					if ( i in arr && arr[ i ] === elem ) {
						return i;
					}
				}
			}
	
			return -1;
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			while ( j < len ) {
				first[ i++ ] = second[ j++ ];
			}
	
			// Support: IE<9
			// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
			if ( len !== len ) {
				while ( second[j] !== undefined ) {
					first[ i++ ] = second[ j++ ];
				}
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var args, proxy, tmp;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: function() {
			return +( new Date() );
		},
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});
	
	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});
	
	function isArraylike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		if ( obj.nodeType === 1 && length ) {
			return true;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
		nodeType = context.nodeType;
	
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		if ( !seed && documentIsHTML ) {
	
			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;
	
		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return doc;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context !== document && context;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {
	
			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
		});
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};
	
	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				ret = [],
				self = this,
				len = self.length;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;
	
						// scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );
	
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id !== match[2] ) {
								return rootjQuery.find( selector );
							}
	
							// Otherwise, we inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				cur = elem[ dir ];
	
			while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
				if ( cur.nodeType === 1 ) {
					matched.push( cur );
				}
				cur = cur[dir];
			}
			return matched;
		},
	
		sibling: function( n, elem ) {
			var r = [];
	
			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					r.push( n );
				}
			}
	
			return r;
		}
	});
	
	jQuery.fn.extend({
		has: function( target ) {
			var i,
				targets = jQuery( target, this ),
				len = targets.length;
	
			return this.filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},
	
		// Determine the position of an element within
		// the matched set of elements
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// index in selector
			if ( typeof elem === "string" ) {
				return jQuery.inArray( this[0], jQuery( elem ) );
			}
	
			// Locate the position of the desired element
			return jQuery.inArray(
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[0] : elem, this );
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});
	
	function sibling( cur, dir ) {
		do {
			cur = cur[ dir ];
		} while ( cur && cur.nodeType !== 1 );
	
		return cur;
	}
	
	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return jQuery.nodeName( elem, "iframe" ) ?
				elem.contentDocument || elem.contentWindow.document :
				jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var ret = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				ret = jQuery.filter( selector, ret );
			}
	
			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					ret = jQuery.unique( ret );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					ret = ret.reverse();
				}
			}
	
			return this.pushStack( ret );
		};
	});
	var rnotwhite = (/\S+/g);
	
	
	
	// String to Object options format cache
	var optionsCache = {};
	
	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
			// Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend({
	
		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
	
						} else if ( !(--remaining) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}
	
			// if we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	});
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready );
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});
	
	/**
	 * Clean-up method for dom ready events
	 */
	function detach() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );
	
		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	}
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// we once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );
	
			// Standards-based browsers support DOMContentLoaded
			} else if ( document.addEventListener ) {
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
	
			// If IE event model is used
			} else {
				// Ensure firing before onload, maybe late but safe also for iframes
				document.attachEvent( "onreadystatechange", completed );
	
				// A fallback to window.onload, that will always work
				window.attachEvent( "onload", completed );
	
				// If IE and not a frame
				// continually check to see if the document is ready
				var top = false;
	
				try {
					top = window.frameElement == null && document.documentElement;
				} catch(e) {}
	
				if ( top && top.doScroll ) {
					(function doScrollCheck() {
						if ( !jQuery.isReady ) {
	
							try {
								// Use the trick by Diego Perini
								// http://javascript.nwbox.com/IEContentLoaded/
								top.doScroll("left");
							} catch(e) {
								return setTimeout( doScrollCheck, 50 );
							}
	
							// detach all dom ready events
							detach();
	
							// and execute any waiting functions
							jQuery.ready();
						}
					})();
				}
			}
		}
		return readyList.promise( obj );
	};
	
	
	var strundefined = typeof undefined;
	
	
	
	// Support: IE<9
	// Iteration over object's inherited properties before its own
	var i;
	for ( i in jQuery( support ) ) {
		break;
	}
	support.ownLast = i !== "0";
	
	// Note: most support tests are defined in their respective modules.
	// false until the test is run
	support.inlineBlockNeedsLayout = false;
	
	// Execute ASAP in case we need to set body.style.zoom
	jQuery(function() {
		// Minified: var a,b,c,d
		var val, div, body, container;
	
		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Return for frameset docs that don't have a body
			return;
		}
	
		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );
	
		if ( typeof div.style.zoom !== strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
	
			support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
			if ( val ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}
	
		body.removeChild( container );
	});
	
	
	
	
	(function() {
		var div = document.createElement( "div" );
	
		// Execute the test only if not already executed in another module.
		if (support.deleteExpando == null) {
			// Support: IE<9
			support.deleteExpando = true;
			try {
				delete div.test;
			} catch( e ) {
				support.deleteExpando = false;
			}
		}
	
		// Null elements to avoid leaks in IE.
		div = null;
	})();
	
	
	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( elem ) {
		var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
			nodeType = +elem.nodeType || 1;
	
		// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
		return nodeType !== 1 && nodeType !== 9 ?
			false :
	
			// Nodes accept data unless otherwise specified; rejection can be conditional
			!noData || noData !== true && elem.getAttribute("classid") === noData;
	};
	
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;
	
	function dataAttr( elem, key, data ) {
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
	
			var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
	
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}
	
				// Make sure we set the data so it isn't changed later
				jQuery.data( elem, key, data );
	
			} else {
				data = undefined;
			}
		}
	
		return data;
	}
	
	// checks a cache object for emptiness
	function isEmptyDataObject( obj ) {
		var name;
		for ( name in obj ) {
	
			// if the public data object is empty, the private is still empty
			if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
				continue;
			}
			if ( name !== "toJSON" ) {
				return false;
			}
		}
	
		return true;
	}
	
	function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
	
		var ret, thisCache,
			internalKey = jQuery.expando,
	
			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,
	
			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,
	
			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
	
		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
			return;
		}
	
		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}
	
		if ( !cache[ id ] ) {
			// Avoid exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
		}
	
		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}
	
		thisCache = cache[ id ];
	
		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}
	
			thisCache = thisCache.data;
		}
	
		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}
	
		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( typeof name === "string" ) {
	
			// First Try to find as-is property data
			ret = thisCache[ name ];
	
			// Test for null|undefined property data
			if ( ret == null ) {
	
				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}
	
		return ret;
	}
	
	function internalRemoveData( elem, name, pvt ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
	
		var thisCache, i,
			isNode = elem.nodeType,
	
			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
	
		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}
	
		if ( name ) {
	
			thisCache = pvt ? cache[ id ] : cache[ id ].data;
	
			if ( thisCache ) {
	
				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {
	
					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {
	
						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				} else {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = name.concat( jQuery.map( name, jQuery.camelCase ) );
				}
	
				i = name.length;
				while ( i-- ) {
					delete thisCache[ name[i] ];
				}
	
				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
					return;
				}
			}
		}
	
		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;
	
			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}
	
		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );
	
		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		/* jshint eqeqeq: false */
		} else if ( support.deleteExpando || cache != cache.window ) {
			/* jshint eqeqeq: true */
			delete cache[ id ];
	
		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	}
	
	jQuery.extend({
		cache: {},
	
		// The following elements (space-suffixed to avoid Object.prototype collisions)
		// throw uncatchable exceptions if you attempt to set expando properties
		noData: {
			"applet ": true,
			"embed ": true,
			// ...but Flash objects (which have this classid) *can* handle expandos
			"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
		},
	
		hasData: function( elem ) {
			elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
			return !!elem && !isEmptyDataObject( elem );
		},
	
		data: function( elem, name, data ) {
			return internalData( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			return internalRemoveData( elem, name );
		},
	
		// For internal use only.
		_data: function( elem, name, data ) {
			return internalData( elem, name, data, true );
		},
	
		_removeData: function( elem, name ) {
			return internalRemoveData( elem, name, true );
		}
	});
	
	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[0],
				attrs = elem && elem.attributes;
	
			// Special expections of .data basically thwart jQuery.access,
			// so implement the relevant behavior ourselves
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = jQuery.data( elem );
	
					if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						jQuery._data( elem, "parsedAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					jQuery.data( this, key );
				});
			}
	
			return arguments.length > 1 ?
	
				// Sets one value
				this.each(function() {
					jQuery.data( this, key, value );
				}) :
	
				// Gets one value
				// Try to fetch any internally stored data first
				elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
		},
	
		removeData: function( key ) {
			return this.each(function() {
				jQuery.removeData( this, key );
			});
		}
	});
	
	
	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = jQuery._data( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray(data) ) {
						queue = jQuery._data( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// not intended for public consumption - generates a queueHooks object, or returns the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return jQuery._data( elem, key ) || jQuery._data( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					jQuery._removeData( elem, type + "queue" );
					jQuery._removeData( elem, key );
				})
			});
		}
	});
	
	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}
	
			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );
	
					// ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = jQuery._data( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	};
	var rcheckableType = (/^(?:checkbox|radio)$/i);
	
	
	
	(function() {
		// Minified: var a,b,c
		var input = document.createElement( "input" ),
			div = document.createElement( "div" ),
			fragment = document.createDocumentFragment();
	
		// Setup
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	
		// IE strips leading whitespace when .innerHTML is used
		support.leadingWhitespace = div.firstChild.nodeType === 3;
	
		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		support.tbody = !div.getElementsByTagName( "tbody" ).length;
	
		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;
	
		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		support.html5Clone =
			document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";
	
		// Check if a disconnected checkbox will retain its checked
		// value of true after appended to the DOM (IE6/7)
		input.type = "checkbox";
		input.checked = true;
		fragment.appendChild( input );
		support.appendChecked = input.checked;
	
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		// Support: IE6-IE11+
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	
		// #11217 - WebKit loses check when the name is after the checked attribute
		fragment.appendChild( div );
		div.innerHTML = "<input type='radio' checked='checked' name='t'/>";
	
		// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
		// old WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<9
		// Opera does not clone events (and typeof div.attachEvent === undefined).
		// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
		support.noCloneEvent = true;
		if ( div.attachEvent ) {
			div.attachEvent( "onclick", function() {
				support.noCloneEvent = false;
			});
	
			div.cloneNode( true ).click();
		}
	
		// Execute the test only if not already executed in another module.
		if (support.deleteExpando == null) {
			// Support: IE<9
			support.deleteExpando = true;
			try {
				delete div.test;
			} catch( e ) {
				support.deleteExpando = false;
			}
		}
	})();
	
	
	(function() {
		var i, eventName,
			div = document.createElement( "div" );
	
		// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
		for ( i in { submit: true, change: true, focusin: true }) {
			eventName = "on" + i;
	
			if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
				// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
				div.setAttribute( eventName, "t" );
				support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
			}
		}
	
		// Null elements to avoid leaks in IE.
		div = null;
	})();
	
	
	var rformElems = /^(?:input|select|textarea)$/i,
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
			var tmp, events, t, handleObjIn,
				special, eventHandle, handleObj,
				handlers, type, namespaces, origType,
				elemData = jQuery._data( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
						undefined;
				};
				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
				eventHandle.elem = elem;
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener/attachEvent if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						// Bind the global event handler to the element
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
	
						} else if ( elem.attachEvent ) {
							elem.attachEvent( "on" + type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
			// Nullify elem to prevent memory leaks in IE
			elem = null;
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
			var j, handleObj, tmp,
				origCount, t, events,
				special, handlers, type,
				namespaces, origType,
				elemData = jQuery.hasData( elem ) && jQuery._data( elem );
	
			if ( !elemData || !(events = elemData.events) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
	
				// removeData also checks for emptiness and clears the expando if empty
				// so use it instead of delete
				jQuery._removeData( elem, "events" );
			}
		},
	
		trigger: function( event, data, elem, onlyHandlers ) {
			var handle, ontype, cur,
				bubbleType, special, tmp, i,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Can't use an .isFunction() check here because IE6/7 fails that test.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						try {
							elem[ type ]();
						} catch ( e ) {
							// IE<9 dies on focus/blur to hidden element (#1486,#12518)
							// only reproducible on winXP IE8 native, not IE9 in IE8 mode
						}
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, ret, handleObj, matched, j,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or
					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var sel, handleObj, matches, i,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
	
				/* jshint eqeqeq: false */
				for ( ; cur != this; cur = cur.parentNode || this ) {
					/* jshint eqeqeq: true */
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}
	
			return handlerQueue;
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: IE<9
			// Fix target property (#1925)
			if ( !event.target ) {
				event.target = originalEvent.srcElement || document;
			}
	
			// Support: Chrome 23+, Safari?
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			// Support: IE<9
			// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
			event.metaKey = !!event.metaKey;
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var body, eventDoc, doc,
					button = original.button,
					fromElement = original.fromElement;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add relatedTarget, if necessary
				if ( !event.relatedTarget && fromElement ) {
					event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						try {
							this.focus();
							return false;
						} catch ( e ) {
							// Support: IE<9
							// If we error on focus to hidden element (#1486, #12518),
							// let .trigger() run the handlers
						}
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},
	
		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};
	
	jQuery.removeEvent = document.removeEventListener ?
		function( elem, type, handle ) {
			if ( elem.removeEventListener ) {
				elem.removeEventListener( type, handle, false );
			}
		} :
		function( elem, type, handle ) {
			var name = "on" + type;
	
			if ( elem.detachEvent ) {
	
				// #8545, #7054, preventing memory leaks for custom events in IE6-8
				// detachEvent needed property on element, by name of that event, to properly expose it to GC
				if ( typeof elem[ name ] === strundefined ) {
					elem[ name ] = null;
				}
	
				elem.detachEvent( name, handle );
			}
		};
	
	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: IE < 9, Android < 4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
			if ( !e ) {
				return;
			}
	
			// If preventDefault exists, run it on the original event
			if ( e.preventDefault ) {
				e.preventDefault();
	
			// Support: IE
			// Otherwise set the returnValue property of the original event to false
			} else {
				e.returnValue = false;
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
			if ( !e ) {
				return;
			}
			// If stopPropagation exists, run it on the original event
			if ( e.stopPropagation ) {
				e.stopPropagation();
			}
	
			// Support: IE
			// Set the cancelBubble property of the original event to true
			e.cancelBubble = true;
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});
	
	// IE submit delegation
	if ( !support.submitBubbles ) {
	
		jQuery.event.special.submit = {
			setup: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}
	
				// Lazy-add a submit handler when a descendant form may potentially be submitted
				jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
					// Node name check avoids a VML-related crash in IE (#9807)
					var elem = e.target,
						form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
					if ( form && !jQuery._data( form, "submitBubbles" ) ) {
						jQuery.event.add( form, "submit._submit", function( event ) {
							event._submit_bubble = true;
						});
						jQuery._data( form, "submitBubbles", true );
					}
				});
				// return undefined since we don't need an event listener
			},
	
			postDispatch: function( event ) {
				// If form was submitted by the user, bubble the event up the tree
				if ( event._submit_bubble ) {
					delete event._submit_bubble;
					if ( this.parentNode && !event.isTrigger ) {
						jQuery.event.simulate( "submit", this.parentNode, event, true );
					}
				}
			},
	
			teardown: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}
	
				// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
				jQuery.event.remove( this, "._submit" );
			}
		};
	}
	
	// IE change delegation and checkbox/radio fix
	if ( !support.changeBubbles ) {
	
		jQuery.event.special.change = {
	
			setup: function() {
	
				if ( rformElems.test( this.nodeName ) ) {
					// IE doesn't fire change on a check/radio until blur; trigger it on click
					// after a propertychange. Eat the blur-change in special.change.handle.
					// This still fires onchange a second time for check/radio after blur.
					if ( this.type === "checkbox" || this.type === "radio" ) {
						jQuery.event.add( this, "propertychange._change", function( event ) {
							if ( event.originalEvent.propertyName === "checked" ) {
								this._just_changed = true;
							}
						});
						jQuery.event.add( this, "click._change", function( event ) {
							if ( this._just_changed && !event.isTrigger ) {
								this._just_changed = false;
							}
							// Allow triggered, simulated change events (#11500)
							jQuery.event.simulate( "change", this, event, true );
						});
					}
					return false;
				}
				// Delegated event; lazy-add a change handler on descendant inputs
				jQuery.event.add( this, "beforeactivate._change", function( e ) {
					var elem = e.target;
	
					if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
						jQuery.event.add( elem, "change._change", function( event ) {
							if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
								jQuery.event.simulate( "change", this.parentNode, event, true );
							}
						});
						jQuery._data( elem, "changeBubbles", true );
					}
				});
			},
	
			handle: function( event ) {
				var elem = event.target;
	
				// Swallow native change events from checkbox/radio, we already triggered them above
				if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
					return event.handleObj.handler.apply( this, arguments );
				}
			},
	
			teardown: function() {
				jQuery.event.remove( this, "._change" );
	
				return !rformElems.test( this.nodeName );
			}
		};
	}
	
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = jQuery._data( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = jQuery._data( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						jQuery._removeData( doc, fix );
					} else {
						jQuery._data( doc, fix, attaches );
					}
				}
			};
		});
	}
	
	jQuery.fn.extend({
	
		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var type, origFn;
	
			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}
	
			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}
	
			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},
	
		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});
	
	
	function createSafeFragment( document ) {
		var list = nodeNames.split( "|" ),
			safeFrag = document.createDocumentFragment();
	
		if ( safeFrag.createElement ) {
			while ( list.length ) {
				safeFrag.createElement(
					list.pop()
				);
			}
		}
		return safeFrag;
	}
	
	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
			"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
		rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
		rleadingWhitespace = /^\s+/,
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rtbody = /<tbody/i,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	
		// We have to close these tags to support XHTML (#13200)
		wrapMap = {
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
			legend: [ 1, "<fieldset>", "</fieldset>" ],
			area: [ 1, "<map>", "</map>" ],
			param: [ 1, "<object>", "</object>" ],
			thead: [ 1, "<table>", "</table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
			// unless wrapped in a div with non-breaking characters in front of it.
			_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
		},
		safeFragment = createSafeFragment( document ),
		fragmentDiv = safeFragment.appendChild( document.createElement("div") );
	
	wrapMap.optgroup = wrapMap.option;
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	function getAll( context, tag ) {
		var elems, elem,
			i = 0,
			found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
				undefined;
	
		if ( !found ) {
			for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
				if ( !tag || jQuery.nodeName( elem, tag ) ) {
					found.push( elem );
				} else {
					jQuery.merge( found, getAll( elem, tag ) );
				}
			}
		}
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], found ) :
			found;
	}
	
	// Used in buildFragment, fixes the defaultChecked property
	function fixDefaultChecked( elem ) {
		if ( rcheckableType.test( elem.type ) ) {
			elem.defaultChecked = elem.checked;
		}
	}
	
	// Support: IE<8
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
		if ( match ) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}
		return elem;
	}
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var elem,
			i = 0;
		for ( ; (elem = elems[i]) != null; i++ ) {
			jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
		}
	}
	
	function cloneCopyEvent( src, dest ) {
	
		if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
			return;
		}
	
		var type, i, l,
			oldData = jQuery._data( src ),
			curData = jQuery._data( dest, oldData ),
			events = oldData.events;
	
		if ( events ) {
			delete curData.handle;
			curData.events = {};
	
			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	
		// make the cloned public data object a copy from the original
		if ( curData.data ) {
			curData.data = jQuery.extend( {}, curData.data );
		}
	}
	
	function fixCloneNodeIssues( src, dest ) {
		var nodeName, e, data;
	
		// We do not need to do anything for non-Elements
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		nodeName = dest.nodeName.toLowerCase();
	
		// IE6-8 copies events bound via attachEvent when using cloneNode.
		if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
			data = jQuery._data( dest );
	
			for ( e in data.events ) {
				jQuery.removeEvent( dest, e, data.handle );
			}
	
			// Event data gets referenced instead of copied if the expando gets copied too
			dest.removeAttribute( jQuery.expando );
		}
	
		// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
		if ( nodeName === "script" && dest.text !== src.text ) {
			disableScript( dest ).text = src.text;
			restoreScript( dest );
	
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		} else if ( nodeName === "object" ) {
			if ( dest.parentNode ) {
				dest.outerHTML = src.outerHTML;
			}
	
			// This path appears unavoidable for IE9. When cloning an object
			// element in IE9, the outerHTML strategy above is not sufficient.
			// If the src has innerHTML and the destination does not,
			// copy the src.innerHTML into the dest.innerHTML. #10324
			if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
				dest.innerHTML = src.innerHTML;
			}
	
		} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			// IE6-8 fails to persist the checked state of a cloned checkbox
			// or radio button. Worse, IE6-7 fail to give the cloned element
			// a checked appearance if the defaultChecked value isn't also set
	
			dest.defaultChecked = dest.checked = src.checked;
	
			// IE6-7 get confused and end up setting the value of a cloned
			// checkbox/radio button to an empty string instead of "on"
			if ( dest.value !== src.value ) {
				dest.value = src.value;
			}
	
		// IE6-8 fails to return the selected option to the default selected
		// state when cloning options
		} else if ( nodeName === "option" ) {
			dest.defaultSelected = dest.selected = src.defaultSelected;
	
		// IE6-8 fails to set the defaultValue to the correct value when
		// cloning other types of input fields
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var destElements, node, clone, i, srcElements,
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
				clone = elem.cloneNode( true );
	
			// IE<=8 does not properly clone detached, unknown element nodes
			} else {
				fragmentDiv.innerHTML = elem.outerHTML;
				fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
			}
	
			if ( (!support.noCloneEvent || !support.noCloneChecked) &&
					(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				// Fix all IE cloning issues
				for ( i = 0; (node = srcElements[i]) != null; ++i ) {
					// Ensure that the destination node is not null; Fixes #9587
					if ( destElements[i] ) {
						fixCloneNodeIssues( node, destElements[i] );
					}
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0; (node = srcElements[i]) != null; i++ ) {
						cloneCopyEvent( node, destElements[i] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			destElements = srcElements = node = null;
	
			// Return the cloned set
			return clone;
		},
	
		buildFragment: function( elems, context, scripts, selection ) {
			var j, elem, contains,
				tmp, tag, tbody, wrap,
				l = elems.length,
	
				// Ensure a safe fragment
				safe = createSafeFragment( context ),
	
				nodes = [],
				i = 0;
	
			for ( ; i < l; i++ ) {
				elem = elems[ i ];
	
				if ( elem || elem === 0 ) {
	
					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );
	
					// Convert html into DOM nodes
					} else {
						tmp = tmp || safe.appendChild( context.createElement("div") );
	
						// Deserialize a standard representation
						tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
	
						tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];
	
						// Descend through wrappers to the right content
						j = wrap[0];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}
	
						// Manually add leading whitespace removed by IE
						if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
							nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
						}
	
						// Remove IE's autoinserted <tbody> from table fragments
						if ( !support.tbody ) {
	
							// String was a <table>, *may* have spurious <tbody>
							elem = tag === "table" && !rtbody.test( elem ) ?
								tmp.firstChild :
	
								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !rtbody.test( elem ) ?
									tmp :
									0;
	
							j = elem && elem.childNodes.length;
							while ( j-- ) {
								if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
									elem.removeChild( tbody );
								}
							}
						}
	
						jQuery.merge( nodes, tmp.childNodes );
	
						// Fix #12392 for WebKit and IE > 9
						tmp.textContent = "";
	
						// Fix #12392 for oldIE
						while ( tmp.firstChild ) {
							tmp.removeChild( tmp.firstChild );
						}
	
						// Remember the top-level container for proper cleanup
						tmp = safe.lastChild;
					}
				}
			}
	
			// Fix #11356: Clear elements from fragment
			if ( tmp ) {
				safe.removeChild( tmp );
			}
	
			// Reset defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			if ( !support.appendChecked ) {
				jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
			}
	
			i = 0;
			while ( (elem = nodes[ i++ ]) ) {
	
				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}
	
				contains = jQuery.contains( elem.ownerDocument, elem );
	
				// Append to fragment
				tmp = getAll( safe.appendChild( elem ), "script" );
	
				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}
	
				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}
	
			tmp = null;
	
			return safe;
		},
	
		cleanData: function( elems, /* internal */ acceptData ) {
			var elem, type, id, data,
				i = 0,
				internalKey = jQuery.expando,
				cache = jQuery.cache,
				deleteExpando = support.deleteExpando,
				special = jQuery.event.special;
	
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( acceptData || jQuery.acceptData( elem ) ) {
	
					id = elem[ internalKey ];
					data = id && cache[ id ];
	
					if ( data ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Remove cache only if it was not already removed by jQuery.event.remove
						if ( cache[ id ] ) {
	
							delete cache[ id ];
	
							// IE does not allow us to delete expando properties from nodes,
							// nor does it have a removeAttribute function on Document nodes;
							// we must handle all of these cases
							if ( deleteExpando ) {
								delete elem[ internalKey ];
	
							} else if ( typeof elem.removeAttribute !== strundefined ) {
								elem.removeAttribute( internalKey );
	
							} else {
								elem[ internalKey ] = null;
							}
	
							deletedIds.push( id );
						}
					}
				}
			}
		}
	});
	
	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},
	
		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},
	
		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},
	
		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},
	
		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;
	
			for ( ; (elem = elems[i]) != null; i++ ) {
	
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}
	
				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}
	
			return this;
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; (elem = this[i]) != null; i++ ) {
				// Remove element nodes and prevent memory leaks
				if ( elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem, false ) );
				}
	
				// Remove any remaining nodes
				while ( elem.firstChild ) {
					elem.removeChild( elem.firstChild );
				}
	
				// If this is a select, ensure that it displays empty (#12336)
				// Support: IE<9
				if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
					elem.options.length = 0;
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined ) {
					return elem.nodeType === 1 ?
						elem.innerHTML.replace( rinlinejQuery, "" ) :
						undefined;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
					( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
					!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {
	
					value = value.replace( rxhtmlTag, "<$1></$2>" );
	
					try {
						for (; i < l; i++ ) {
							// Remove element nodes and prevent memory leaks
							elem = this[i] || {};
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch(e) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var arg = arguments[ 0 ];
	
			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;
	
				jQuery.cleanData( getAll( this ) );
	
				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});
	
			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},
	
		detach: function( selector ) {
			return this.remove( selector, true );
		},
	
		domManip: function( args, callback ) {
	
			// Flatten any nested arrays
			args = concat.apply( [], args );
	
			var first, node, hasScripts,
				scripts, doc, fragment,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[0],
				isFunction = jQuery.isFunction( value );
	
			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[0] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}
	
			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;
	
				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}
	
				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;
	
					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;
	
						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );
	
							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}
	
						callback.call( this[i], node, i );
					}
	
					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;
	
						// Reenable scripts
						jQuery.map( scripts, restoreScript );
	
						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
	
								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
								}
							}
						}
					}
	
					// Fix #11809: Avoid leaking memory
					fragment = first = null;
				}
			}
	
			return this;
		}
	});
	
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				i = 0,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone(true);
				jQuery( insert[i] )[ original ]( elems );
	
				// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	});
	
	
	var iframe,
		elemdisplay = {};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?
	
				// Use of this method is a temporary fix (more like optmization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	
	
	(function() {
		var shrinkWrapBlocksVal;
	
		support.shrinkWrapBlocks = function() {
			if ( shrinkWrapBlocksVal != null ) {
				return shrinkWrapBlocksVal;
			}
	
			// Will be changed later if needed.
			shrinkWrapBlocksVal = false;
	
			// Minified: var b,c,d
			var div, body, container;
	
			body = document.getElementsByTagName( "body" )[ 0 ];
			if ( !body || !body.style ) {
				// Test fired too early or in an unsupported environment, exit.
				return;
			}
	
			// Setup
			div = document.createElement( "div" );
			container = document.createElement( "div" );
			container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
			body.appendChild( container ).appendChild( div );
	
			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			if ( typeof div.style.zoom !== strundefined ) {
				// Reset CSS: box-sizing; display; margin; border
				div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;" +
					"padding:1px;width:1px;zoom:1";
				div.appendChild( document.createElement( "div" ) ).style.width = "5px";
				shrinkWrapBlocksVal = div.offsetWidth !== 3;
			}
	
			body.removeChild( container );
	
			return shrinkWrapBlocksVal;
		};
	
	})();
	var rmargin = (/^margin/);
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	
	
	var getStyles, curCSS,
		rposition = /^(top|right|bottom|left)$/;
	
	if ( window.getComputedStyle ) {
		getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}
	
			return window.getComputedStyle( elem, null );
		};
	
		curCSS = function( elem, name, computed ) {
			var width, minWidth, maxWidth, ret,
				style = elem.style;
	
			computed = computed || getStyles( elem );
	
			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
	
			if ( computed ) {
	
				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
					ret = jQuery.style( elem, name );
				}
	
				// A tribute to the "awesome hack by Dean Edwards"
				// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
				// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
				if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;
	
					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;
	
					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}
	
			// Support: IE
			// IE returns zIndex value as an integer.
			return ret === undefined ?
				ret :
				ret + "";
		};
	} else if ( document.documentElement.currentStyle ) {
		getStyles = function( elem ) {
			return elem.currentStyle;
		};
	
		curCSS = function( elem, name, computed ) {
			var left, rs, rsLeft, ret,
				style = elem.style;
	
			computed = computed || getStyles( elem );
			ret = computed ? computed[ name ] : undefined;
	
			// Avoid setting ret to empty string here
			// so we don't default to auto
			if ( ret == null && style && style[ name ] ) {
				ret = style[ name ];
			}
	
			// From the awesome hack by Dean Edwards
			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	
			// If we're not dealing with a regular pixel number
			// but a number that has a weird ending, we need to convert it to pixels
			// but not position css attributes, as those are proportional to the parent element instead
			// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
			if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
	
				// Remember the original values
				left = style.left;
				rs = elem.runtimeStyle;
				rsLeft = rs && rs.left;
	
				// Put in the new values to get a computed value out
				if ( rsLeft ) {
					rs.left = elem.currentStyle.left;
				}
				style.left = name === "fontSize" ? "1em" : ret;
				ret = style.pixelLeft + "px";
	
				// Revert the changed values
				style.left = left;
				if ( rsLeft ) {
					rs.left = rsLeft;
				}
			}
	
			// Support: IE
			// IE returns zIndex value as an integer.
			return ret === undefined ?
				ret :
				ret + "" || "auto";
		};
	}
	
	
	
	
	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				var condition = conditionFn();
	
				if ( condition == null ) {
					// The test was not ready at this point; screw the hook this time
					// but check again when needed next time.
					return;
				}
	
				if ( condition ) {
					// Hook not needed (or it's not possible to use it due to missing dependency),
					// remove it.
					// Since there are no other hooks for marginRight, remove the whole object.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
	
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}
	
	
	(function() {
		// Minified: var b,c,d,e,f,g, h,i
		var div, style, a, pixelPositionVal, boxSizingReliableVal,
			reliableHiddenOffsetsVal, reliableMarginRightVal;
	
		// Setup
		div = document.createElement( "div" );
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
		a = div.getElementsByTagName( "a" )[ 0 ];
		style = a && a.style;
	
		// Finish early in limited (non-browser) environments
		if ( !style ) {
			return;
		}
	
		style.cssText = "float:left;opacity:.5";
	
		// Support: IE<9
		// Make sure that element opacity exists (as opposed to filter)
		support.opacity = style.opacity === "0.5";
	
		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		support.cssFloat = !!style.cssFloat;
	
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		// Support: Firefox<29, Android 2.3
		// Vendor-prefix box-sizing
		support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
			style.WebkitBoxSizing === "";
	
		jQuery.extend(support, {
			reliableHiddenOffsets: function() {
				if ( reliableHiddenOffsetsVal == null ) {
					computeStyleTests();
				}
				return reliableHiddenOffsetsVal;
			},
	
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
	
			pixelPosition: function() {
				if ( pixelPositionVal == null ) {
					computeStyleTests();
				}
				return pixelPositionVal;
			},
	
			// Support: Android 2.3
			reliableMarginRight: function() {
				if ( reliableMarginRightVal == null ) {
					computeStyleTests();
				}
				return reliableMarginRightVal;
			}
		});
	
		function computeStyleTests() {
			// Minified: var b,c,d,j
			var div, body, container, contents;
	
			body = document.getElementsByTagName( "body" )[ 0 ];
			if ( !body || !body.style ) {
				// Test fired too early or in an unsupported environment, exit.
				return;
			}
	
			// Setup
			div = document.createElement( "div" );
			container = document.createElement( "div" );
			container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
			body.appendChild( container ).appendChild( div );
	
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
	
			// Support: IE<9
			// Assume reasonable values in the absence of getComputedStyle
			pixelPositionVal = boxSizingReliableVal = false;
			reliableMarginRightVal = true;
	
			// Check for getComputedStyle so that this code is not run in IE<9.
			if ( window.getComputedStyle ) {
				pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
				boxSizingReliableVal =
					( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
	
				// Support: Android 2.3
				// Div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				contents = div.appendChild( document.createElement( "div" ) );
	
				// Reset CSS: box-sizing; display; margin; border; padding
				contents.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				contents.style.marginRight = contents.style.width = "0";
				div.style.width = "1px";
	
				reliableMarginRightVal =
					!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );
	
				div.removeChild( contents );
			}
	
			// Support: IE8
			// Check if table cells still have offsetWidth/Height when they are set
			// to display:none and there are still other visible table cells in a
			// table row; if so, offsetWidth/Height are not reliable for use when
			// determining if an element has been hidden directly using
			// display:none (it is still safe to use offsets if a parent element is
			// hidden; don safety goggles and see bug #4512 for more information).
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			contents = div.getElementsByTagName( "td" );
			contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
			if ( reliableHiddenOffsetsVal ) {
				contents[ 0 ].style.display = "";
				contents[ 1 ].style.display = "none";
				reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
			}
	
			body.removeChild( container );
		}
	
	})();
	
	
	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var
			ralpha = /alpha\([^)]*\)/i,
		ropacity = /opacity\s*=\s*([^)]*)/,
	
		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
	
	
	// return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {
	
		// shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}
	
		// check for vendor prefixed names
		var capName = name.charAt(0).toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}
	
		return origName;
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = jQuery._data( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
			// both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// at this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// at this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// at this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}
	
			// we need the check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend({
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			// normalize float css property
			"float": support.cssFloat ? "cssFloat" : "styleFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
	
			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// convert relative number strings (+= or -=) to relative numbers. #7345
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set. See: #7116
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}
	
				// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
				// but it would mean to define eight (for every problematic property) identical functions
				if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
	
					// Support: IE
					// Swallow errors from 'invalid' CSS values (#5509)
					try {
						style[ name ] = value;
					} catch(e) {}
				}
	
			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var num, val, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
	
			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			//convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Return, converting to number if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});
	
	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
					// certain elements can have dimension info if we invisibly show them
					// however, it must have a current display style that would benefit from this
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});
	
	if ( !support.opacity ) {
		jQuery.cssHooks.opacity = {
			get: function( elem, computed ) {
				// IE uses filters for opacity
				return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
					computed ? "1" : "";
			},
	
			set: function( elem, value ) {
				var style = elem.style,
					currentStyle = elem.currentStyle,
					opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
					filter = currentStyle && currentStyle.filter || style.filter || "";
	
				// IE has trouble with opacity if it does not have layout
				// Force it by setting the zoom level
				style.zoom = 1;
	
				// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
				// if value === "", then remove inline opacity #12685
				if ( ( value >= 1 || value === "" ) &&
						jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
						style.removeAttribute ) {
	
					// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
					// if "filter:" is present at all, clearType is disabled, we want to avoid this
					// style.removeAttribute is IE Only, but so apparently is this code path...
					style.removeAttribute( "filter" );
	
					// if there is no filter style applied in a css rule or unset inline opacity, we are done
					if ( value === "" || currentStyle && !currentStyle.filter ) {
						return;
					}
				}
	
				// otherwise, set new filter values
				style.filter = ralpha.test( filter ) ?
					filter.replace( ralpha, opacity ) :
					filter + " " + opacity;
			}
		};
	}
	
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});
	
	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}
	
				// passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails
				// so, simple values such as "10px" are parsed to Float.
				// complex values such as "rotate(1rad)" are returned as is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// use step hook for back compat - use cssHook if its there - use .style if its
				// available and use plain properties where available
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9
	// Panic based approach to setting things on disconnected nodes
	
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;
	
				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];
	
					// Make sure we update the tween properties later on
					parts = parts || [];
	
					// Iteratively approximate from a nonzero starting point
					start = +target || 1;
	
					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";
	
						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );
	
					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}
	
				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}
	
				return tween;
			} ]
		};
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			attrs = { height: type },
			i = 0;
	
		// if we include width, step value is 1 to do all cssExpand values,
		// if we don't include width, step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {
	
				// we're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = jQuery._data( elem, "fxshow" );
	
		// handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always(function() {
				// doing this makes sure that the complete handler will be called
				// before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}
	
		// height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE does not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
	
				// inline-level elements accept inline-block;
				// block-level elements need to be inline with layout
				if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
					style.display = "inline-block";
				} else {
					style.zoom = 1;
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			if ( !support.shrinkWrapBlocks() ) {
				anim.always(function() {
					style.overflow = opts.overflow[ 0 ];
					style.overflowX = opts.overflow[ 1 ];
					style.overflowY = opts.overflow[ 2 ];
				});
			}
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = jQuery._data( elem, "fxshow", {} );
			}
	
			// store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;
				jQuery._removeData( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// not quite $.extend, this wont overwrite keys already present.
				// also - reusing 'index' from above because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ]);
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// if we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// resolve when we played the last frame
					// otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {
	
			// show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || jQuery._data( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = jQuery._data( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// start the next in the queue if the last step wasn't forced
				// timers currently will call their complete callbacks, which will dequeue
				// but only if they were gotoEnd
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = jQuery._data( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// enable finishing flag on private data
				data.finish = true;
	
				// empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// turn off finishing flag
				delete data.finish;
			});
		}
	});
	
	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});
	
	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			timers = jQuery.timers,
			i = 0;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};
	
	
	(function() {
		// Minified: var a,b,c,d,e
		var input, div, select, a, opt;
	
		// Setup
		div = document.createElement( "div" );
		div.setAttribute( "className", "t" );
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
		a = div.getElementsByTagName("a")[ 0 ];
	
		// First batch of tests.
		select = document.createElement("select");
		opt = select.appendChild( document.createElement("option") );
		input = div.getElementsByTagName("input")[ 0 ];
	
		a.style.cssText = "top:1px";
	
		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		support.getSetAttribute = div.className !== "t";
	
		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		support.style = /top/.test( a.getAttribute("style") );
	
		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		support.hrefNormalized = a.getAttribute("href") === "/a";
	
		// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
		support.checkOn = !!input.value;
	
		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		support.optSelected = opt.selected;
	
		// Tests for enctype support on a form (#6743)
		support.enctype = !!document.createElement("form").enctype;
	
		// Make sure that the options inside disabled selects aren't marked as disabled
		// (WebKit marks them as disabled)
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE8 only
		// Check if we can trust getAttribute("value")
		input = document.createElement( "input" );
		input.setAttribute( "value", "" );
		support.input = input.getAttribute( "value" ) === "";
	
		// Check if an input maintains its value after becoming a radio
		input.value = "t";
		input.setAttribute( "type", "radio" );
		support.radioValue = input.value === "t";
	})();
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
						// handle most common string cases
						ret.replace(rreturn, "") :
						// handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each(function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
				} else if ( typeof val === "number" ) {
					val += "";
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});
	
	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// oldIE doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {
	
							// Support: IE6
							// When new option element is added to select box we need to
							// force reflow of newly added node in order to workaround delay
							// of initialization properties
							try {
								option.selected = optionSet = true;
	
							} catch ( _ ) {
	
								// Will be executed only in IE6
								option.scrollHeight;
							}
	
						} else {
							option.selected = false;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
	
					return options;
				}
			}
		}
	});
	
	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				// Support: Webkit
				// "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});
	
	
	
	
	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle,
		ruseDefault = /^(?:checked|selected)$/i,
		getSetAttribute = support.getSetAttribute,
		getSetInput = support.input;
	
	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});
	
	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;
	
			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}
	
			if ( value !== undefined ) {
	
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
	
				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;
	
				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}
	
			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;
	
			} else {
				ret = jQuery.find.attr( elem, name );
	
				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
							elem[ propName ] = false;
						// Support: IE<9
						// Also clear defaultChecked/defaultSelected (if appropriate)
						} else {
							elem[ jQuery.camelCase( "default-" + name ) ] =
								elem[ propName ] = false;
						}
	
					// See #9699 for explanation of this approach (setting first, then removal)
					} else {
						jQuery.attr( elem, name, "" );
					}
	
					elem.removeAttribute( getSetAttribute ? name : propName );
				}
			}
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
						// Setting the type on a radio button after the value resets the value in IE6-9
						// Reset value to default in case type is set after value during creation
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});
	
	// Hook for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
				// IE<8 needs the *property* name
				elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
	
			// Use defaultChecked and defaultSelected for oldIE
			} else {
				elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
			}
	
			return name;
		}
	};
	
	// Retrieve booleans specially
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
			function( elem, name, isXML ) {
				var ret, handle;
				if ( !isXML ) {
					// Avoid an infinite loop by temporarily removing this function from the getter
					handle = attrHandle[ name ];
					attrHandle[ name ] = ret;
					ret = getter( elem, name, isXML ) != null ?
						name.toLowerCase() :
						null;
					attrHandle[ name ] = handle;
				}
				return ret;
			} :
			function( elem, name, isXML ) {
				if ( !isXML ) {
					return elem[ jQuery.camelCase( "default-" + name ) ] ?
						name.toLowerCase() :
						null;
				}
			};
	});
	
	// fix oldIE attroperties
	if ( !getSetInput || !getSetAttribute ) {
		jQuery.attrHooks.value = {
			set: function( elem, value, name ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					// Does not return so that setAttribute is also used
					elem.defaultValue = value;
				} else {
					// Use nodeHook if defined (#1954); otherwise setAttribute is fine
					return nodeHook && nodeHook.set( elem, value, name );
				}
			}
		};
	}
	
	// IE6/7 do not support getting/setting some attributes with get/setAttribute
	if ( !getSetAttribute ) {
	
		// Use this for any attribute in IE6/7
		// This fixes almost every IE6/7 issue
		nodeHook = {
			set: function( elem, value, name ) {
				// Set the existing or create a new attribute node
				var ret = elem.getAttributeNode( name );
				if ( !ret ) {
					elem.setAttributeNode(
						(ret = elem.ownerDocument.createAttribute( name ))
					);
				}
	
				ret.value = value += "";
	
				// Break association with cloned elements by also using setAttribute (#9646)
				if ( name === "value" || value === elem.getAttribute( name ) ) {
					return value;
				}
			}
		};
	
		// Some attributes are constructed with empty-string values when not defined
		attrHandle.id = attrHandle.name = attrHandle.coords =
			function( elem, name, isXML ) {
				var ret;
				if ( !isXML ) {
					return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
						ret.value :
						null;
				}
			};
	
		// Fixing value retrieval on a button requires this module
		jQuery.valHooks.button = {
			get: function( elem, name ) {
				var ret = elem.getAttributeNode( name );
				if ( ret && ret.specified ) {
					return ret.value;
				}
			},
			set: nodeHook.set
		};
	
		// Set contenteditable to false on removals(#10429)
		// Setting to empty string throws an error as an invalid value
		jQuery.attrHooks.contenteditable = {
			set: function( elem, value, name ) {
				nodeHook.set( elem, value === "" ? false : value, name );
			}
		};
	
		// Set width and height to auto instead of 0 on empty string( Bug #8150 )
		// This is for removals
		jQuery.each([ "width", "height" ], function( i, name ) {
			jQuery.attrHooks[ name ] = {
				set: function( elem, value ) {
					if ( value === "" ) {
						elem.setAttribute( name, "auto" );
						return value;
					}
				}
			};
		});
	}
	
	if ( !support.style ) {
		jQuery.attrHooks.style = {
			get: function( elem ) {
				// Return undefined in the case of empty string
				// Note: IE uppercases css property names, but if we were to .toLowerCase()
				// .cssText, that would destroy case senstitivity in URL's, like in "background"
				return elem.style.cssText || undefined;
			},
			set: function( elem, value ) {
				return ( elem.style.cssText = value + "" );
			}
		};
	}
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button|object)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			name = jQuery.propFix[ name ] || name;
			return this.each(function() {
				// try/catch handles cases where IE balks (such as removing a property on window)
				try {
					this[ name ] = undefined;
					delete this[ name ];
				} catch( e ) {}
			});
		}
	});
	
	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},
	
		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;
	
			// don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
	
			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );
	
			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
					// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
				}
			}
		}
	});
	
	// Some attributes require a special call on IE
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !support.hrefNormalized ) {
		// href/src property should get the full normalized URL (#10299/#12915)
		jQuery.each([ "href", "src" ], function( i, name ) {
			jQuery.propHooks[ name ] = {
				get: function( elem ) {
					return elem.getAttribute( name, 4 );
				}
			};
		});
	}
	
	// Support: Safari, IE9+
	// mis-reports the default selected property of an option
	// Accessing the parent's selectedIndex property fixes it
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
	
				if ( parent ) {
					parent.selectedIndex;
	
					// Make sure that it also works with optgroups, see #5701
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
				return null;
			}
		};
	}
	
	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});
	
	// IE6/7 call enctype encoding
	if ( !support.enctype ) {
		jQuery.propFix.enctype = "encoding";
	}
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				i = 0,
				len = this.length,
				proceed = typeof value === "string" && value;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}
	
			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				i = 0,
				len = this.length,
				proceed = arguments.length === 0 || typeof value === "string" && value;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}
	
			return this.each(function() {
				if ( type === "string" ) {
					// toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];
	
					while ( (className = classNames[ i++ ]) ) {
						// check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						jQuery._data( this, "__className__", this.className );
					}
	
					// If the element has a class name or if we're passed "false",
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
				}
			});
		},
	
		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}
	
			return false;
		}
	});
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});
	
	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});
	
	
	var nonce = jQuery.now();
	
	var rquery = (/\?/);
	
	
	
	var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
	
	jQuery.parseJSON = function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			// Support: Android 2.3
			// Workaround failure to string-cast null input
			return window.JSON.parse( data + "" );
		}
	
		var requireNonComma,
			depth = null,
			str = jQuery.trim( data + "" );
	
		// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
		// after removing valid tokens
		return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {
	
			// Force termination if we see a misplaced comma
			if ( requireNonComma && comma ) {
				depth = 0;
			}
	
			// Perform no more replacements after returning to outermost depth
			if ( depth === 0 ) {
				return token;
			}
	
			// Commas must not follow "[", "{", or ","
			requireNonComma = open || comma;
	
			// Determine new depth
			// array/object open ("[" or "{"): depth += true - false (increment)
			// array/object close ("]" or "}"): depth += false - true (decrement)
			// other cases ("," or primitive): depth += true - true (numeric cast)
			depth += !close - !open;
	
			// Remove this token
			return "";
		}) ) ?
			( Function( "return " + str ) )() :
			jQuery.error( "Invalid JSON: " + data );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data, "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		// Document location
		ajaxLocParts,
		ajaxLocation,
	
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*");
	
	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	try {
		ajaxLocation = location.href;
	} catch( e ) {
		// Use the href attribute of an A element
		// since IE will modify it given document.location
		ajaxLocation = document.createElement( "a" );
		ajaxLocation.href = "";
		ajaxLocation = ajaxLocation.href;
	}
	
	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType.charAt( 0 ) === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
	
					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var deep, key,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
		var firstDataType, ct, finalDataType, type,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend({
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var // Cross-domain detection vars
				parts,
				// Loop variable
				i,
				// URL without anti-cache param
				cacheURL,
				// Response headers as string
				responseHeadersString,
				// timeout handle
				timeoutTimer,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				transport,
				// Response headers
				responseHeaders,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// We extract error from statusText
					// then normalize statusText and status for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};
	
	
	jQuery.fn.extend({
		wrapAll: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapAll( html.call(this, i) );
				});
			}
	
			if ( this[0] ) {
				// The elements to wrap the target around
				var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
	
				if ( this[0].parentNode ) {
					wrap.insertBefore( this[0] );
				}
	
				wrap.map(function() {
					var elem = this;
	
					while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
						elem = elem.firstChild;
					}
	
					return elem;
				}).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapInner( html.call(this, i) );
				});
			}
	
			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			});
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each(function(i) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},
	
		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!support.reliableHiddenOffsets() &&
				((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};
	
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
	
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;
				// Use .is(":disabled") so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});
	
	
	// Create the request object
	// (This is still attached to ajaxSettings for backward compatibility)
	jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
		// Support: IE6+
		function() {
	
			// XHR cannot access local files, always use ActiveX for that case
			return !this.isLocal &&
	
				// Support: IE7-8
				// oldIE XHR does not support non-RFC2616 methods (#13240)
				// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
				// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
				// Although this check for six methods instead of eight
				// since IE also does not support "trace" and "connect"
				/^(get|post|head|put|delete|options)$/i.test( this.type ) &&
	
				createStandardXHR() || createActiveXHR();
		} :
		// For all other browsers, use the standard XMLHttpRequest object
		createStandardXHR;
	
	var xhrId = 0,
		xhrCallbacks = {},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	// Support: IE<10
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]( undefined, true );
			}
		});
	}
	
	// Determine support properties
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	xhrSupported = support.ajax = !!xhrSupported;
	
	// Create transport if the browser can provide an xhr
	if ( xhrSupported ) {
	
		jQuery.ajaxTransport(function( options ) {
			// Cross domain only allowed if supported through XMLHttpRequest
			if ( !options.crossDomain || support.cors ) {
	
				var callback;
	
				return {
					send: function( headers, complete ) {
						var i,
							xhr = options.xhr(),
							id = ++xhrId;
	
						// Open the socket
						xhr.open( options.type, options.url, options.async, options.username, options.password );
	
						// Apply custom fields if provided
						if ( options.xhrFields ) {
							for ( i in options.xhrFields ) {
								xhr[ i ] = options.xhrFields[ i ];
							}
						}
	
						// Override mime type if needed
						if ( options.mimeType && xhr.overrideMimeType ) {
							xhr.overrideMimeType( options.mimeType );
						}
	
						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if ( !options.crossDomain && !headers["X-Requested-With"] ) {
							headers["X-Requested-With"] = "XMLHttpRequest";
						}
	
						// Set headers
						for ( i in headers ) {
							// Support: IE<9
							// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
							// request header to a null-value.
							//
							// To keep consistent with other XHR implementations, cast the value
							// to string and ignore `undefined`.
							if ( headers[ i ] !== undefined ) {
								xhr.setRequestHeader( i, headers[ i ] + "" );
							}
						}
	
						// Do send the request
						// This may raise an exception which is actually
						// handled in jQuery.ajax (so no try/catch here)
						xhr.send( ( options.hasContent && options.data ) || null );
	
						// Listener
						callback = function( _, isAbort ) {
							var status, statusText, responses;
	
							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
								// Clean up
								delete xhrCallbacks[ id ];
								callback = undefined;
								xhr.onreadystatechange = jQuery.noop;
	
								// Abort manually if needed
								if ( isAbort ) {
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
	
									// Support: IE<10
									// Accessing binary-data responseText throws an exception
									// (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}
	
									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}
	
									// Filter status for non standard behaviors
	
									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && options.isLocal && !options.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
	
							// Call complete if needed
							if ( responses ) {
								complete( status, statusText, responses, xhr.getAllResponseHeaders() );
							}
						};
	
						if ( !options.async ) {
							// if we're in sync mode we fire the callback
							callback();
						} else if ( xhr.readyState === 4 ) {
							// (IE6 & IE7) if it's in cache and has been
							// retrieved directly we need to fire the callback
							setTimeout( callback );
						} else {
							// Add to the list of active xhr callbacks
							xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
						}
					},
	
					abort: function() {
						if ( callback ) {
							callback( undefined, true );
						}
					}
				};
			}
		});
	}
	
	// Functions to create xhrs
	function createStandardXHR() {
		try {
			return new window.XMLHttpRequest();
		} catch( e ) {}
	}
	
	function createActiveXHR() {
		try {
			return new window.ActiveXObject( "Microsoft.XMLHTTP" );
		} catch( e ) {}
	}
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});
	
	// Handle cache's special case and global
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
			s.global = false;
		}
	});
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function(s) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
	
			var script,
				head = document.head || jQuery("head")[0] || document.documentElement;
	
			return {
	
				send: function( _, callback ) {
	
					script = document.createElement("script");
	
					script.async = true;
	
					if ( s.scriptCharset ) {
						script.charset = s.scriptCharset;
					}
	
					script.src = s.url;
	
					// Attach handlers for all browsers
					script.onload = script.onreadystatechange = function( _, isAbort ) {
	
						if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
	
							// Handle memory leak in IE
							script.onload = script.onreadystatechange = null;
	
							// Remove the script
							if ( script.parentNode ) {
								script.parentNode.removeChild( script );
							}
	
							// Dereference the script
							script = null;
	
							// Callback if not abort
							if ( !isAbort ) {
								callback( 200, "success" );
							}
						}
					};
	
					// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					head.insertBefore( script, head.firstChild );
				},
	
				abort: function() {
					if ( script ) {
						script.onload( undefined, true );
					}
				}
			};
		}
	});
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;
	
				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			});
	
			// Delegate to script
			return "script";
		}
	});
	
	
	
	
	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}
	
		parsed = jQuery.buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, response, type,
			self = this,
			off = url.indexOf(" ");
	
		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off, url.length ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,
	
				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
	
	
	
	
	
	var docElem = window.document.documentElement;
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ?
			elem :
			elem.nodeType === 9 ?
				elem.defaultView || elem.parentWindow :
				false;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;
	
			// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}
	
			var docElem, win,
				box = { top: 0, left: 0 },
				elem = this[ 0 ],
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			// If we don't have gBCR, just use 0,0 rather than error
			// BlackBerry 5, iOS 3 (original iPhone)
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
				left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				parentOffset = { top: 0, left: 0 },
				elem = this[ 0 ];
	
			// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// we assume that getBoundingClientRect is available when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			// note: when an element has margin: auto the offsetLeft and marginLeft
			// are the same in Safari causing offset.left to incorrectly be 0
			return {
				top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
			};
		},
	
		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;
	
				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}
				return offsetParent || docElem;
			});
		}
	});
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = /Y/.test( prop );
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? (prop in win) ? win[ prop ] :
						win.document.documentElement[ method ] :
						elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : jQuery( win ).scrollLeft(),
						top ? val : jQuery( win ).scrollTop()
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});
	
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// if curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
						// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});
	
	
	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in
	// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	return jQuery;
	
	}));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.1.2
	
	//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org
	
	(function(root, factory) {
	
	  // Set up Backbone appropriately for the environment. Start with AMD.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(1), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
	      // Export global even in AMD case in case this script is loaded with
	      // others that may still expect a global Backbone.
	      root.Backbone = factory(root, exports, _, $);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
	  } else if (typeof exports !== 'undefined') {
	    var _ = require('underscore');
	    factory(root, exports, _);
	
	  // Finally, as a browser global.
	  } else {
	    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
	  }
	
	}(this, function(root, Backbone, _, $) {
	
	  // Initial Setup
	  // -------------
	
	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;
	
	  // Create local references to array methods we'll want to use later.
	  var array = [];
	  var push = array.push;
	  var slice = array.slice;
	  var splice = array.splice;
	
	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.1.2';
	
	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = $;
	
	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };
	
	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;
	
	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;
	
	  // Backbone.Events
	  // ---------------
	
	  // A module that can be mixed in to *any object* in order to provide it with
	  // custom events. You may bind with `on` or remove with `off` callback
	  // functions to an event; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {
	
	    // Bind an event to a `callback` function. Passing `"all"` will bind
	    // the callback to all events fired.
	    on: function(name, callback, context) {
	      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
	      this._events || (this._events = {});
	      var events = this._events[name] || (this._events[name] = []);
	      events.push({callback: callback, context: context, ctx: context || this});
	      return this;
	    },
	
	    // Bind an event to only be triggered a single time. After the first time
	    // the callback is invoked, it will be removed.
	    once: function(name, callback, context) {
	      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
	      var self = this;
	      var once = _.once(function() {
	        self.off(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	      return this.on(name, once, context);
	    },
	
	    // Remove one or many callbacks. If `context` is null, removes all
	    // callbacks with that function. If `callback` is null, removes all
	    // callbacks for the event. If `name` is null, removes all bound
	    // callbacks for all events.
	    off: function(name, callback, context) {
	      var retain, ev, events, names, i, l, j, k;
	      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
	      if (!name && !callback && !context) {
	        this._events = void 0;
	        return this;
	      }
	      names = name ? [name] : _.keys(this._events);
	      for (i = 0, l = names.length; i < l; i++) {
	        name = names[i];
	        if (events = this._events[name]) {
	          this._events[name] = retain = [];
	          if (callback || context) {
	            for (j = 0, k = events.length; j < k; j++) {
	              ev = events[j];
	              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
	                  (context && context !== ev.context)) {
	                retain.push(ev);
	              }
	            }
	          }
	          if (!retain.length) delete this._events[name];
	        }
	      }
	
	      return this;
	    },
	
	    // Trigger one or many events, firing all bound callbacks. Callbacks are
	    // passed the same arguments as `trigger` is, apart from the event name
	    // (unless you're listening on `"all"`, which will cause your callback to
	    // receive the true name of the event as the first argument).
	    trigger: function(name) {
	      if (!this._events) return this;
	      var args = slice.call(arguments, 1);
	      if (!eventsApi(this, 'trigger', name, args)) return this;
	      var events = this._events[name];
	      var allEvents = this._events.all;
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, arguments);
	      return this;
	    },
	
	    // Tell this object to stop listening to either specific events ... or
	    // to every object it's currently listening to.
	    stopListening: function(obj, name, callback) {
	      var listeningTo = this._listeningTo;
	      if (!listeningTo) return this;
	      var remove = !name && !callback;
	      if (!callback && typeof name === 'object') callback = this;
	      if (obj) (listeningTo = {})[obj._listenId] = obj;
	      for (var id in listeningTo) {
	        obj = listeningTo[id];
	        obj.off(name, callback, this);
	        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
	      }
	      return this;
	    }
	
	  };
	
	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;
	
	  // Implement fancy features of the Events API such as multiple event
	  // names `"change blur"` and jQuery-style event maps `{change: action}`
	  // in terms of the existing API.
	  var eventsApi = function(obj, action, name, rest) {
	    if (!name) return true;
	
	    // Handle event maps.
	    if (typeof name === 'object') {
	      for (var key in name) {
	        obj[action].apply(obj, [key, name[key]].concat(rest));
	      }
	      return false;
	    }
	
	    // Handle space separated event names.
	    if (eventSplitter.test(name)) {
	      var names = name.split(eventSplitter);
	      for (var i = 0, l = names.length; i < l; i++) {
	        obj[action].apply(obj, [names[i]].concat(rest));
	      }
	      return false;
	    }
	
	    return true;
	  };
	
	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
	    }
	  };
	
	  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};
	
	  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
	  // listen to an event in another object ... keeping track of what it's
	  // listening to.
	  _.each(listenMethods, function(implementation, method) {
	    Events[method] = function(obj, name, callback) {
	      var listeningTo = this._listeningTo || (this._listeningTo = {});
	      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
	      listeningTo[id] = obj;
	      if (!callback && typeof name === 'object') callback = this;
	      obj[implementation](name, callback, this);
	      return this;
	    };
	  });
	
	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;
	
	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);
	
	  // Backbone.Model
	  // --------------
	
	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.
	
	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId('c');
	    this.attributes = {};
	    if (options.collection) this.collection = options.collection;
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };
	
	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {
	
	    // A hash of attributes whose current and previous value differ.
	    changed: null,
	
	    // The value returned during the last failed validation.
	    validationError: null,
	
	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },
	
	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },
	
	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },
	
	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },
	
	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },
	
	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      var attr, attrs, unset, changes, silent, changing, prev, current;
	      if (key == null) return this;
	
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options || (options = {});
	
	      // Run validation.
	      if (!this._validate(attrs, options)) return false;
	
	      // Extract attributes and options.
	      unset           = options.unset;
	      silent          = options.silent;
	      changes         = [];
	      changing        = this._changing;
	      this._changing  = true;
	
	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }
	      current = this.attributes, prev = this._previousAttributes;
	
	      // Check for changes of `id`.
	      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
	
	      // For each `set` attribute, update or delete the current value.
	      for (attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          this.changed[attr] = val;
	        } else {
	          delete this.changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }
	
	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = options;
	        for (var i = 0, l = changes.length; i < l; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }
	
	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },
	
	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },
	
	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },
	
	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },
	
	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var val, changed = false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      for (var attr in diff) {
	        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
	        (changed || (changed = {}))[attr] = val;
	      }
	      return changed;
	    },
	
	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },
	
	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },
	
	    // Fetch the model from the server. If the server's representation of the
	    // model differs from its current attributes, they will be overridden,
	    // triggering a `"change"` event.
	    fetch: function(options) {
	      options = options ? _.clone(options) : {};
	      if (options.parse === void 0) options.parse = true;
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        if (!model.set(model.parse(resp, options), options)) return false;
	        if (success) success(model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },
	
	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      var attrs, method, xhr, attributes = this.attributes;
	
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options = _.extend({validate: true}, options);
	
	      // If we're not waiting and attributes exist, save acts as
	      // `set(attr).save(null, opts)` with validation. Otherwise, check if
	      // the model will be valid when the attributes, if any, are set.
	      if (attrs && !options.wait) {
	        if (!this.set(attrs, options)) return false;
	      } else {
	        if (!this._validate(attrs, options)) return false;
	      }
	
	      // Set temporary attributes if `{wait: true}`.
	      if (attrs && options.wait) {
	        this.attributes = _.extend({}, attributes, attrs);
	      }
	
	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      if (options.parse === void 0) options.parse = true;
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = model.parse(resp, options);
	        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
	        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
	          return false;
	        }
	        if (success) success(model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	
	      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch') options.attrs = attrs;
	      xhr = this.sync(method, this, options);
	
	      // Restore attributes.
	      if (attrs && options.wait) this.attributes = attributes;
	
	      return xhr;
	    },
	
	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;
	
	      var destroy = function() {
	        model.trigger('destroy', model, model.collection, options);
	      };
	
	      options.success = function(resp) {
	        if (options.wait || model.isNew()) destroy();
	        if (success) success(model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };
	
	      if (this.isNew()) {
	        options.success();
	        return false;
	      }
	      wrapError(this, options);
	
	      var xhr = this.sync('delete', this, options);
	      if (!options.wait) destroy();
	      return xhr;
	    },
	
	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url') ||
	        urlError();
	      if (this.isNew()) return base;
	      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
	    },
	
	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },
	
	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },
	
	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return !this.has(this.idAttribute);
	    },
	
	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.extend(options || {}, { validate: true }));
	    },
	
	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
	      return false;
	    }
	
	  });
	
	  // Underscore methods that we want to implement on the Model.
	  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
	
	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  _.each(modelMethods, function(method) {
	    Model.prototype[method] = function() {
	      var args = slice.call(arguments);
	      args.unshift(this.attributes);
	      return _[method].apply(_, args);
	    };
	  });
	
	  // Backbone.Collection
	  // -------------------
	
	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analagous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.
	
	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };
	
	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, remove: false};
	
	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {
	
	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model){ return model.toJSON(options); });
	    },
	
	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },
	
	    // Add a model, or list of models to the set.
	    add: function(models, options) {
	      return this.set(models, _.extend({merge: false}, options, addOptions));
	    },
	
	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      var singular = !_.isArray(models);
	      models = singular ? [models] : _.clone(models);
	      options || (options = {});
	      var i, l, index, model;
	      for (i = 0, l = models.length; i < l; i++) {
	        model = models[i] = this.get(models[i]);
	        if (!model) continue;
	        delete this._byId[model.id];
	        delete this._byId[model.cid];
	        index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;
	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }
	        this._removeReference(model, options);
	      }
	      return singular ? models[0] : models;
	    },
	
	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      options = _.defaults({}, options, setOptions);
	      if (options.parse) models = this.parse(models, options);
	      var singular = !_.isArray(models);
	      models = singular ? (models ? [models] : []) : _.clone(models);
	      var i, l, id, model, attrs, existing, sort;
	      var at = options.at;
	      var targetModel = this.model;
	      var sortable = this.comparator && (at == null) && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
	      var toAdd = [], toRemove = [], modelMap = {};
	      var add = options.add, merge = options.merge, remove = options.remove;
	      var order = !sortable && add && remove ? [] : false;
	
	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      for (i = 0, l = models.length; i < l; i++) {
	        attrs = models[i] || {};
	        if (attrs instanceof Model) {
	          id = model = attrs;
	        } else {
	          id = attrs[targetModel.prototype.idAttribute || 'id'];
	        }
	
	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        if (existing = this.get(id)) {
	          if (remove) modelMap[existing.cid] = true;
	          if (merge) {
	            attrs = attrs === model ? model.attributes : attrs;
	            if (options.parse) attrs = existing.parse(attrs, options);
	            existing.set(attrs, options);
	            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
	          }
	          models[i] = existing;
	
	        // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(attrs, options);
	          if (!model) continue;
	          toAdd.push(model);
	          this._addReference(model, options);
	        }
	
	        // Do not add multiple models with the same `id`.
	        model = existing || model;
	        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
	        modelMap[model.id] = true;
	      }
	
	      // Remove nonexistent models if appropriate.
	      if (remove) {
	        for (i = 0, l = this.length; i < l; ++i) {
	          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this.remove(toRemove, options);
	      }
	
	      // See if sorting is needed, update `length` and splice in new models.
	      if (toAdd.length || (order && order.length)) {
	        if (sortable) sort = true;
	        this.length += toAdd.length;
	        if (at != null) {
	          for (i = 0, l = toAdd.length; i < l; i++) {
	            this.models.splice(at + i, 0, toAdd[i]);
	          }
	        } else {
	          if (order) this.models.length = 0;
	          var orderedModels = order || toAdd;
	          for (i = 0, l = orderedModels.length; i < l; i++) {
	            this.models.push(orderedModels[i]);
	          }
	        }
	      }
	
	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});
	
	      // Unless silenced, it's time to fire all appropriate add/sort events.
	      if (!options.silent) {
	        for (i = 0, l = toAdd.length; i < l; i++) {
	          (model = toAdd[i]).trigger('add', model, this, options);
	        }
	        if (sort || (order && order.length)) this.trigger('sort', this, options);
	      }
	
	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },
	
	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options || (options = {});
	      for (var i = 0, l = this.models.length; i < l; i++) {
	        this._removeReference(this.models[i], options);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return models;
	    },
	
	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },
	
	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      this.remove(model, options);
	      return model;
	    },
	
	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },
	
	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      this.remove(model, options);
	      return model;
	    },
	
	    // Slice out a sub-array of models from the collection.
	    slice: function() {
	      return slice.apply(this.models, arguments);
	    },
	
	    // Get a model from the set by id.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
	    },
	
	    // Get the model at the given index.
	    at: function(index) {
	      return this.models[index];
	    },
	
	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      if (_.isEmpty(attrs)) return first ? void 0 : [];
	      return this[first ? 'find' : 'filter'](function(model) {
	        for (var key in attrs) {
	          if (attrs[key] !== model.get(key)) return false;
	        }
	        return true;
	      });
	    },
	
	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },
	
	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});
	
	      // Run sort based on type of `comparator`.
	      if (_.isString(this.comparator) || this.comparator.length === 1) {
	        this.models = this.sortBy(this.comparator, this);
	      } else {
	        this.models.sort(_.bind(this.comparator, this));
	      }
	
	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },
	
	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return _.invoke(this.models, 'get', attr);
	    },
	
	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = options ? _.clone(options) : {};
	      if (options.parse === void 0) options.parse = true;
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success(collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },
	
	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      if (!(model = this._prepareModel(model, options))) return false;
	      if (!options.wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(model, resp) {
	        if (options.wait) collection.add(model, options);
	        if (success) success(model, resp, options);
	      };
	      model.save(null, options);
	      return model;
	    },
	
	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },
	
	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models);
	    },
	
	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },
	
	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (attrs instanceof Model) return attrs;
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) return model;
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },
	
	    // Internal method to create a model's ties to a collection.
	    _addReference: function(model, options) {
	      this._byId[model.cid] = model;
	      if (model.id != null) this._byId[model.id] = model;
	      if (!model.collection) model.collection = this;
	      model.on('all', this._onModelEvent, this);
	    },
	
	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model, options) {
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },
	
	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if ((event === 'add' || event === 'remove') && collection !== this) return;
	      if (event === 'destroy') this.remove(model, options);
	      if (model && event === 'change:' + model.idAttribute) {
	        delete this._byId[model.previous(model.idAttribute)];
	        if (model.id != null) this._byId[model.id] = model;
	      }
	      this.trigger.apply(this, arguments);
	    }
	
	  });
	
	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
	    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
	    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
	    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
	    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
	    'lastIndexOf', 'isEmpty', 'chain', 'sample'];
	
	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  _.each(methods, function(method) {
	    Collection.prototype[method] = function() {
	      var args = slice.call(arguments);
	      args.unshift(this.models);
	      return _[method].apply(_, args);
	    };
	  });
	
	  // Underscore methods that take a property name as an argument.
	  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];
	
	  // Use attributes instead of properties.
	  _.each(attributeMethods, function(method) {
	    Collection.prototype[method] = function(value, context) {
	      var iterator = _.isFunction(value) ? value : function(model) {
	        return model.get(value);
	      };
	      return _[method](this.models, iterator, context);
	    };
	  });
	
	  // Backbone.View
	  // -------------
	
	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.
	
	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    options || (options = {});
	    _.extend(this, _.pick(options, viewOptions));
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	    this.delegateEvents();
	  };
	
	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;
	
	  // List of view options to be merged as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
	
	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {
	
	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',
	
	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },
	
	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this.$el.remove();
	      this.stopListening();
	      return this;
	    },
	
	    // Change the view's element (`this.el` property), including event
	    // re-delegation.
	    setElement: function(element, delegate) {
	      if (this.$el) this.undelegateEvents();
	      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
	      this.el = this.$el[0];
	      if (delegate !== false) this.delegateEvents();
	      return this;
	    },
	
	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    // This only works for delegate-able events: not `focus`, `blur`, and
	    // not `change`, `submit`, and `reset` in Internet Explorer.
	    delegateEvents: function(events) {
	      if (!(events || (events = _.result(this, 'events')))) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[events[key]];
	        if (!method) continue;
	
	        var match = key.match(delegateEventSplitter);
	        var eventName = match[1], selector = match[2];
	        method = _.bind(method, this);
	        eventName += '.delegateEvents' + this.cid;
	        if (selector === '') {
	          this.$el.on(eventName, method);
	        } else {
	          this.$el.on(eventName, selector, method);
	        }
	      }
	      return this;
	    },
	
	    // Clears all callbacks previously bound to the view with `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },
	
	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
	        this.setElement($el, false);
	      } else {
	        this.setElement(_.result(this, 'el'), false);
	      }
	    }
	
	  });
	
	  // Backbone.sync
	  // -------------
	
	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];
	
	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });
	
	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};
	
	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }
	
	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }
	
	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }
	
	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }
	
	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }
	
	    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
	    // that still has ActiveX enabled by default, override jQuery to use that
	    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
	    if (params.type === 'PATCH' && noXhrPatch) {
	      params.xhr = function() {
	        return new ActiveXObject("Microsoft.XMLHTTP");
	      };
	    }
	
	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };
	
	  var noXhrPatch =
	    typeof window !== 'undefined' && !!window.ActiveXObject &&
	      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
	
	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch':  'PATCH',
	    'delete': 'DELETE',
	    'read':   'GET'
	  };
	
	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };
	
	  // Backbone.Router
	  // ---------------
	
	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };
	
	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;
	
	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {
	
	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},
	
	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        router.execute(callback, args);
	        router.trigger.apply(router, ['route:' + name].concat(args));
	        router.trigger('route', name, args);
	        Backbone.history.trigger('route', router, name, args);
	      });
	      return this;
	    },
	
	    // Execute a route handler with the provided parameters.  This is an
	    // excellent place to do pre-route setup or post-route cleanup.
	    execute: function(callback, args) {
	      if (callback) callback.apply(this, args);
	    },
	
	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },
	
	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },
	
	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	                   .replace(optionalParam, '(?:$1)?')
	                   .replace(namedParam, function(match, optional) {
	                     return optional ? match : '([^/?]+)';
	                   })
	                   .replace(splatParam, '([^?]*?)');
	      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
	    },
	
	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param, i) {
	        // Don't decode the search params.
	        if (i === params.length - 1) return param || null;
	        return param ? decodeURIComponent(param) : null;
	      });
	    }
	
	  });
	
	  // Backbone.History
	  // ----------------
	
	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    _.bindAll(this, 'checkUrl');
	
	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };
	
	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;
	
	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;
	
	  // Cached regex for detecting MSIE.
	  var isExplorer = /msie [\w.]+/;
	
	  // Cached regex for removing a trailing slash.
	  var trailingSlash = /\/$/;
	
	  // Cached regex for stripping urls of hash.
	  var pathStripper = /#.*$/;
	
	  // Has the history handling already been started?
	  History.started = false;
	
	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {
	
	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,
	
	    // Are we at the app root?
	    atRoot: function() {
	      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
	    },
	
	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },
	
	    // Get the cross-browser normalized URL fragment, either from the URL,
	    // the hash, or the override.
	    getFragment: function(fragment, forcePushState) {
	      if (fragment == null) {
	        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
	          fragment = decodeURI(this.location.pathname + this.location.search);
	          var root = this.root.replace(trailingSlash, '');
	          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },
	
	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error("Backbone.history has already been started");
	      History.started = true;
	
	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
	      var fragment          = this.getFragment();
	      var docMode           = document.documentMode;
	      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));
	
	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');
	
	      if (oldIE && this._wantsHashChange) {
	        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
	        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
	        this.navigate(fragment);
	      }
	
	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._hasPushState) {
	        Backbone.$(window).on('popstate', this.checkUrl);
	      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
	        Backbone.$(window).on('hashchange', this.checkUrl);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }
	
	      // Determine if we need to change the base url, for a pushState link
	      // opened by a non-pushState browser.
	      this.fragment = fragment;
	      var loc = this.location;
	
	      // Transition from hashChange to pushState or vice versa if both are
	      // requested.
	      if (this._wantsHashChange && this._wantsPushState) {
	
	        // If we've started off with a route from a `pushState`-enabled
	        // browser, but we're currently in a browser that doesn't support it...
	        if (!this._hasPushState && !this.atRoot()) {
	          this.fragment = this.getFragment(null, true);
	          this.location.replace(this.root + '#' + this.fragment);
	          // Return immediately as browser will do redirect to new url
	          return true;
	
	        // Or if we've started out with a hash-based route, but we're currently
	        // in a browser where it could be `pushState`-based instead...
	        } else if (this._hasPushState && this.atRoot() && loc.hash) {
	          this.fragment = this.getHash().replace(routeStripper, '');
	          this.history.replaceState({}, document.title, this.root + this.fragment);
	        }
	
	      }
	
	      if (!this.options.silent) return this.loadUrl();
	    },
	
	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
	      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },
	
	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },
	
	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();
	      if (current === this.fragment && this.iframe) {
	        current = this.getFragment(this.getHash(this.iframe));
	      }
	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl();
	    },
	
	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragment) {
	      fragment = this.fragment = this.getFragment(fragment);
	      return _.any(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	    },
	
	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: !!options};
	
	      var url = this.root + (fragment = this.getFragment(fragment || ''));
	
	      // Strip the hash for matching.
	      fragment = fragment.replace(pathStripper, '');
	
	      if (this.fragment === fragment) return;
	      this.fragment = fragment;
	
	      // Don't include a trailing slash on the root.
	      if (fragment === '' && url !== '/') url = url.slice(0, -1);
	
	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._hasPushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
	
	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if(!options.replace) this.iframe.document.open().close();
	          this._updateHash(this.iframe.location, fragment, options.replace);
	        }
	
	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) return this.loadUrl(fragment);
	    },
	
	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }
	
	  });
	
	  // Create the default Backbone.history.
	  Backbone.history = new History;
	
	  // Helpers
	  // -------
	
	  // Helper function to correctly set up the prototype chain, for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;
	
	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent's constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }
	
	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);
	
	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent`'s constructor function.
	    var Surrogate = function(){ this.constructor = child; };
	    Surrogate.prototype = parent.prototype;
	    child.prototype = new Surrogate;
	
	    // Add prototype properties (instance properties) to the subclass,
	    // if supplied.
	    if (protoProps) _.extend(child.prototype, protoProps);
	
	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;
	
	    return child;
	  };
	
	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
	
	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };
	
	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function(model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error(model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };
	
	  return Backbone;
	
	}));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0
	//     http://underscorejs.org
	//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function() {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Establish the object that gets returned to break out of a loop iteration.
	  var breaker = {};
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    concat           = ArrayProto.concat,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeForEach      = ArrayProto.forEach,
	    nativeMap          = ArrayProto.map,
	    nativeReduce       = ArrayProto.reduce,
	    nativeReduceRight  = ArrayProto.reduceRight,
	    nativeFilter       = ArrayProto.filter,
	    nativeEvery        = ArrayProto.every,
	    nativeSome         = ArrayProto.some,
	    nativeIndexOf      = ArrayProto.indexOf,
	    nativeLastIndexOf  = ArrayProto.lastIndexOf,
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object via a string identifier,
	  // for Closure Compiler "advanced" mode.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.6.0';
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles objects with the built-in `forEach`, arrays, and raw objects.
	  // Delegates to **ECMAScript 5**'s native `forEach` if available.
	  var each = _.each = _.forEach = function(obj, iterator, context) {
	    if (obj == null) return obj;
	    if (nativeForEach && obj.forEach === nativeForEach) {
	      obj.forEach(iterator, context);
	    } else if (obj.length === +obj.length) {
	      for (var i = 0, length = obj.length; i < length; i++) {
	        if (iterator.call(context, obj[i], i, obj) === breaker) return;
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (var i = 0, length = keys.length; i < length; i++) {
	        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
	      }
	    }
	    return obj;
	  };
	
	  // Return the results of applying the iterator to each element.
	  // Delegates to **ECMAScript 5**'s native `map` if available.
	  _.map = _.collect = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	    each(obj, function(value, index, list) {
	      results.push(iterator.call(context, value, index, list));
	    });
	    return results;
	  };
	
	  var reduceError = 'Reduce of empty array with no initial value';
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduce && obj.reduce === nativeReduce) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	    }
	    each(obj, function(value, index, list) {
	      if (!initial) {
	        memo = value;
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, value, index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };
	
	  // The right-associative version of reduce, also known as `foldr`.
	  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
	    }
	    var length = obj.length;
	    if (length !== +length) {
	      var keys = _.keys(obj);
	      length = keys.length;
	    }
	    each(obj, function(value, index, list) {
	      index = keys ? keys[--length] : --length;
	      if (!initial) {
	        memo = obj[index];
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, obj[index], index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var result;
	    any(obj, function(value, index, list) {
	      if (predicate.call(context, value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };
	
	  // Return all the elements that pass a truth test.
	  // Delegates to **ECMAScript 5**'s native `filter` if available.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
	    each(obj, function(value, index, list) {
	      if (predicate.call(context, value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, function(value, index, list) {
	      return !predicate.call(context, value, index, list);
	    }, context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Delegates to **ECMAScript 5**'s native `every` if available.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate || (predicate = _.identity);
	    var result = true;
	    if (obj == null) return result;
	    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
	    each(obj, function(value, index, list) {
	      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Delegates to **ECMAScript 5**'s native `some` if available.
	  // Aliased as `any`.
	  var any = _.some = _.any = function(obj, predicate, context) {
	    predicate || (predicate = _.identity);
	    var result = false;
	    if (obj == null) return result;
	    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
	    each(obj, function(value, index, list) {
	      if (result || (result = predicate.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };
	
	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
	    return any(obj, function(value) {
	      return value === target;
	    });
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matches(attrs));
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matches(attrs));
	  };
	
	  // Return the maximum element or (element-based computation).
	  // Can't optimize arrays of integers longer than 65,535 elements.
	  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
	  _.max = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.max.apply(Math, obj);
	    }
	    var result = -Infinity, lastComputed = -Infinity;
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      if (computed > lastComputed) {
	        result = value;
	        lastComputed = computed;
	      }
	    });
	    return result;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.min.apply(Math, obj);
	    }
	    var result = Infinity, lastComputed = Infinity;
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      if (computed < lastComputed) {
	        result = value;
	        lastComputed = computed;
	      }
	    });
	    return result;
	  };
	
	  // Shuffle an array, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var rand;
	    var index = 0;
	    var shuffled = [];
	    each(obj, function(value) {
	      rand = _.random(index++);
	      shuffled[index - 1] = shuffled[rand];
	      shuffled[rand] = value;
	    });
	    return shuffled;
	  };
	
	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (obj.length !== +obj.length) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };
	
	  // An internal function to generate lookup iterators.
	  var lookupIterator = function(value) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return value;
	    return _.property(value);
	  };
	
	  // Sort the object's values by a criterion produced by an iterator.
	  _.sortBy = function(obj, iterator, context) {
	    iterator = lookupIterator(iterator);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iterator.call(context, value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iterator, context) {
	      var result = {};
	      iterator = lookupIterator(iterator);
	      each(obj, function(value, index) {
	        var key = iterator.call(context, value, index, obj);
	        behavior(result, key, value);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, key, value) {
	    _.has(result, key) ? result[key].push(value) : result[key] = [value];
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, key, value) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, key) {
	    _.has(result, key) ? result[key]++ : result[key] = 1;
	  });
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iterator, context) {
	    iterator = lookupIterator(iterator);
	    var value = iterator.call(context, obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
	    }
	    return low;
	  };
	
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	  };
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n == null) || guard) return array[0];
	    if (n < 0) return [];
	    return slice.call(array, 0, n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n == null) || guard) return array[array.length - 1];
	    return slice.call(array, Math.max(array.length - n, 0));
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, (n == null) || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, output) {
	    if (shallow && _.every(input, _.isArray)) {
	      return concat.apply(output, input);
	    }
	    each(input, function(value) {
	      if (_.isArray(value) || _.isArguments(value)) {
	        shallow ? push.apply(output, value) : flatten(value, shallow, output);
	      } else {
	        output.push(value);
	      }
	    });
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, []);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };
	
	  // Split an array into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(array, predicate) {
	    var pass = [], fail = [];
	    each(array, function(elem) {
	      (predicate(elem) ? pass : fail).push(elem);
	    });
	    return [pass, fail];
	  };
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iterator, context) {
	    if (_.isFunction(isSorted)) {
	      context = iterator;
	      iterator = isSorted;
	      isSorted = false;
	    }
	    var initial = iterator ? _.map(array, iterator, context) : array;
	    var results = [];
	    var seen = [];
	    each(initial, function(value, index) {
	      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
	        seen.push(value);
	        results.push(array[index]);
	      }
	    });
	    return results;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(_.flatten(arguments, true));
	  };
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var rest = slice.call(arguments, 1);
	    return _.filter(_.uniq(array), function(item) {
	      return _.every(rest, function(other) {
	        return _.contains(other, item);
	      });
	    });
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
	    return _.filter(array, function(value){ return !_.contains(rest, value); });
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    var length = _.max(_.pluck(arguments, 'length').concat(0));
	    var results = new Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(arguments, '' + i);
	    }
	    return results;
	  };
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, length = list.length; i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	  // we need this function. Return the position of the first occurrence of an
	  // item in an array, or -1 if the item is not included in the array.
	  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, length = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
	    for (; i < length; i++) if (array[i] === item) return i;
	    return -1;
	  };
	
	  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var hasIndex = from != null;
	    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
	      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
	    }
	    var i = (hasIndex ? from : array.length);
	    while (i--) if (array[i] === item) return i;
	    return -1;
	  };
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = arguments[2] || 1;
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var idx = 0;
	    var range = new Array(length);
	
	    while(idx < length) {
	      range[idx++] = start;
	      start += step;
	    }
	
	    return range;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Reusable constructor function for prototype setting.
	  var ctor = function(){};
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    var args, bound;
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError;
	    args = slice.call(arguments, 2);
	    return bound = function() {
	      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
	      ctor.prototype = func.prototype;
	      var self = new ctor;
	      ctor.prototype = null;
	      var result = func.apply(self, args.concat(slice.call(arguments)));
	      if (Object(result) === result) return result;
	      return self;
	    };
	  };
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    return function() {
	      var position = 0;
	      var args = boundArgs.slice();
	      for (var i = 0, length = args.length; i < length; i++) {
	        if (args[i] === _) args[i] = arguments[position++];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return func.apply(this, args);
	    };
	  };
	
	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var funcs = slice.call(arguments, 1);
	    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
	    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
	    return obj;
	  };
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memo = {};
	    hasher || (hasher = _.identity);
	    return function() {
	      var key = hasher.apply(this, arguments);
	      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
	    };
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){ return func.apply(null, args); }, wait);
	  };
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    options || (options = {});
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	        context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	
	    var later = function() {
	      var last = _.now() - timestamp;
	      if (last < wait) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          context = args = null;
	        }
	      }
	    };
	
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) {
	        timeout = setTimeout(later, wait);
	      }
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }
	
	      return result;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = function(func) {
	    var ran = false, memo;
	    return function() {
	      if (ran) return memo;
	      ran = true;
	      memo = func.apply(this, arguments);
	      func = null;
	      return memo;
	    };
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments;
	      for (var i = funcs.length - 1; i >= 0; i--) {
	        args = [funcs[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  };
	
	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Object Functions
	  // ----------------
	
	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = new Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = new Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    each(keys, function(key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  };
	
	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    for (var key in obj) {
	      if (!_.contains(keys, key)) copy[key] = obj[key];
	    }
	    return copy;
	  };
	
	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          if (obj[prop] === void 0) obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a == 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className != toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, dates, and booleans are compared by value.
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return a == String(b);
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
	        // other numeric values.
	        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a == +b;
	      // RegExps are compared by their source patterns and flags.
	      case '[object RegExp]':
	        return a.source == b.source &&
	               a.global == b.global &&
	               a.multiline == b.multiline &&
	               a.ignoreCase == b.ignoreCase;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] == a) return bStack[length] == b;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s
	    // from different frames are.
	    var aCtor = a.constructor, bCtor = b.constructor;
	    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
	                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
	                        && ('constructor' in a && 'constructor' in b)) {
	      return false;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size = 0, result = true;
	    // Recursively compare objects and arrays.
	    if (className == '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size == b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Deep compare objects.
	      for (var key in a) {
	        if (_.has(a, key)) {
	          // Count the expected number of properties.
	          size++;
	          // Deep compare each member.
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	      // Ensure that both objects contain the same number of properties.
	      if (result) {
	        for (key in b) {
	          if (_.has(b, key) && !(size--)) break;
	        }
	        result = !size;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    return obj === Object(obj);
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) == '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return !!(obj && _.has(obj, 'callee'));
	    };
	  }
	
	  // Optimize `isFunction` if appropriate.
	  if (true) {
	    _.isFunction = function(obj) {
	      return typeof obj === 'function';
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj != +obj;
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iterators.
	  _.identity = function(value) {
	    return value;
	  };
	
	  _.constant = function(value) {
	    return function () {
	      return value;
	    };
	  };
	
	  _.property = function(key) {
	    return function(obj) {
	      return obj[key];
	    };
	  };
	
	  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
	  _.matches = function(attrs) {
	    return function(obj) {
	      if (obj === attrs) return true; //avoid comparing an object to itself.
	      for (var key in attrs) {
	        if (attrs[key] !== obj[key])
	          return false;
	      }
	      return true;
	    }
	  };
	
	  // Run a function **n** times.
	  _.times = function(n, iterator, context) {
	    var accum = Array(Math.max(0, n));
	    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
	    return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() { return new Date().getTime(); };
	
	  // List of HTML entities for escaping.
	  var entityMap = {
	    escape: {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#x27;'
	    }
	  };
	  entityMap.unescape = _.invert(entityMap.escape);
	
	  // Regexes containing the keys and values listed immediately above.
	  var entityRegexes = {
	    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
	    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	  };
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  _.each(['escape', 'unescape'], function(method) {
	    _[method] = function(string) {
	      if (string == null) return '';
	      return ('' + string).replace(entityRegexes[method], function(match) {
	        return entityMap[method][match];
	      });
	    };
	  });
	
	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return void 0;
	    var value = object[property];
	    return _.isFunction(value) ? value.call(object) : value;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\t':     't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  _.template = function(text, data, settings) {
	    var render;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset)
	        .replace(escaper, function(match) { return '\\' + escapes[match]; });
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      }
	      if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      }
	      if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	      index = offset + match.length;
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + "return __p;\n";
	
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    if (data) return render(data, _);
	    var template = function(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function, which will delegate to the wrapper.
	  _.chain = function(obj) {
	    return _(obj).chain();
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  _.extend(_.prototype, {
	
	    // Start chaining a wrapped Underscore object.
	    chain: function() {
	      this._chain = true;
	      return this;
	    },
	
	    // Extracts the result from a wrapped and chained object.
	    value: function() {
	      return this._wrapped;
	    }
	
	  });
	
	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(88),
	  __webpack_require__(165),
	  __webpack_require__(115),
	  __webpack_require__(102),
	  __webpack_require__(116),
	  __webpack_require__(125),
	  __webpack_require__(124),
	  __webpack_require__(126),
	  __webpack_require__(127),
	  __webpack_require__(136),
	  __webpack_require__(137),
	  __webpack_require__(138),
	  __webpack_require__(118),
	  __webpack_require__(100),
	  __webpack_require__(121),
	  __webpack_require__(122),
	  __webpack_require__(123),
	  __webpack_require__(119),
	  __webpack_require__(101),
	  __webpack_require__(139),
	  __webpack_require__(128),
	  __webpack_require__(141),
	  __webpack_require__(142),
	  __webpack_require__(112),
	  __webpack_require__(143),
	  __webpack_require__(95),
	  __webpack_require__(91),
	  __webpack_require__(144),
	  __webpack_require__(145),
	  __webpack_require__(148),
	  __webpack_require__(149),
	  __webpack_require__(153),
	  __webpack_require__(94),
	  __webpack_require__(155),
	  __webpack_require__(158),
	  __webpack_require__(111),
	  __webpack_require__(159),
	  __webpack_require__(162),
	  __webpack_require__(164),
	  __webpack_require__(5),
	  __webpack_require__(166),
	  __webpack_require__(106),
	  __webpack_require__(170),
	  __webpack_require__(90),
	  __webpack_require__(89),
	  __webpack_require__(172),
	  __webpack_require__(173),
	  __webpack_require__(105),
	  __webpack_require__(177),
	  __webpack_require__(167),
	  __webpack_require__(179),
	  __webpack_require__(181),
	  __webpack_require__(183),
	  __webpack_require__(107),
	  __webpack_require__(147),
	  __webpack_require__(174),
	  __webpack_require__(104),
	  __webpack_require__(99),
	  //'./view/form/FileDropZone',
	  __webpack_require__(146),
	  __webpack_require__(185),
	  __webpack_require__(187),
	  __webpack_require__(192),
	  __webpack_require__(193),
	  __webpack_require__(194),
	  __webpack_require__(195),
	  __webpack_require__(197),
	  __webpack_require__(199),
	  __webpack_require__(198),
	  __webpack_require__(189),
	  __webpack_require__(200),
	  __webpack_require__(204),
	  __webpack_require__(156),
	  __webpack_require__(201),
	  __webpack_require__(93),
	  __webpack_require__(206),
	  __webpack_require__(208),
	  __webpack_require__(210)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Plumage) {
	  return Plumage;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(89),
	  __webpack_require__(104),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, FieldWithPicker, DateRangePicker) {
	
	  return  Plumage.view.form.fields.DateRangeField = FieldWithPicker.extend(
	  /** @lends Plumage.view.form.fields.DateRangeField.prototype */
	  {
	
	    fieldTemplate: '<div class="input-prepend"><button class="btn" data-toggle="dropdown" data-target="#"><i class="icon-calendar"></i></button>'+FieldWithPicker.prototype.fieldTemplate+'</div>',
	
	    className: 'date-range-field',
	
	    /** model attribute used as the start of the selected date range. */
	    fromAttr: undefined,
	
	    /** model attribute used as the end of the selected date range. */
	    toAttr: undefined,
	
	    /** min selectable date, inclusive. */
	    minDate: undefined,
	
	    /** min selectable date, inclusive. */
	    maxDate: undefined,
	
	    pickerCls: DateRangePicker,
	
	    /** Options to pass on to contained [DateRangePicker]{@link Plumage.view.form.fields.picker.DateRangePicker} object. */
	    pickerOptions: undefined,
	
	    /** Which side to open the picker on*/
	    opens: 'right',
	
	    /**
	     * Date format for text fields. Other formats can be typed into the main field, as long it can be
	     * parsed by moment.js
	     */
	    format: 'MMM D, YYYY',
	
	    formatWithHour: 'MMM D ha, YYYY',
	
	    /**
	     * Field for selecting a date range.
	     *
	     * DateRangeField uses two model attributes to get and store its selection, unlike a normal
	     * field that only uses one. The two attribute names are specified by [fromAttr]{@link Plumage.view.form.fields.DateRangeField#fromAttr}
	     * and [toAttr]{@link Plumage.view.form.fields.DateRangeField#toAttr}, for the start
	     * and end of the range respectively.
	     *
	     * The user can either select from and to dates from the left and right calendars respectively, or they
	     * can choose from a list of presets. In either 'apply' must be clicked before the field's value is set.
	     *
	     * The value can also be set by editing the text field directly, as long as it can be parsed back into dates.
	     *
	     * See a live demo in the [Kitchen Sink example]{@link /examples/kitchen_sink/form/FieldsAndForms}
	     *
	     * @constructs
	     * @extends Plumage.view.form.fields.Field
	     */
	    initialize:function(options) {
	      FieldWithPicker.prototype.initialize.apply(this, arguments);
	    },
	
	    setShowHourSelect: function(showHourSelect) {
	      this.getPicker().setShowHourSelect(showHourSelect);
	    },
	
	    setMaxDate: function(maxDate) {
	      this.getPicker().model.set('maxDate', maxDate);
	    },
	
	    setMinDate: function(minDate) {
	      this.getPicker().model.set('minDate', minDate);
	    },
	
	    //
	    // Value
	    //
	
	    processValueForDom: function(value) {
	      if (value && value.length) {
	        var picker = this.getPicker();
	        var format = picker.showHourSelect ? this.formatWithHour : this.format;
	        var m0 = picker.utc ? moment.utc(value[0]) : moment(value[0]);
	        var m1 = picker.utc ? moment.utc(value[1]) : moment(value[1]);
	        return m0.format(format) + ' - ' + m1.format(format);
	      }
	      return '';
	    },
	
	    //
	    // View value <--> DOM
	    //
	
	    isDomValueValid: function(value) {
	      if (!value) {
	        return true;
	      }
	      var values = value.split('-');
	      if (values.length !== 2) {
	        return false;
	      }
	      var utc = this.getPicker().utc,
	        fromDate = utc ? moment.utc(values[0].trim()) : moment(values[0].trim()),
	        toDate = utc ? moment.utc(values[1].trim()) : moment(values[1].trim());
	
	      if (!fromDate.isValid() || !toDate.isValid()) {
	        return false;
	      }
	
	      if (fromDate > toDate) {
	        return false;
	      }
	
	      return Plumage.util.DateTimeUtil.isDateInRange(fromDate, this.minDate, this.maxDate) &&
	        Plumage.util.DateTimeUtil.isDateInRange(toDate, this.minDate, this.maxDate);
	    },
	
	    processDomValue: function(value) {
	      if (!value) {
	        return null;
	      }
	      var format = this.getPicker().showHourSelect ? this.formatWithHour : this.format;
	      var values = value.split('-'),
	        utc = this.getPicker().utc,
	        m0 = utc ? moment.utc(values[0].trim(), format) : moment(values[0].trim()),
	        m1 = utc ? moment.utc(values[1].trim(), format) : moment(values[1].trim()),
	        fromDate = m0.valueOf(),
	        toDate = m1.valueOf();
	      return [fromDate, toDate];
	    },
	
	    //
	    // View value <--> Model
	    //
	
	    getValueFromModel: function() {
	      if (this.model) {
	        var from = this.model.get(this.fromAttr),
	          to = this.model.get(this.toAttr);
	        return [from, to];
	      }
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.getValue();
	
	      var newValues = {};
	      newValues[this.fromAttr] = value[0];
	      newValues[this.toAttr] = value[1];
	      return model.set(newValues);
	    },
	
	    valueChanged: function() {
	      FieldWithPicker.prototype.valueChanged.apply(this, arguments);
	      this.getPicker().model.set({
	        minDate: this.minDate,
	        maxDate: this.maxDate
	      });
	    },
	
	    //
	    // Events
	    //
	
	    onModelChange: function (e) {
	      if (e.changed[this.fromAttr] !== undefined || e.changed[this.toAttr] !== undefined) {
	        this.updateValueFromModel();
	      }
	    },
	
	    onKeyDown: function(e) {
	      if (e.keyCode === 13) { //on enter
	        e.preventDefault();
	        this.updateValueFromDom();
	      } else if(e.keyCode === 27) {
	        this.update();
	      }
	    },
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	
	 handlebars v3.0.3
	
	Copyright (C) 2011-2014 by Yehuda Katz
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	
	@license
	*/
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define(factory);
		else if(typeof exports === 'object')
			exports["Handlebars"] = factory();
		else
			root["Handlebars"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
	
		var _runtime = __webpack_require__(1);
	
		var _runtime2 = _interopRequireWildcard(_runtime);
	
		// Compiler imports
	
		var _AST = __webpack_require__(2);
	
		var _AST2 = _interopRequireWildcard(_AST);
	
		var _Parser$parse = __webpack_require__(3);
	
		var _Compiler$compile$precompile = __webpack_require__(4);
	
		var _JavaScriptCompiler = __webpack_require__(5);
	
		var _JavaScriptCompiler2 = _interopRequireWildcard(_JavaScriptCompiler);
	
		var _Visitor = __webpack_require__(6);
	
		var _Visitor2 = _interopRequireWildcard(_Visitor);
	
		var _noConflict = __webpack_require__(7);
	
		var _noConflict2 = _interopRequireWildcard(_noConflict);
	
		var _create = _runtime2['default'].create;
		function create() {
		  var hb = _create();
	
		  hb.compile = function (input, options) {
		    return _Compiler$compile$precompile.compile(input, options, hb);
		  };
		  hb.precompile = function (input, options) {
		    return _Compiler$compile$precompile.precompile(input, options, hb);
		  };
	
		  hb.AST = _AST2['default'];
		  hb.Compiler = _Compiler$compile$precompile.Compiler;
		  hb.JavaScriptCompiler = _JavaScriptCompiler2['default'];
		  hb.Parser = _Parser$parse.parser;
		  hb.parse = _Parser$parse.parse;
	
		  return hb;
		}
	
		var inst = create();
		inst.create = create;
	
		_noConflict2['default'](inst);
	
		inst.Visitor = _Visitor2['default'];
	
		inst['default'] = inst;
	
		exports['default'] = inst;
		module.exports = exports['default'];
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
	
		var _import = __webpack_require__(9);
	
		var base = _interopRequireWildcard(_import);
	
		// Each of these augment the Handlebars object. No need to setup here.
		// (This is done to easily share code between commonjs and browse envs)
	
		var _SafeString = __webpack_require__(10);
	
		var _SafeString2 = _interopRequireWildcard(_SafeString);
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var _import2 = __webpack_require__(12);
	
		var Utils = _interopRequireWildcard(_import2);
	
		var _import3 = __webpack_require__(13);
	
		var runtime = _interopRequireWildcard(_import3);
	
		var _noConflict = __webpack_require__(7);
	
		var _noConflict2 = _interopRequireWildcard(_noConflict);
	
		// For compatibility and usage outside of module systems, make the Handlebars object a namespace
		function create() {
		  var hb = new base.HandlebarsEnvironment();
	
		  Utils.extend(hb, base);
		  hb.SafeString = _SafeString2['default'];
		  hb.Exception = _Exception2['default'];
		  hb.Utils = Utils;
		  hb.escapeExpression = Utils.escapeExpression;
	
		  hb.VM = runtime;
		  hb.template = function (spec) {
		    return runtime.template(spec, hb);
		  };
	
		  return hb;
		}
	
		var inst = create();
		inst.create = create;
	
		_noConflict2['default'](inst);
	
		inst['default'] = inst;
	
		exports['default'] = inst;
		module.exports = exports['default'];
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
		var AST = {
		  Program: function Program(statements, blockParams, strip, locInfo) {
		    this.loc = locInfo;
		    this.type = 'Program';
		    this.body = statements;
	
		    this.blockParams = blockParams;
		    this.strip = strip;
		  },
	
		  MustacheStatement: function MustacheStatement(path, params, hash, escaped, strip, locInfo) {
		    this.loc = locInfo;
		    this.type = 'MustacheStatement';
	
		    this.path = path;
		    this.params = params || [];
		    this.hash = hash;
		    this.escaped = escaped;
	
		    this.strip = strip;
		  },
	
		  BlockStatement: function BlockStatement(path, params, hash, program, inverse, openStrip, inverseStrip, closeStrip, locInfo) {
		    this.loc = locInfo;
		    this.type = 'BlockStatement';
	
		    this.path = path;
		    this.params = params || [];
		    this.hash = hash;
		    this.program = program;
		    this.inverse = inverse;
	
		    this.openStrip = openStrip;
		    this.inverseStrip = inverseStrip;
		    this.closeStrip = closeStrip;
		  },
	
		  PartialStatement: function PartialStatement(name, params, hash, strip, locInfo) {
		    this.loc = locInfo;
		    this.type = 'PartialStatement';
	
		    this.name = name;
		    this.params = params || [];
		    this.hash = hash;
	
		    this.indent = '';
		    this.strip = strip;
		  },
	
		  ContentStatement: function ContentStatement(string, locInfo) {
		    this.loc = locInfo;
		    this.type = 'ContentStatement';
		    this.original = this.value = string;
		  },
	
		  CommentStatement: function CommentStatement(comment, strip, locInfo) {
		    this.loc = locInfo;
		    this.type = 'CommentStatement';
		    this.value = comment;
	
		    this.strip = strip;
		  },
	
		  SubExpression: function SubExpression(path, params, hash, locInfo) {
		    this.loc = locInfo;
	
		    this.type = 'SubExpression';
		    this.path = path;
		    this.params = params || [];
		    this.hash = hash;
		  },
	
		  PathExpression: function PathExpression(data, depth, parts, original, locInfo) {
		    this.loc = locInfo;
		    this.type = 'PathExpression';
	
		    this.data = data;
		    this.original = original;
		    this.parts = parts;
		    this.depth = depth;
		  },
	
		  StringLiteral: function StringLiteral(string, locInfo) {
		    this.loc = locInfo;
		    this.type = 'StringLiteral';
		    this.original = this.value = string;
		  },
	
		  NumberLiteral: function NumberLiteral(number, locInfo) {
		    this.loc = locInfo;
		    this.type = 'NumberLiteral';
		    this.original = this.value = Number(number);
		  },
	
		  BooleanLiteral: function BooleanLiteral(bool, locInfo) {
		    this.loc = locInfo;
		    this.type = 'BooleanLiteral';
		    this.original = this.value = bool === 'true';
		  },
	
		  UndefinedLiteral: function UndefinedLiteral(locInfo) {
		    this.loc = locInfo;
		    this.type = 'UndefinedLiteral';
		    this.original = this.value = undefined;
		  },
	
		  NullLiteral: function NullLiteral(locInfo) {
		    this.loc = locInfo;
		    this.type = 'NullLiteral';
		    this.original = this.value = null;
		  },
	
		  Hash: function Hash(pairs, locInfo) {
		    this.loc = locInfo;
		    this.type = 'Hash';
		    this.pairs = pairs;
		  },
		  HashPair: function HashPair(key, value, locInfo) {
		    this.loc = locInfo;
		    this.type = 'HashPair';
		    this.key = key;
		    this.value = value;
		  },
	
		  // Public API used to evaluate derived attributes regarding AST nodes
		  helpers: {
		    // a mustache is definitely a helper if:
		    // * it is an eligible helper, and
		    // * it has at least one parameter or hash segment
		    helperExpression: function helperExpression(node) {
		      return !!(node.type === 'SubExpression' || node.params.length || node.hash);
		    },
	
		    scopedId: function scopedId(path) {
		      return /^\.|this\b/.test(path.original);
		    },
	
		    // an ID is simple if it only has one part, and that part is not
		    // `..` or `this`.
		    simpleId: function simpleId(path) {
		      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
		    }
		  }
		};
	
		// Must be exported as an object rather than the root of the module as the jison lexer
		// must modify the object to operate properly.
		exports['default'] = AST;
		module.exports = exports['default'];
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
		exports.parse = parse;
	
		var _parser = __webpack_require__(14);
	
		var _parser2 = _interopRequireWildcard(_parser);
	
		var _AST = __webpack_require__(2);
	
		var _AST2 = _interopRequireWildcard(_AST);
	
		var _WhitespaceControl = __webpack_require__(15);
	
		var _WhitespaceControl2 = _interopRequireWildcard(_WhitespaceControl);
	
		var _import = __webpack_require__(16);
	
		var Helpers = _interopRequireWildcard(_import);
	
		var _extend = __webpack_require__(12);
	
		exports.parser = _parser2['default'];
	
		var yy = {};
		_extend.extend(yy, Helpers, _AST2['default']);
	
		function parse(input, options) {
		  // Just return if an already-compiled AST was passed in.
		  if (input.type === 'Program') {
		    return input;
		  }
	
		  _parser2['default'].yy = yy;
	
		  // Altering the shared object here, but this is ok as parser is a sync operation
		  yy.locInfo = function (locInfo) {
		    return new yy.SourceLocation(options && options.srcName, locInfo);
		  };
	
		  var strip = new _WhitespaceControl2['default']();
		  return strip.accept(_parser2['default'].parse(input));
		}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
		exports.Compiler = Compiler;
		exports.precompile = precompile;
		exports.compile = compile;
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var _isArray$indexOf = __webpack_require__(12);
	
		var _AST = __webpack_require__(2);
	
		var _AST2 = _interopRequireWildcard(_AST);
	
		var slice = [].slice;
	
		function Compiler() {}
	
		// the foundHelper register will disambiguate helper lookup from finding a
		// function in a context. This is necessary for mustache compatibility, which
		// requires that context functions in blocks are evaluated by blockHelperMissing,
		// and then proceed as if the resulting value was provided to blockHelperMissing.
	
		Compiler.prototype = {
		  compiler: Compiler,
	
		  equals: function equals(other) {
		    var len = this.opcodes.length;
		    if (other.opcodes.length !== len) {
		      return false;
		    }
	
		    for (var i = 0; i < len; i++) {
		      var opcode = this.opcodes[i],
		          otherOpcode = other.opcodes[i];
		      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
		        return false;
		      }
		    }
	
		    // We know that length is the same between the two arrays because they are directly tied
		    // to the opcode behavior above.
		    len = this.children.length;
		    for (var i = 0; i < len; i++) {
		      if (!this.children[i].equals(other.children[i])) {
		        return false;
		      }
		    }
	
		    return true;
		  },
	
		  guid: 0,
	
		  compile: function compile(program, options) {
		    this.sourceNode = [];
		    this.opcodes = [];
		    this.children = [];
		    this.options = options;
		    this.stringParams = options.stringParams;
		    this.trackIds = options.trackIds;
	
		    options.blockParams = options.blockParams || [];
	
		    // These changes will propagate to the other compiler components
		    var knownHelpers = options.knownHelpers;
		    options.knownHelpers = {
		      helperMissing: true,
		      blockHelperMissing: true,
		      each: true,
		      'if': true,
		      unless: true,
		      'with': true,
		      log: true,
		      lookup: true
		    };
		    if (knownHelpers) {
		      for (var _name in knownHelpers) {
		        if (_name in knownHelpers) {
		          options.knownHelpers[_name] = knownHelpers[_name];
		        }
		      }
		    }
	
		    return this.accept(program);
		  },
	
		  compileProgram: function compileProgram(program) {
		    var childCompiler = new this.compiler(),
		        // eslint-disable-line new-cap
		    result = childCompiler.compile(program, this.options),
		        guid = this.guid++;
	
		    this.usePartial = this.usePartial || result.usePartial;
	
		    this.children[guid] = result;
		    this.useDepths = this.useDepths || result.useDepths;
	
		    return guid;
		  },
	
		  accept: function accept(node) {
		    this.sourceNode.unshift(node);
		    var ret = this[node.type](node);
		    this.sourceNode.shift();
		    return ret;
		  },
	
		  Program: function Program(program) {
		    this.options.blockParams.unshift(program.blockParams);
	
		    var body = program.body,
		        bodyLength = body.length;
		    for (var i = 0; i < bodyLength; i++) {
		      this.accept(body[i]);
		    }
	
		    this.options.blockParams.shift();
	
		    this.isSimple = bodyLength === 1;
		    this.blockParams = program.blockParams ? program.blockParams.length : 0;
	
		    return this;
		  },
	
		  BlockStatement: function BlockStatement(block) {
		    transformLiteralToPath(block);
	
		    var program = block.program,
		        inverse = block.inverse;
	
		    program = program && this.compileProgram(program);
		    inverse = inverse && this.compileProgram(inverse);
	
		    var type = this.classifySexpr(block);
	
		    if (type === 'helper') {
		      this.helperSexpr(block, program, inverse);
		    } else if (type === 'simple') {
		      this.simpleSexpr(block);
	
		      // now that the simple mustache is resolved, we need to
		      // evaluate it by executing `blockHelperMissing`
		      this.opcode('pushProgram', program);
		      this.opcode('pushProgram', inverse);
		      this.opcode('emptyHash');
		      this.opcode('blockValue', block.path.original);
		    } else {
		      this.ambiguousSexpr(block, program, inverse);
	
		      // now that the simple mustache is resolved, we need to
		      // evaluate it by executing `blockHelperMissing`
		      this.opcode('pushProgram', program);
		      this.opcode('pushProgram', inverse);
		      this.opcode('emptyHash');
		      this.opcode('ambiguousBlockValue');
		    }
	
		    this.opcode('append');
		  },
	
		  PartialStatement: function PartialStatement(partial) {
		    this.usePartial = true;
	
		    var params = partial.params;
		    if (params.length > 1) {
		      throw new _Exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
		    } else if (!params.length) {
		      params.push({ type: 'PathExpression', parts: [], depth: 0 });
		    }
	
		    var partialName = partial.name.original,
		        isDynamic = partial.name.type === 'SubExpression';
		    if (isDynamic) {
		      this.accept(partial.name);
		    }
	
		    this.setupFullMustacheParams(partial, undefined, undefined, true);
	
		    var indent = partial.indent || '';
		    if (this.options.preventIndent && indent) {
		      this.opcode('appendContent', indent);
		      indent = '';
		    }
	
		    this.opcode('invokePartial', isDynamic, partialName, indent);
		    this.opcode('append');
		  },
	
		  MustacheStatement: function MustacheStatement(mustache) {
		    this.SubExpression(mustache); // eslint-disable-line new-cap
	
		    if (mustache.escaped && !this.options.noEscape) {
		      this.opcode('appendEscaped');
		    } else {
		      this.opcode('append');
		    }
		  },
	
		  ContentStatement: function ContentStatement(content) {
		    if (content.value) {
		      this.opcode('appendContent', content.value);
		    }
		  },
	
		  CommentStatement: function CommentStatement() {},
	
		  SubExpression: function SubExpression(sexpr) {
		    transformLiteralToPath(sexpr);
		    var type = this.classifySexpr(sexpr);
	
		    if (type === 'simple') {
		      this.simpleSexpr(sexpr);
		    } else if (type === 'helper') {
		      this.helperSexpr(sexpr);
		    } else {
		      this.ambiguousSexpr(sexpr);
		    }
		  },
		  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
		    var path = sexpr.path,
		        name = path.parts[0],
		        isBlock = program != null || inverse != null;
	
		    this.opcode('getContext', path.depth);
	
		    this.opcode('pushProgram', program);
		    this.opcode('pushProgram', inverse);
	
		    this.accept(path);
	
		    this.opcode('invokeAmbiguous', name, isBlock);
		  },
	
		  simpleSexpr: function simpleSexpr(sexpr) {
		    this.accept(sexpr.path);
		    this.opcode('resolvePossibleLambda');
		  },
	
		  helperSexpr: function helperSexpr(sexpr, program, inverse) {
		    var params = this.setupFullMustacheParams(sexpr, program, inverse),
		        path = sexpr.path,
		        name = path.parts[0];
	
		    if (this.options.knownHelpers[name]) {
		      this.opcode('invokeKnownHelper', params.length, name);
		    } else if (this.options.knownHelpersOnly) {
		      throw new _Exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
		    } else {
		      path.falsy = true;
	
		      this.accept(path);
		      this.opcode('invokeHelper', params.length, path.original, _AST2['default'].helpers.simpleId(path));
		    }
		  },
	
		  PathExpression: function PathExpression(path) {
		    this.addDepth(path.depth);
		    this.opcode('getContext', path.depth);
	
		    var name = path.parts[0],
		        scoped = _AST2['default'].helpers.scopedId(path),
		        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
	
		    if (blockParamId) {
		      this.opcode('lookupBlockParam', blockParamId, path.parts);
		    } else if (!name) {
		      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
		      this.opcode('pushContext');
		    } else if (path.data) {
		      this.options.data = true;
		      this.opcode('lookupData', path.depth, path.parts);
		    } else {
		      this.opcode('lookupOnContext', path.parts, path.falsy, scoped);
		    }
		  },
	
		  StringLiteral: function StringLiteral(string) {
		    this.opcode('pushString', string.value);
		  },
	
		  NumberLiteral: function NumberLiteral(number) {
		    this.opcode('pushLiteral', number.value);
		  },
	
		  BooleanLiteral: function BooleanLiteral(bool) {
		    this.opcode('pushLiteral', bool.value);
		  },
	
		  UndefinedLiteral: function UndefinedLiteral() {
		    this.opcode('pushLiteral', 'undefined');
		  },
	
		  NullLiteral: function NullLiteral() {
		    this.opcode('pushLiteral', 'null');
		  },
	
		  Hash: function Hash(hash) {
		    var pairs = hash.pairs,
		        i = 0,
		        l = pairs.length;
	
		    this.opcode('pushHash');
	
		    for (; i < l; i++) {
		      this.pushParam(pairs[i].value);
		    }
		    while (i--) {
		      this.opcode('assignToHash', pairs[i].key);
		    }
		    this.opcode('popHash');
		  },
	
		  // HELPERS
		  opcode: function opcode(name) {
		    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
		  },
	
		  addDepth: function addDepth(depth) {
		    if (!depth) {
		      return;
		    }
	
		    this.useDepths = true;
		  },
	
		  classifySexpr: function classifySexpr(sexpr) {
		    var isSimple = _AST2['default'].helpers.simpleId(sexpr.path);
	
		    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
	
		    // a mustache is an eligible helper if:
		    // * its id is simple (a single part, not `this` or `..`)
		    var isHelper = !isBlockParam && _AST2['default'].helpers.helperExpression(sexpr);
	
		    // if a mustache is an eligible helper but not a definite
		    // helper, it is ambiguous, and will be resolved in a later
		    // pass or at runtime.
		    var isEligible = !isBlockParam && (isHelper || isSimple);
	
		    // if ambiguous, we can possibly resolve the ambiguity now
		    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
		    if (isEligible && !isHelper) {
		      var _name2 = sexpr.path.parts[0],
		          options = this.options;
	
		      if (options.knownHelpers[_name2]) {
		        isHelper = true;
		      } else if (options.knownHelpersOnly) {
		        isEligible = false;
		      }
		    }
	
		    if (isHelper) {
		      return 'helper';
		    } else if (isEligible) {
		      return 'ambiguous';
		    } else {
		      return 'simple';
		    }
		  },
	
		  pushParams: function pushParams(params) {
		    for (var i = 0, l = params.length; i < l; i++) {
		      this.pushParam(params[i]);
		    }
		  },
	
		  pushParam: function pushParam(val) {
		    var value = val.value != null ? val.value : val.original || '';
	
		    if (this.stringParams) {
		      if (value.replace) {
		        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
		      }
	
		      if (val.depth) {
		        this.addDepth(val.depth);
		      }
		      this.opcode('getContext', val.depth || 0);
		      this.opcode('pushStringParam', value, val.type);
	
		      if (val.type === 'SubExpression') {
		        // SubExpressions get evaluated and passed in
		        // in string params mode.
		        this.accept(val);
		      }
		    } else {
		      if (this.trackIds) {
		        var blockParamIndex = undefined;
		        if (val.parts && !_AST2['default'].helpers.scopedId(val) && !val.depth) {
		          blockParamIndex = this.blockParamIndex(val.parts[0]);
		        }
		        if (blockParamIndex) {
		          var blockParamChild = val.parts.slice(1).join('.');
		          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
		        } else {
		          value = val.original || value;
		          if (value.replace) {
		            value = value.replace(/^\.\//g, '').replace(/^\.$/g, '');
		          }
	
		          this.opcode('pushId', val.type, value);
		        }
		      }
		      this.accept(val);
		    }
		  },
	
		  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
		    var params = sexpr.params;
		    this.pushParams(params);
	
		    this.opcode('pushProgram', program);
		    this.opcode('pushProgram', inverse);
	
		    if (sexpr.hash) {
		      this.accept(sexpr.hash);
		    } else {
		      this.opcode('emptyHash', omitEmpty);
		    }
	
		    return params;
		  },
	
		  blockParamIndex: function blockParamIndex(name) {
		    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
		      var blockParams = this.options.blockParams[depth],
		          param = blockParams && _isArray$indexOf.indexOf(blockParams, name);
		      if (blockParams && param >= 0) {
		        return [depth, param];
		      }
		    }
		  }
		};
	
		function precompile(input, options, env) {
		  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
		    throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
		  }
	
		  options = options || {};
		  if (!('data' in options)) {
		    options.data = true;
		  }
		  if (options.compat) {
		    options.useDepths = true;
		  }
	
		  var ast = env.parse(input, options),
		      environment = new env.Compiler().compile(ast, options);
		  return new env.JavaScriptCompiler().compile(environment, options);
		}
	
		function compile(input, _x, env) {
		  var options = arguments[1] === undefined ? {} : arguments[1];
	
		  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
		    throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
		  }
	
		  if (!('data' in options)) {
		    options.data = true;
		  }
		  if (options.compat) {
		    options.useDepths = true;
		  }
	
		  var compiled = undefined;
	
		  function compileInput() {
		    var ast = env.parse(input, options),
		        environment = new env.Compiler().compile(ast, options),
		        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
		    return env.template(templateSpec);
		  }
	
		  // Template is only compiled on first use and cached after that point.
		  function ret(context, execOptions) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled.call(this, context, execOptions);
		  }
		  ret._setup = function (setupOptions) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled._setup(setupOptions);
		  };
		  ret._child = function (i, data, blockParams, depths) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled._child(i, data, blockParams, depths);
		  };
		  return ret;
		}
	
		function argEquals(a, b) {
		  if (a === b) {
		    return true;
		  }
	
		  if (_isArray$indexOf.isArray(a) && _isArray$indexOf.isArray(b) && a.length === b.length) {
		    for (var i = 0; i < a.length; i++) {
		      if (!argEquals(a[i], b[i])) {
		        return false;
		      }
		    }
		    return true;
		  }
		}
	
		function transformLiteralToPath(sexpr) {
		  if (!sexpr.path.parts) {
		    var literal = sexpr.path;
		    // Casting to string here to make false and 0 literal values play nicely with the rest
		    // of the system.
		    sexpr.path = new _AST2['default'].PathExpression(false, 0, [literal.original + ''], literal.original + '', literal.loc);
		  }
		}
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
	
		var _COMPILER_REVISION$REVISION_CHANGES = __webpack_require__(9);
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var _isArray = __webpack_require__(12);
	
		var _CodeGen = __webpack_require__(17);
	
		var _CodeGen2 = _interopRequireWildcard(_CodeGen);
	
		function Literal(value) {
		  this.value = value;
		}
	
		function JavaScriptCompiler() {}
	
		JavaScriptCompiler.prototype = {
		  // PUBLIC API: You can override these methods in a subclass to provide
		  // alternative compiled forms for name lookup and buffering semantics
		  nameLookup: function nameLookup(parent, name /* , type*/) {
		    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
		      return [parent, '.', name];
		    } else {
		      return [parent, '[\'', name, '\']'];
		    }
		  },
		  depthedLookup: function depthedLookup(name) {
		    return [this.aliasable('this.lookup'), '(depths, "', name, '")'];
		  },
	
		  compilerInfo: function compilerInfo() {
		    var revision = _COMPILER_REVISION$REVISION_CHANGES.COMPILER_REVISION,
		        versions = _COMPILER_REVISION$REVISION_CHANGES.REVISION_CHANGES[revision];
		    return [revision, versions];
		  },
	
		  appendToBuffer: function appendToBuffer(source, location, explicit) {
		    // Force a source as this simplifies the merge logic.
		    if (!_isArray.isArray(source)) {
		      source = [source];
		    }
		    source = this.source.wrap(source, location);
	
		    if (this.environment.isSimple) {
		      return ['return ', source, ';'];
		    } else if (explicit) {
		      // This is a case where the buffer operation occurs as a child of another
		      // construct, generally braces. We have to explicitly output these buffer
		      // operations to ensure that the emitted code goes in the correct location.
		      return ['buffer += ', source, ';'];
		    } else {
		      source.appendToBuffer = true;
		      return source;
		    }
		  },
	
		  initializeBuffer: function initializeBuffer() {
		    return this.quotedString('');
		  },
		  // END PUBLIC API
	
		  compile: function compile(environment, options, context, asObject) {
		    this.environment = environment;
		    this.options = options;
		    this.stringParams = this.options.stringParams;
		    this.trackIds = this.options.trackIds;
		    this.precompile = !asObject;
	
		    this.name = this.environment.name;
		    this.isChild = !!context;
		    this.context = context || {
		      programs: [],
		      environments: []
		    };
	
		    this.preamble();
	
		    this.stackSlot = 0;
		    this.stackVars = [];
		    this.aliases = {};
		    this.registers = { list: [] };
		    this.hashes = [];
		    this.compileStack = [];
		    this.inlineStack = [];
		    this.blockParams = [];
	
		    this.compileChildren(environment, options);
	
		    this.useDepths = this.useDepths || environment.useDepths || this.options.compat;
		    this.useBlockParams = this.useBlockParams || environment.useBlockParams;
	
		    var opcodes = environment.opcodes,
		        opcode = undefined,
		        firstLoc = undefined,
		        i = undefined,
		        l = undefined;
	
		    for (i = 0, l = opcodes.length; i < l; i++) {
		      opcode = opcodes[i];
	
		      this.source.currentLocation = opcode.loc;
		      firstLoc = firstLoc || opcode.loc;
		      this[opcode.opcode].apply(this, opcode.args);
		    }
	
		    // Flush any trailing content that might be pending.
		    this.source.currentLocation = firstLoc;
		    this.pushSource('');
	
		    /* istanbul ignore next */
		    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
		      throw new _Exception2['default']('Compile completed with content left on stack');
		    }
	
		    var fn = this.createFunctionContext(asObject);
		    if (!this.isChild) {
		      var ret = {
		        compiler: this.compilerInfo(),
		        main: fn
		      };
		      var programs = this.context.programs;
		      for (i = 0, l = programs.length; i < l; i++) {
		        if (programs[i]) {
		          ret[i] = programs[i];
		        }
		      }
	
		      if (this.environment.usePartial) {
		        ret.usePartial = true;
		      }
		      if (this.options.data) {
		        ret.useData = true;
		      }
		      if (this.useDepths) {
		        ret.useDepths = true;
		      }
		      if (this.useBlockParams) {
		        ret.useBlockParams = true;
		      }
		      if (this.options.compat) {
		        ret.compat = true;
		      }
	
		      if (!asObject) {
		        ret.compiler = JSON.stringify(ret.compiler);
	
		        this.source.currentLocation = { start: { line: 1, column: 0 } };
		        ret = this.objectLiteral(ret);
	
		        if (options.srcName) {
		          ret = ret.toStringWithSourceMap({ file: options.destName });
		          ret.map = ret.map && ret.map.toString();
		        } else {
		          ret = ret.toString();
		        }
		      } else {
		        ret.compilerOptions = this.options;
		      }
	
		      return ret;
		    } else {
		      return fn;
		    }
		  },
	
		  preamble: function preamble() {
		    // track the last context pushed into place to allow skipping the
		    // getContext opcode when it would be a noop
		    this.lastContext = 0;
		    this.source = new _CodeGen2['default'](this.options.srcName);
		  },
	
		  createFunctionContext: function createFunctionContext(asObject) {
		    var varDeclarations = '';
	
		    var locals = this.stackVars.concat(this.registers.list);
		    if (locals.length > 0) {
		      varDeclarations += ', ' + locals.join(', ');
		    }
	
		    // Generate minimizer alias mappings
		    //
		    // When using true SourceNodes, this will update all references to the given alias
		    // as the source nodes are reused in situ. For the non-source node compilation mode,
		    // aliases will not be used, but this case is already being run on the client and
		    // we aren't concern about minimizing the template size.
		    var aliasCount = 0;
		    for (var alias in this.aliases) {
		      // eslint-disable-line guard-for-in
		      var node = this.aliases[alias];
	
		      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
		        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
		        node.children[0] = 'alias' + aliasCount;
		      }
		    }
	
		    var params = ['depth0', 'helpers', 'partials', 'data'];
	
		    if (this.useBlockParams || this.useDepths) {
		      params.push('blockParams');
		    }
		    if (this.useDepths) {
		      params.push('depths');
		    }
	
		    // Perform a second pass over the output to merge content when possible
		    var source = this.mergeSource(varDeclarations);
	
		    if (asObject) {
		      params.push(source);
	
		      return Function.apply(this, params);
		    } else {
		      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
		    }
		  },
		  mergeSource: function mergeSource(varDeclarations) {
		    var isSimple = this.environment.isSimple,
		        appendOnly = !this.forceBuffer,
		        appendFirst = undefined,
		        sourceSeen = undefined,
		        bufferStart = undefined,
		        bufferEnd = undefined;
		    this.source.each(function (line) {
		      if (line.appendToBuffer) {
		        if (bufferStart) {
		          line.prepend('  + ');
		        } else {
		          bufferStart = line;
		        }
		        bufferEnd = line;
		      } else {
		        if (bufferStart) {
		          if (!sourceSeen) {
		            appendFirst = true;
		          } else {
		            bufferStart.prepend('buffer += ');
		          }
		          bufferEnd.add(';');
		          bufferStart = bufferEnd = undefined;
		        }
	
		        sourceSeen = true;
		        if (!isSimple) {
		          appendOnly = false;
		        }
		      }
		    });
	
		    if (appendOnly) {
		      if (bufferStart) {
		        bufferStart.prepend('return ');
		        bufferEnd.add(';');
		      } else if (!sourceSeen) {
		        this.source.push('return "";');
		      }
		    } else {
		      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
	
		      if (bufferStart) {
		        bufferStart.prepend('return buffer + ');
		        bufferEnd.add(';');
		      } else {
		        this.source.push('return buffer;');
		      }
		    }
	
		    if (varDeclarations) {
		      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
		    }
	
		    return this.source.merge();
		  },
	
		  // [blockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // On stack, after: return value of blockHelperMissing
		  //
		  // The purpose of this opcode is to take a block of the form
		  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
		  // replace it on the stack with the result of properly
		  // invoking blockHelperMissing.
		  blockValue: function blockValue(name) {
		    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs(name, 0, params);
	
		    var blockName = this.popStack();
		    params.splice(1, 0, blockName);
	
		    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
		  },
	
		  // [ambiguousBlockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // Compiler value, before: lastHelper=value of last found helper, if any
		  // On stack, after, if no lastHelper: same as [blockValue]
		  // On stack, after, if lastHelper: value
		  ambiguousBlockValue: function ambiguousBlockValue() {
		    // We're being a bit cheeky and reusing the options value from the prior exec
		    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs('', 0, params, true);
	
		    this.flushInline();
	
		    var current = this.topStack();
		    params.splice(1, 0, current);
	
		    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
		  },
	
		  // [appendContent]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  //
		  // Appends the string value of `content` to the current buffer
		  appendContent: function appendContent(content) {
		    if (this.pendingContent) {
		      content = this.pendingContent + content;
		    } else {
		      this.pendingLocation = this.source.currentLocation;
		    }
	
		    this.pendingContent = content;
		  },
	
		  // [append]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Coerces `value` to a String and appends it to the current buffer.
		  //
		  // If `value` is truthy, or 0, it is coerced into a string and appended
		  // Otherwise, the empty string is appended
		  append: function append() {
		    if (this.isInline()) {
		      this.replaceStack(function (current) {
		        return [' != null ? ', current, ' : ""'];
		      });
	
		      this.pushSource(this.appendToBuffer(this.popStack()));
		    } else {
		      var local = this.popStack();
		      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
		      if (this.environment.isSimple) {
		        this.pushSource(['else { ', this.appendToBuffer('\'\'', undefined, true), ' }']);
		      }
		    }
		  },
	
		  // [appendEscaped]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Escape `value` and append it to the buffer
		  appendEscaped: function appendEscaped() {
		    this.pushSource(this.appendToBuffer([this.aliasable('this.escapeExpression'), '(', this.popStack(), ')']));
		  },
	
		  // [getContext]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  // Compiler value, after: lastContext=depth
		  //
		  // Set the value of the `lastContext` compiler value to the depth
		  getContext: function getContext(depth) {
		    this.lastContext = depth;
		  },
	
		  // [pushContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext, ...
		  //
		  // Pushes the value of the current context onto the stack.
		  pushContext: function pushContext() {
		    this.pushStackLiteral(this.contextName(this.lastContext));
		  },
	
		  // [lookupOnContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext[name], ...
		  //
		  // Looks up the value of `name` on the current context and pushes
		  // it onto the stack.
		  lookupOnContext: function lookupOnContext(parts, falsy, scoped) {
		    var i = 0;
	
		    if (!scoped && this.options.compat && !this.lastContext) {
		      // The depthed query is expected to handle the undefined logic for the root level that
		      // is implemented below, so we evaluate that directly in compat mode
		      this.push(this.depthedLookup(parts[i++]));
		    } else {
		      this.pushContext();
		    }
	
		    this.resolvePath('context', parts, i, falsy);
		  },
	
		  // [lookupBlockParam]
		  //
		  // On stack, before: ...
		  // On stack, after: blockParam[name], ...
		  //
		  // Looks up the value of `parts` on the given block param and pushes
		  // it onto the stack.
		  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
		    this.useBlockParams = true;
	
		    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
		    this.resolvePath('context', parts, 1);
		  },
	
		  // [lookupData]
		  //
		  // On stack, before: ...
		  // On stack, after: data, ...
		  //
		  // Push the data lookup operator
		  lookupData: function lookupData(depth, parts) {
		    if (!depth) {
		      this.pushStackLiteral('data');
		    } else {
		      this.pushStackLiteral('this.data(data, ' + depth + ')');
		    }
	
		    this.resolvePath('data', parts, 0, true);
		  },
	
		  resolvePath: function resolvePath(type, parts, i, falsy) {
		    var _this = this;
	
		    if (this.options.strict || this.options.assumeObjects) {
		      this.push(strictLookup(this.options.strict, this, parts, type));
		      return;
		    }
	
		    var len = parts.length;
		    for (; i < len; i++) {
		      /*eslint-disable no-loop-func */
		      this.replaceStack(function (current) {
		        var lookup = _this.nameLookup(current, parts[i], type);
		        // We want to ensure that zero and false are handled properly if the context (falsy flag)
		        // needs to have the special handling for these values.
		        if (!falsy) {
		          return [' != null ? ', lookup, ' : ', current];
		        } else {
		          // Otherwise we can use generic falsy handling
		          return [' && ', lookup];
		        }
		      });
		      /*eslint-enable no-loop-func */
		    }
		  },
	
		  // [resolvePossibleLambda]
		  //
		  // On stack, before: value, ...
		  // On stack, after: resolved value, ...
		  //
		  // If the `value` is a lambda, replace it on the stack by
		  // the return value of the lambda
		  resolvePossibleLambda: function resolvePossibleLambda() {
		    this.push([this.aliasable('this.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
		  },
	
		  // [pushStringParam]
		  //
		  // On stack, before: ...
		  // On stack, after: string, currentContext, ...
		  //
		  // This opcode is designed for use in string mode, which
		  // provides the string value of a parameter along with its
		  // depth rather than resolving it immediately.
		  pushStringParam: function pushStringParam(string, type) {
		    this.pushContext();
		    this.pushString(type);
	
		    // If it's a subexpression, the string result
		    // will be pushed after this opcode.
		    if (type !== 'SubExpression') {
		      if (typeof string === 'string') {
		        this.pushString(string);
		      } else {
		        this.pushStackLiteral(string);
		      }
		    }
		  },
	
		  emptyHash: function emptyHash(omitEmpty) {
		    if (this.trackIds) {
		      this.push('{}'); // hashIds
		    }
		    if (this.stringParams) {
		      this.push('{}'); // hashContexts
		      this.push('{}'); // hashTypes
		    }
		    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
		  },
		  pushHash: function pushHash() {
		    if (this.hash) {
		      this.hashes.push(this.hash);
		    }
		    this.hash = { values: [], types: [], contexts: [], ids: [] };
		  },
		  popHash: function popHash() {
		    var hash = this.hash;
		    this.hash = this.hashes.pop();
	
		    if (this.trackIds) {
		      this.push(this.objectLiteral(hash.ids));
		    }
		    if (this.stringParams) {
		      this.push(this.objectLiteral(hash.contexts));
		      this.push(this.objectLiteral(hash.types));
		    }
	
		    this.push(this.objectLiteral(hash.values));
		  },
	
		  // [pushString]
		  //
		  // On stack, before: ...
		  // On stack, after: quotedString(string), ...
		  //
		  // Push a quoted version of `string` onto the stack
		  pushString: function pushString(string) {
		    this.pushStackLiteral(this.quotedString(string));
		  },
	
		  // [pushLiteral]
		  //
		  // On stack, before: ...
		  // On stack, after: value, ...
		  //
		  // Pushes a value onto the stack. This operation prevents
		  // the compiler from creating a temporary variable to hold
		  // it.
		  pushLiteral: function pushLiteral(value) {
		    this.pushStackLiteral(value);
		  },
	
		  // [pushProgram]
		  //
		  // On stack, before: ...
		  // On stack, after: program(guid), ...
		  //
		  // Push a program expression onto the stack. This takes
		  // a compile-time guid and converts it into a runtime-accessible
		  // expression.
		  pushProgram: function pushProgram(guid) {
		    if (guid != null) {
		      this.pushStackLiteral(this.programExpression(guid));
		    } else {
		      this.pushStackLiteral(null);
		    }
		  },
	
		  // [invokeHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // Pops off the helper's parameters, invokes the helper,
		  // and pushes the helper's return value onto the stack.
		  //
		  // If the helper is not found, `helperMissing` is called.
		  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
		    var nonHelper = this.popStack(),
		        helper = this.setupHelper(paramSize, name),
		        simple = isSimple ? [helper.name, ' || '] : '';
	
		    var lookup = ['('].concat(simple, nonHelper);
		    if (!this.options.strict) {
		      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
		    }
		    lookup.push(')');
	
		    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
		  },
	
		  // [invokeKnownHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // This operation is used when the helper is known to exist,
		  // so a `helperMissing` fallback is not required.
		  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
		    var helper = this.setupHelper(paramSize, name);
		    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
		  },
	
		  // [invokeAmbiguous]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of disambiguation
		  //
		  // This operation is used when an expression like `{{foo}}`
		  // is provided, but we don't know at compile-time whether it
		  // is a helper or a path.
		  //
		  // This operation emits more code than the other options,
		  // and can be avoided by passing the `knownHelpers` and
		  // `knownHelpersOnly` flags at compile-time.
		  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
		    this.useRegister('helper');
	
		    var nonHelper = this.popStack();
	
		    this.emptyHash();
		    var helper = this.setupHelper(0, name, helperCall);
	
		    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
	
		    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
		    if (!this.options.strict) {
		      lookup[0] = '(helper = ';
		      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
		    }
	
		    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
		  },
	
		  // [invokePartial]
		  //
		  // On stack, before: context, ...
		  // On stack after: result of partial invocation
		  //
		  // This operation pops off a context, invokes a partial with that context,
		  // and pushes the result of the invocation back.
		  invokePartial: function invokePartial(isDynamic, name, indent) {
		    var params = [],
		        options = this.setupParams(name, 1, params, false);
	
		    if (isDynamic) {
		      name = this.popStack();
		      delete options.name;
		    }
	
		    if (indent) {
		      options.indent = JSON.stringify(indent);
		    }
		    options.helpers = 'helpers';
		    options.partials = 'partials';
	
		    if (!isDynamic) {
		      params.unshift(this.nameLookup('partials', name, 'partial'));
		    } else {
		      params.unshift(name);
		    }
	
		    if (this.options.compat) {
		      options.depths = 'depths';
		    }
		    options = this.objectLiteral(options);
		    params.push(options);
	
		    this.push(this.source.functionCall('this.invokePartial', '', params));
		  },
	
		  // [assignToHash]
		  //
		  // On stack, before: value, ..., hash, ...
		  // On stack, after: ..., hash, ...
		  //
		  // Pops a value off the stack and assigns it to the current hash
		  assignToHash: function assignToHash(key) {
		    var value = this.popStack(),
		        context = undefined,
		        type = undefined,
		        id = undefined;
	
		    if (this.trackIds) {
		      id = this.popStack();
		    }
		    if (this.stringParams) {
		      type = this.popStack();
		      context = this.popStack();
		    }
	
		    var hash = this.hash;
		    if (context) {
		      hash.contexts[key] = context;
		    }
		    if (type) {
		      hash.types[key] = type;
		    }
		    if (id) {
		      hash.ids[key] = id;
		    }
		    hash.values[key] = value;
		  },
	
		  pushId: function pushId(type, name, child) {
		    if (type === 'BlockParam') {
		      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
		    } else if (type === 'PathExpression') {
		      this.pushString(name);
		    } else if (type === 'SubExpression') {
		      this.pushStackLiteral('true');
		    } else {
		      this.pushStackLiteral('null');
		    }
		  },
	
		  // HELPERS
	
		  compiler: JavaScriptCompiler,
	
		  compileChildren: function compileChildren(environment, options) {
		    var children = environment.children,
		        child = undefined,
		        compiler = undefined;
	
		    for (var i = 0, l = children.length; i < l; i++) {
		      child = children[i];
		      compiler = new this.compiler(); // eslint-disable-line new-cap
	
		      var index = this.matchExistingProgram(child);
	
		      if (index == null) {
		        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
		        index = this.context.programs.length;
		        child.index = index;
		        child.name = 'program' + index;
		        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
		        this.context.environments[index] = child;
	
		        this.useDepths = this.useDepths || compiler.useDepths;
		        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
		      } else {
		        child.index = index;
		        child.name = 'program' + index;
	
		        this.useDepths = this.useDepths || child.useDepths;
		        this.useBlockParams = this.useBlockParams || child.useBlockParams;
		      }
		    }
		  },
		  matchExistingProgram: function matchExistingProgram(child) {
		    for (var i = 0, len = this.context.environments.length; i < len; i++) {
		      var environment = this.context.environments[i];
		      if (environment && environment.equals(child)) {
		        return i;
		      }
		    }
		  },
	
		  programExpression: function programExpression(guid) {
		    var child = this.environment.children[guid],
		        programParams = [child.index, 'data', child.blockParams];
	
		    if (this.useBlockParams || this.useDepths) {
		      programParams.push('blockParams');
		    }
		    if (this.useDepths) {
		      programParams.push('depths');
		    }
	
		    return 'this.program(' + programParams.join(', ') + ')';
		  },
	
		  useRegister: function useRegister(name) {
		    if (!this.registers[name]) {
		      this.registers[name] = true;
		      this.registers.list.push(name);
		    }
		  },
	
		  push: function push(expr) {
		    if (!(expr instanceof Literal)) {
		      expr = this.source.wrap(expr);
		    }
	
		    this.inlineStack.push(expr);
		    return expr;
		  },
	
		  pushStackLiteral: function pushStackLiteral(item) {
		    this.push(new Literal(item));
		  },
	
		  pushSource: function pushSource(source) {
		    if (this.pendingContent) {
		      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		      this.pendingContent = undefined;
		    }
	
		    if (source) {
		      this.source.push(source);
		    }
		  },
	
		  replaceStack: function replaceStack(callback) {
		    var prefix = ['('],
		        stack = undefined,
		        createdStack = undefined,
		        usedLiteral = undefined;
	
		    /* istanbul ignore next */
		    if (!this.isInline()) {
		      throw new _Exception2['default']('replaceStack on non-inline');
		    }
	
		    // We want to merge the inline statement into the replacement statement via ','
		    var top = this.popStack(true);
	
		    if (top instanceof Literal) {
		      // Literals do not need to be inlined
		      stack = [top.value];
		      prefix = ['(', stack];
		      usedLiteral = true;
		    } else {
		      // Get or create the current stack name for use by the inline
		      createdStack = true;
		      var _name = this.incrStack();
	
		      prefix = ['((', this.push(_name), ' = ', top, ')'];
		      stack = this.topStack();
		    }
	
		    var item = callback.call(this, stack);
	
		    if (!usedLiteral) {
		      this.popStack();
		    }
		    if (createdStack) {
		      this.stackSlot--;
		    }
		    this.push(prefix.concat(item, ')'));
		  },
	
		  incrStack: function incrStack() {
		    this.stackSlot++;
		    if (this.stackSlot > this.stackVars.length) {
		      this.stackVars.push('stack' + this.stackSlot);
		    }
		    return this.topStackName();
		  },
		  topStackName: function topStackName() {
		    return 'stack' + this.stackSlot;
		  },
		  flushInline: function flushInline() {
		    var inlineStack = this.inlineStack;
		    this.inlineStack = [];
		    for (var i = 0, len = inlineStack.length; i < len; i++) {
		      var entry = inlineStack[i];
		      /* istanbul ignore if */
		      if (entry instanceof Literal) {
		        this.compileStack.push(entry);
		      } else {
		        var stack = this.incrStack();
		        this.pushSource([stack, ' = ', entry, ';']);
		        this.compileStack.push(stack);
		      }
		    }
		  },
		  isInline: function isInline() {
		    return this.inlineStack.length;
		  },
	
		  popStack: function popStack(wrapped) {
		    var inline = this.isInline(),
		        item = (inline ? this.inlineStack : this.compileStack).pop();
	
		    if (!wrapped && item instanceof Literal) {
		      return item.value;
		    } else {
		      if (!inline) {
		        /* istanbul ignore next */
		        if (!this.stackSlot) {
		          throw new _Exception2['default']('Invalid stack pop');
		        }
		        this.stackSlot--;
		      }
		      return item;
		    }
		  },
	
		  topStack: function topStack() {
		    var stack = this.isInline() ? this.inlineStack : this.compileStack,
		        item = stack[stack.length - 1];
	
		    /* istanbul ignore if */
		    if (item instanceof Literal) {
		      return item.value;
		    } else {
		      return item;
		    }
		  },
	
		  contextName: function contextName(context) {
		    if (this.useDepths && context) {
		      return 'depths[' + context + ']';
		    } else {
		      return 'depth' + context;
		    }
		  },
	
		  quotedString: function quotedString(str) {
		    return this.source.quotedString(str);
		  },
	
		  objectLiteral: function objectLiteral(obj) {
		    return this.source.objectLiteral(obj);
		  },
	
		  aliasable: function aliasable(name) {
		    var ret = this.aliases[name];
		    if (ret) {
		      ret.referenceCount++;
		      return ret;
		    }
	
		    ret = this.aliases[name] = this.source.wrap(name);
		    ret.aliasable = true;
		    ret.referenceCount = 1;
	
		    return ret;
		  },
	
		  setupHelper: function setupHelper(paramSize, name, blockHelper) {
		    var params = [],
		        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
		    var foundHelper = this.nameLookup('helpers', name, 'helper');
	
		    return {
		      params: params,
		      paramsInit: paramsInit,
		      name: foundHelper,
		      callParams: [this.contextName(0)].concat(params)
		    };
		  },
	
		  setupParams: function setupParams(helper, paramSize, params) {
		    var options = {},
		        contexts = [],
		        types = [],
		        ids = [],
		        param = undefined;
	
		    options.name = this.quotedString(helper);
		    options.hash = this.popStack();
	
		    if (this.trackIds) {
		      options.hashIds = this.popStack();
		    }
		    if (this.stringParams) {
		      options.hashTypes = this.popStack();
		      options.hashContexts = this.popStack();
		    }
	
		    var inverse = this.popStack(),
		        program = this.popStack();
	
		    // Avoid setting fn and inverse if neither are set. This allows
		    // helpers to do a check for `if (options.fn)`
		    if (program || inverse) {
		      options.fn = program || 'this.noop';
		      options.inverse = inverse || 'this.noop';
		    }
	
		    // The parameters go on to the stack in order (making sure that they are evaluated in order)
		    // so we need to pop them off the stack in reverse order
		    var i = paramSize;
		    while (i--) {
		      param = this.popStack();
		      params[i] = param;
	
		      if (this.trackIds) {
		        ids[i] = this.popStack();
		      }
		      if (this.stringParams) {
		        types[i] = this.popStack();
		        contexts[i] = this.popStack();
		      }
		    }
	
		    if (this.trackIds) {
		      options.ids = this.source.generateArray(ids);
		    }
		    if (this.stringParams) {
		      options.types = this.source.generateArray(types);
		      options.contexts = this.source.generateArray(contexts);
		    }
	
		    if (this.options.data) {
		      options.data = 'data';
		    }
		    if (this.useBlockParams) {
		      options.blockParams = 'blockParams';
		    }
		    return options;
		  },
	
		  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
		    var options = this.setupParams(helper, paramSize, params, true);
		    options = this.objectLiteral(options);
		    if (useRegister) {
		      this.useRegister('options');
		      params.push('options');
		      return ['options=', options];
		    } else {
		      params.push(options);
		      return '';
		    }
		  }
		};
	
		(function () {
		  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
	
		  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
	
		  for (var i = 0, l = reservedWords.length; i < l; i++) {
		    compilerWords[reservedWords[i]] = true;
		  }
		})();
	
		JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
		  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
		};
	
		function strictLookup(requireTerminal, compiler, parts, type) {
		  var stack = compiler.popStack(),
		      i = 0,
		      len = parts.length;
		  if (requireTerminal) {
		    len--;
		  }
	
		  for (; i < len; i++) {
		    stack = compiler.nameLookup(stack, parts[i], type);
		  }
	
		  if (requireTerminal) {
		    return [compiler.aliasable('this.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
		  } else {
		    return stack;
		  }
		}
	
		exports['default'] = JavaScriptCompiler;
		module.exports = exports['default'];
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var _AST = __webpack_require__(2);
	
		var _AST2 = _interopRequireWildcard(_AST);
	
		function Visitor() {
		  this.parents = [];
		}
	
		Visitor.prototype = {
		  constructor: Visitor,
		  mutating: false,
	
		  // Visits a given value. If mutating, will replace the value if necessary.
		  acceptKey: function acceptKey(node, name) {
		    var value = this.accept(node[name]);
		    if (this.mutating) {
		      // Hacky sanity check:
		      if (value && (!value.type || !_AST2['default'][value.type])) {
		        throw new _Exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
		      }
		      node[name] = value;
		    }
		  },
	
		  // Performs an accept operation with added sanity check to ensure
		  // required keys are not removed.
		  acceptRequired: function acceptRequired(node, name) {
		    this.acceptKey(node, name);
	
		    if (!node[name]) {
		      throw new _Exception2['default'](node.type + ' requires ' + name);
		    }
		  },
	
		  // Traverses a given array. If mutating, empty respnses will be removed
		  // for child elements.
		  acceptArray: function acceptArray(array) {
		    for (var i = 0, l = array.length; i < l; i++) {
		      this.acceptKey(array, i);
	
		      if (!array[i]) {
		        array.splice(i, 1);
		        i--;
		        l--;
		      }
		    }
		  },
	
		  accept: function accept(object) {
		    if (!object) {
		      return;
		    }
	
		    if (this.current) {
		      this.parents.unshift(this.current);
		    }
		    this.current = object;
	
		    var ret = this[object.type](object);
	
		    this.current = this.parents.shift();
	
		    if (!this.mutating || ret) {
		      return ret;
		    } else if (ret !== false) {
		      return object;
		    }
		  },
	
		  Program: function Program(program) {
		    this.acceptArray(program.body);
		  },
	
		  MustacheStatement: function MustacheStatement(mustache) {
		    this.acceptRequired(mustache, 'path');
		    this.acceptArray(mustache.params);
		    this.acceptKey(mustache, 'hash');
		  },
	
		  BlockStatement: function BlockStatement(block) {
		    this.acceptRequired(block, 'path');
		    this.acceptArray(block.params);
		    this.acceptKey(block, 'hash');
	
		    this.acceptKey(block, 'program');
		    this.acceptKey(block, 'inverse');
		  },
	
		  PartialStatement: function PartialStatement(partial) {
		    this.acceptRequired(partial, 'name');
		    this.acceptArray(partial.params);
		    this.acceptKey(partial, 'hash');
		  },
	
		  ContentStatement: function ContentStatement() {},
		  CommentStatement: function CommentStatement() {},
	
		  SubExpression: function SubExpression(sexpr) {
		    this.acceptRequired(sexpr, 'path');
		    this.acceptArray(sexpr.params);
		    this.acceptKey(sexpr, 'hash');
		  },
	
		  PathExpression: function PathExpression() {},
	
		  StringLiteral: function StringLiteral() {},
		  NumberLiteral: function NumberLiteral() {},
		  BooleanLiteral: function BooleanLiteral() {},
		  UndefinedLiteral: function UndefinedLiteral() {},
		  NullLiteral: function NullLiteral() {},
	
		  Hash: function Hash(hash) {
		    this.acceptArray(hash.pairs);
		  },
		  HashPair: function HashPair(pair) {
		    this.acceptRequired(pair, 'value');
		  }
		};
	
		exports['default'] = Visitor;
		module.exports = exports['default'];
		/* content */ /* comment */ /* path */ /* string */ /* number */ /* bool */ /* literal */ /* literal */
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
		exports.__esModule = true;
		/*global window */
	
		exports['default'] = function (Handlebars) {
		  /* istanbul ignore next */
		  var root = typeof global !== 'undefined' ? global : window,
		      $Handlebars = root.Handlebars;
		  /* istanbul ignore next */
		  Handlebars.noConflict = function () {
		    if (root.Handlebars === Handlebars) {
		      root.Handlebars = $Handlebars;
		    }
		  };
		};
	
		module.exports = exports['default'];
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
	
		exports["default"] = function (obj) {
		  return obj && obj.__esModule ? obj : {
		    "default": obj
		  };
		};
	
		exports.__esModule = true;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
		exports.HandlebarsEnvironment = HandlebarsEnvironment;
		exports.createFrame = createFrame;
	
		var _import = __webpack_require__(12);
	
		var Utils = _interopRequireWildcard(_import);
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var VERSION = '3.0.1';
		exports.VERSION = VERSION;
		var COMPILER_REVISION = 6;
	
		exports.COMPILER_REVISION = COMPILER_REVISION;
		var REVISION_CHANGES = {
		  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
		  2: '== 1.0.0-rc.3',
		  3: '== 1.0.0-rc.4',
		  4: '== 1.x.x',
		  5: '== 2.0.0-alpha.x',
		  6: '>= 2.0.0-beta.1'
		};
	
		exports.REVISION_CHANGES = REVISION_CHANGES;
		var isArray = Utils.isArray,
		    isFunction = Utils.isFunction,
		    toString = Utils.toString,
		    objectType = '[object Object]';
	
		function HandlebarsEnvironment(helpers, partials) {
		  this.helpers = helpers || {};
		  this.partials = partials || {};
	
		  registerDefaultHelpers(this);
		}
	
		HandlebarsEnvironment.prototype = {
		  constructor: HandlebarsEnvironment,
	
		  logger: logger,
		  log: log,
	
		  registerHelper: function registerHelper(name, fn) {
		    if (toString.call(name) === objectType) {
		      if (fn) {
		        throw new _Exception2['default']('Arg not supported with multiple helpers');
		      }
		      Utils.extend(this.helpers, name);
		    } else {
		      this.helpers[name] = fn;
		    }
		  },
		  unregisterHelper: function unregisterHelper(name) {
		    delete this.helpers[name];
		  },
	
		  registerPartial: function registerPartial(name, partial) {
		    if (toString.call(name) === objectType) {
		      Utils.extend(this.partials, name);
		    } else {
		      if (typeof partial === 'undefined') {
		        throw new _Exception2['default']('Attempting to register a partial as undefined');
		      }
		      this.partials[name] = partial;
		    }
		  },
		  unregisterPartial: function unregisterPartial(name) {
		    delete this.partials[name];
		  }
		};
	
		function registerDefaultHelpers(instance) {
		  instance.registerHelper('helperMissing', function () {
		    if (arguments.length === 1) {
		      // A missing field in a {{foo}} constuct.
		      return undefined;
		    } else {
		      // Someone is actually trying to call something, blow up.
		      throw new _Exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
		    }
		  });
	
		  instance.registerHelper('blockHelperMissing', function (context, options) {
		    var inverse = options.inverse,
		        fn = options.fn;
	
		    if (context === true) {
		      return fn(this);
		    } else if (context === false || context == null) {
		      return inverse(this);
		    } else if (isArray(context)) {
		      if (context.length > 0) {
		        if (options.ids) {
		          options.ids = [options.name];
		        }
	
		        return instance.helpers.each(context, options);
		      } else {
		        return inverse(this);
		      }
		    } else {
		      if (options.data && options.ids) {
		        var data = createFrame(options.data);
		        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
		        options = { data: data };
		      }
	
		      return fn(context, options);
		    }
		  });
	
		  instance.registerHelper('each', function (context, options) {
		    if (!options) {
		      throw new _Exception2['default']('Must pass iterator to #each');
		    }
	
		    var fn = options.fn,
		        inverse = options.inverse,
		        i = 0,
		        ret = '',
		        data = undefined,
		        contextPath = undefined;
	
		    if (options.data && options.ids) {
		      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
		    }
	
		    if (isFunction(context)) {
		      context = context.call(this);
		    }
	
		    if (options.data) {
		      data = createFrame(options.data);
		    }
	
		    function execIteration(field, index, last) {
		      if (data) {
		        data.key = field;
		        data.index = index;
		        data.first = index === 0;
		        data.last = !!last;
	
		        if (contextPath) {
		          data.contextPath = contextPath + field;
		        }
		      }
	
		      ret = ret + fn(context[field], {
		        data: data,
		        blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])
		      });
		    }
	
		    if (context && typeof context === 'object') {
		      if (isArray(context)) {
		        for (var j = context.length; i < j; i++) {
		          execIteration(i, i, i === context.length - 1);
		        }
		      } else {
		        var priorKey = undefined;
	
		        for (var key in context) {
		          if (context.hasOwnProperty(key)) {
		            // We're running the iterations one step out of sync so we can detect
		            // the last iteration without have to scan the object twice and create
		            // an itermediate keys array.
		            if (priorKey) {
		              execIteration(priorKey, i - 1);
		            }
		            priorKey = key;
		            i++;
		          }
		        }
		        if (priorKey) {
		          execIteration(priorKey, i - 1, true);
		        }
		      }
		    }
	
		    if (i === 0) {
		      ret = inverse(this);
		    }
	
		    return ret;
		  });
	
		  instance.registerHelper('if', function (conditional, options) {
		    if (isFunction(conditional)) {
		      conditional = conditional.call(this);
		    }
	
		    // Default behavior is to render the positive path if the value is truthy and not empty.
		    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
		    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
		    if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
		      return options.inverse(this);
		    } else {
		      return options.fn(this);
		    }
		  });
	
		  instance.registerHelper('unless', function (conditional, options) {
		    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
		  });
	
		  instance.registerHelper('with', function (context, options) {
		    if (isFunction(context)) {
		      context = context.call(this);
		    }
	
		    var fn = options.fn;
	
		    if (!Utils.isEmpty(context)) {
		      if (options.data && options.ids) {
		        var data = createFrame(options.data);
		        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
		        options = { data: data };
		      }
	
		      return fn(context, options);
		    } else {
		      return options.inverse(this);
		    }
		  });
	
		  instance.registerHelper('log', function (message, options) {
		    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
		    instance.log(level, message);
		  });
	
		  instance.registerHelper('lookup', function (obj, field) {
		    return obj && obj[field];
		  });
		}
	
		var logger = {
		  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },
	
		  // State enum
		  DEBUG: 0,
		  INFO: 1,
		  WARN: 2,
		  ERROR: 3,
		  level: 1,
	
		  // Can be overridden in the host environment
		  log: function log(level, message) {
		    if (typeof console !== 'undefined' && logger.level <= level) {
		      var method = logger.methodMap[level];
		      (console[method] || console.log).call(console, message); // eslint-disable-line no-console
		    }
		  }
		};
	
		exports.logger = logger;
		var log = logger.log;
	
		exports.log = log;
	
		function createFrame(object) {
		  var frame = Utils.extend({}, object);
		  frame._parent = object;
		  return frame;
		}
	
		/* [args, ]options */
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
		// Build out our basic SafeString type
		function SafeString(string) {
		  this.string = string;
		}
	
		SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
		  return '' + this.string;
		};
	
		exports['default'] = SafeString;
		module.exports = exports['default'];
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
	
		var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
	
		function Exception(message, node) {
		  var loc = node && node.loc,
		      line = undefined,
		      column = undefined;
		  if (loc) {
		    line = loc.start.line;
		    column = loc.start.column;
	
		    message += ' - ' + line + ':' + column;
		  }
	
		  var tmp = Error.prototype.constructor.call(this, message);
	
		  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
		  for (var idx = 0; idx < errorProps.length; idx++) {
		    this[errorProps[idx]] = tmp[errorProps[idx]];
		  }
	
		  if (Error.captureStackTrace) {
		    Error.captureStackTrace(this, Exception);
		  }
	
		  if (loc) {
		    this.lineNumber = line;
		    this.column = column;
		  }
		}
	
		Exception.prototype = new Error();
	
		exports['default'] = Exception;
		module.exports = exports['default'];
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
		exports.extend = extend;
	
		// Older IE versions do not directly support indexOf so we must implement our own, sadly.
		exports.indexOf = indexOf;
		exports.escapeExpression = escapeExpression;
		exports.isEmpty = isEmpty;
		exports.blockParams = blockParams;
		exports.appendContextPath = appendContextPath;
		var escape = {
		  '&': '&amp;',
		  '<': '&lt;',
		  '>': '&gt;',
		  '"': '&quot;',
		  '\'': '&#x27;',
		  '`': '&#x60;'
		};
	
		var badChars = /[&<>"'`]/g,
		    possible = /[&<>"'`]/;
	
		function escapeChar(chr) {
		  return escape[chr];
		}
	
		function extend(obj /* , ...source */) {
		  for (var i = 1; i < arguments.length; i++) {
		    for (var key in arguments[i]) {
		      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
		        obj[key] = arguments[i][key];
		      }
		    }
		  }
	
		  return obj;
		}
	
		var toString = Object.prototype.toString;
	
		exports.toString = toString;
		// Sourced from lodash
		// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
		/*eslint-disable func-style, no-var */
		var isFunction = function isFunction(value) {
		  return typeof value === 'function';
		};
		// fallback for older versions of Chrome and Safari
		/* istanbul ignore next */
		if (isFunction(/x/)) {
		  exports.isFunction = isFunction = function (value) {
		    return typeof value === 'function' && toString.call(value) === '[object Function]';
		  };
		}
		var isFunction;
		exports.isFunction = isFunction;
		/*eslint-enable func-style, no-var */
	
		/* istanbul ignore next */
		var isArray = Array.isArray || function (value) {
		  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
		};exports.isArray = isArray;
	
		function indexOf(array, value) {
		  for (var i = 0, len = array.length; i < len; i++) {
		    if (array[i] === value) {
		      return i;
		    }
		  }
		  return -1;
		}
	
		function escapeExpression(string) {
		  if (typeof string !== 'string') {
		    // don't escape SafeStrings, since they're already safe
		    if (string && string.toHTML) {
		      return string.toHTML();
		    } else if (string == null) {
		      return '';
		    } else if (!string) {
		      return string + '';
		    }
	
		    // Force a string conversion as this will be done by the append regardless and
		    // the regex test will do this transparently behind the scenes, causing issues if
		    // an object's to string has escaped characters in it.
		    string = '' + string;
		  }
	
		  if (!possible.test(string)) {
		    return string;
		  }
		  return string.replace(badChars, escapeChar);
		}
	
		function isEmpty(value) {
		  if (!value && value !== 0) {
		    return true;
		  } else if (isArray(value) && value.length === 0) {
		    return true;
		  } else {
		    return false;
		  }
		}
	
		function blockParams(params, ids) {
		  params.path = ids;
		  return params;
		}
	
		function appendContextPath(contextPath, id) {
		  return (contextPath ? contextPath + '.' : '') + id;
		}
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
		exports.checkRevision = checkRevision;
	
		// TODO: Remove this line and break up compilePartial
	
		exports.template = template;
		exports.wrapProgram = wrapProgram;
		exports.resolvePartial = resolvePartial;
		exports.invokePartial = invokePartial;
		exports.noop = noop;
	
		var _import = __webpack_require__(12);
	
		var Utils = _interopRequireWildcard(_import);
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		var _COMPILER_REVISION$REVISION_CHANGES$createFrame = __webpack_require__(9);
	
		function checkRevision(compilerInfo) {
		  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
		      currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;
	
		  if (compilerRevision !== currentRevision) {
		    if (compilerRevision < currentRevision) {
		      var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],
		          compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];
		      throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
		    } else {
		      // Use the embedded version info since the runtime doesn't know about this revision yet
		      throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
		    }
		  }
		}
	
		function template(templateSpec, env) {
		  /* istanbul ignore next */
		  if (!env) {
		    throw new _Exception2['default']('No environment passed to template');
		  }
		  if (!templateSpec || !templateSpec.main) {
		    throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);
		  }
	
		  // Note: Using env.VM references rather than local var references throughout this section to allow
		  // for external users to override these as psuedo-supported APIs.
		  env.VM.checkRevision(templateSpec.compiler);
	
		  function invokePartialWrapper(partial, context, options) {
		    if (options.hash) {
		      context = Utils.extend({}, context, options.hash);
		    }
	
		    partial = env.VM.resolvePartial.call(this, partial, context, options);
		    var result = env.VM.invokePartial.call(this, partial, context, options);
	
		    if (result == null && env.compile) {
		      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
		      result = options.partials[options.name](context, options);
		    }
		    if (result != null) {
		      if (options.indent) {
		        var lines = result.split('\n');
		        for (var i = 0, l = lines.length; i < l; i++) {
		          if (!lines[i] && i + 1 === l) {
		            break;
		          }
	
		          lines[i] = options.indent + lines[i];
		        }
		        result = lines.join('\n');
		      }
		      return result;
		    } else {
		      throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
		    }
		  }
	
		  // Just add water
		  var container = {
		    strict: function strict(obj, name) {
		      if (!(name in obj)) {
		        throw new _Exception2['default']('"' + name + '" not defined in ' + obj);
		      }
		      return obj[name];
		    },
		    lookup: function lookup(depths, name) {
		      var len = depths.length;
		      for (var i = 0; i < len; i++) {
		        if (depths[i] && depths[i][name] != null) {
		          return depths[i][name];
		        }
		      }
		    },
		    lambda: function lambda(current, context) {
		      return typeof current === 'function' ? current.call(context) : current;
		    },
	
		    escapeExpression: Utils.escapeExpression,
		    invokePartial: invokePartialWrapper,
	
		    fn: function fn(i) {
		      return templateSpec[i];
		    },
	
		    programs: [],
		    program: function program(i, data, declaredBlockParams, blockParams, depths) {
		      var programWrapper = this.programs[i],
		          fn = this.fn(i);
		      if (data || depths || blockParams || declaredBlockParams) {
		        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
		      } else if (!programWrapper) {
		        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
		      }
		      return programWrapper;
		    },
	
		    data: function data(value, depth) {
		      while (value && depth--) {
		        value = value._parent;
		      }
		      return value;
		    },
		    merge: function merge(param, common) {
		      var obj = param || common;
	
		      if (param && common && param !== common) {
		        obj = Utils.extend({}, common, param);
		      }
	
		      return obj;
		    },
	
		    noop: env.VM.noop,
		    compilerInfo: templateSpec.compiler
		  };
	
		  function ret(context) {
		    var options = arguments[1] === undefined ? {} : arguments[1];
	
		    var data = options.data;
	
		    ret._setup(options);
		    if (!options.partial && templateSpec.useData) {
		      data = initData(context, data);
		    }
		    var depths = undefined,
		        blockParams = templateSpec.useBlockParams ? [] : undefined;
		    if (templateSpec.useDepths) {
		      depths = options.depths ? [context].concat(options.depths) : [context];
		    }
	
		    return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
		  }
		  ret.isTop = true;
	
		  ret._setup = function (options) {
		    if (!options.partial) {
		      container.helpers = container.merge(options.helpers, env.helpers);
	
		      if (templateSpec.usePartial) {
		        container.partials = container.merge(options.partials, env.partials);
		      }
		    } else {
		      container.helpers = options.helpers;
		      container.partials = options.partials;
		    }
		  };
	
		  ret._child = function (i, data, blockParams, depths) {
		    if (templateSpec.useBlockParams && !blockParams) {
		      throw new _Exception2['default']('must pass block params');
		    }
		    if (templateSpec.useDepths && !depths) {
		      throw new _Exception2['default']('must pass parent depths');
		    }
	
		    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
		  };
		  return ret;
		}
	
		function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
		  function prog(context) {
		    var options = arguments[1] === undefined ? {} : arguments[1];
	
		    return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));
		  }
		  prog.program = i;
		  prog.depth = depths ? depths.length : 0;
		  prog.blockParams = declaredBlockParams || 0;
		  return prog;
		}
	
		function resolvePartial(partial, context, options) {
		  if (!partial) {
		    partial = options.partials[options.name];
		  } else if (!partial.call && !options.name) {
		    // This is a dynamic partial that returned a string
		    options.name = partial;
		    partial = options.partials[partial];
		  }
		  return partial;
		}
	
		function invokePartial(partial, context, options) {
		  options.partial = true;
	
		  if (partial === undefined) {
		    throw new _Exception2['default']('The partial ' + options.name + ' could not be found');
		  } else if (partial instanceof Function) {
		    return partial(context, options);
		  }
		}
	
		function noop() {
		  return '';
		}
	
		function initData(context, data) {
		  if (!data || !('root' in data)) {
		    data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};
		    data.root = context;
		  }
		  return data;
		}
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
		"use strict";
	
		exports.__esModule = true;
		/* istanbul ignore next */
		/* Jison generated parser */
		var handlebars = (function () {
		    var parser = { trace: function trace() {},
		        yy: {},
		        symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, content: 12, COMMENT: 13, CONTENT: 14, openRawBlock: 15, END_RAW_BLOCK: 16, OPEN_RAW_BLOCK: 17, helperName: 18, openRawBlock_repetition0: 19, openRawBlock_option0: 20, CLOSE_RAW_BLOCK: 21, openBlock: 22, block_option0: 23, closeBlock: 24, openInverse: 25, block_option1: 26, OPEN_BLOCK: 27, openBlock_repetition0: 28, openBlock_option0: 29, openBlock_option1: 30, CLOSE: 31, OPEN_INVERSE: 32, openInverse_repetition0: 33, openInverse_option0: 34, openInverse_option1: 35, openInverseChain: 36, OPEN_INVERSE_CHAIN: 37, openInverseChain_repetition0: 38, openInverseChain_option0: 39, openInverseChain_option1: 40, inverseAndProgram: 41, INVERSE: 42, inverseChain: 43, inverseChain_option0: 44, OPEN_ENDBLOCK: 45, OPEN: 46, mustache_repetition0: 47, mustache_option0: 48, OPEN_UNESCAPED: 49, mustache_repetition1: 50, mustache_option1: 51, CLOSE_UNESCAPED: 52, OPEN_PARTIAL: 53, partialName: 54, partial_repetition0: 55, partial_option0: 56, param: 57, sexpr: 58, OPEN_SEXPR: 59, sexpr_repetition0: 60, sexpr_option0: 61, CLOSE_SEXPR: 62, hash: 63, hash_repetition_plus0: 64, hashSegment: 65, ID: 66, EQUALS: 67, blockParams: 68, OPEN_BLOCK_PARAMS: 69, blockParams_repetition_plus0: 70, CLOSE_BLOCK_PARAMS: 71, path: 72, dataName: 73, STRING: 74, NUMBER: 75, BOOLEAN: 76, UNDEFINED: 77, NULL: 78, DATA: 79, pathSegments: 80, SEP: 81, $accept: 0, $end: 1 },
		        terminals_: { 2: "error", 5: "EOF", 13: "COMMENT", 14: "CONTENT", 16: "END_RAW_BLOCK", 17: "OPEN_RAW_BLOCK", 21: "CLOSE_RAW_BLOCK", 27: "OPEN_BLOCK", 31: "CLOSE", 32: "OPEN_INVERSE", 37: "OPEN_INVERSE_CHAIN", 42: "INVERSE", 45: "OPEN_ENDBLOCK", 46: "OPEN", 49: "OPEN_UNESCAPED", 52: "CLOSE_UNESCAPED", 53: "OPEN_PARTIAL", 59: "OPEN_SEXPR", 62: "CLOSE_SEXPR", 66: "ID", 67: "EQUALS", 69: "OPEN_BLOCK_PARAMS", 71: "CLOSE_BLOCK_PARAMS", 74: "STRING", 75: "NUMBER", 76: "BOOLEAN", 77: "UNDEFINED", 78: "NULL", 79: "DATA", 81: "SEP" },
		        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [12, 1], [10, 3], [15, 5], [9, 4], [9, 4], [22, 6], [25, 6], [36, 6], [41, 2], [43, 3], [43, 1], [24, 3], [8, 5], [8, 5], [11, 5], [57, 1], [57, 1], [58, 5], [63, 1], [65, 3], [68, 3], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [54, 1], [54, 1], [73, 2], [72, 1], [80, 3], [80, 1], [6, 0], [6, 2], [19, 0], [19, 2], [20, 0], [20, 1], [23, 0], [23, 1], [26, 0], [26, 1], [28, 0], [28, 2], [29, 0], [29, 1], [30, 0], [30, 1], [33, 0], [33, 2], [34, 0], [34, 1], [35, 0], [35, 1], [38, 0], [38, 2], [39, 0], [39, 1], [40, 0], [40, 1], [44, 0], [44, 1], [47, 0], [47, 2], [48, 0], [48, 1], [50, 0], [50, 2], [51, 0], [51, 1], [55, 0], [55, 2], [56, 0], [56, 1], [60, 0], [60, 2], [61, 0], [61, 1], [64, 1], [64, 2], [70, 1], [70, 2]],
		        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
	
		            var $0 = $$.length - 1;
		            switch (yystate) {
		                case 1:
		                    return $$[$0 - 1];
		                    break;
		                case 2:
		                    this.$ = new yy.Program($$[$0], null, {}, yy.locInfo(this._$));
		                    break;
		                case 3:
		                    this.$ = $$[$0];
		                    break;
		                case 4:
		                    this.$ = $$[$0];
		                    break;
		                case 5:
		                    this.$ = $$[$0];
		                    break;
		                case 6:
		                    this.$ = $$[$0];
		                    break;
		                case 7:
		                    this.$ = $$[$0];
		                    break;
		                case 8:
		                    this.$ = new yy.CommentStatement(yy.stripComment($$[$0]), yy.stripFlags($$[$0], $$[$0]), yy.locInfo(this._$));
		                    break;
		                case 9:
		                    this.$ = new yy.ContentStatement($$[$0], yy.locInfo(this._$));
		                    break;
		                case 10:
		                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
		                    break;
		                case 11:
		                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
		                    break;
		                case 12:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
		                    break;
		                case 13:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
		                    break;
		                case 14:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 15:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 16:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 17:
		                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
		                    break;
		                case 18:
		                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
		                        program = new yy.Program([inverse], null, {}, yy.locInfo(this._$));
		                    program.chained = true;
	
		                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };
	
		                    break;
		                case 19:
		                    this.$ = $$[$0];
		                    break;
		                case 20:
		                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
		                    break;
		                case 21:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 22:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 23:
		                    this.$ = new yy.PartialStatement($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.stripFlags($$[$0 - 4], $$[$0]), yy.locInfo(this._$));
		                    break;
		                case 24:
		                    this.$ = $$[$0];
		                    break;
		                case 25:
		                    this.$ = $$[$0];
		                    break;
		                case 26:
		                    this.$ = new yy.SubExpression($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.locInfo(this._$));
		                    break;
		                case 27:
		                    this.$ = new yy.Hash($$[$0], yy.locInfo(this._$));
		                    break;
		                case 28:
		                    this.$ = new yy.HashPair(yy.id($$[$0 - 2]), $$[$0], yy.locInfo(this._$));
		                    break;
		                case 29:
		                    this.$ = yy.id($$[$0 - 1]);
		                    break;
		                case 30:
		                    this.$ = $$[$0];
		                    break;
		                case 31:
		                    this.$ = $$[$0];
		                    break;
		                case 32:
		                    this.$ = new yy.StringLiteral($$[$0], yy.locInfo(this._$));
		                    break;
		                case 33:
		                    this.$ = new yy.NumberLiteral($$[$0], yy.locInfo(this._$));
		                    break;
		                case 34:
		                    this.$ = new yy.BooleanLiteral($$[$0], yy.locInfo(this._$));
		                    break;
		                case 35:
		                    this.$ = new yy.UndefinedLiteral(yy.locInfo(this._$));
		                    break;
		                case 36:
		                    this.$ = new yy.NullLiteral(yy.locInfo(this._$));
		                    break;
		                case 37:
		                    this.$ = $$[$0];
		                    break;
		                case 38:
		                    this.$ = $$[$0];
		                    break;
		                case 39:
		                    this.$ = yy.preparePath(true, $$[$0], this._$);
		                    break;
		                case 40:
		                    this.$ = yy.preparePath(false, $$[$0], this._$);
		                    break;
		                case 41:
		                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
		                    break;
		                case 42:
		                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
		                    break;
		                case 43:
		                    this.$ = [];
		                    break;
		                case 44:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 45:
		                    this.$ = [];
		                    break;
		                case 46:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 53:
		                    this.$ = [];
		                    break;
		                case 54:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 59:
		                    this.$ = [];
		                    break;
		                case 60:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 65:
		                    this.$ = [];
		                    break;
		                case 66:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 73:
		                    this.$ = [];
		                    break;
		                case 74:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 77:
		                    this.$ = [];
		                    break;
		                case 78:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 81:
		                    this.$ = [];
		                    break;
		                case 82:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 85:
		                    this.$ = [];
		                    break;
		                case 86:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 89:
		                    this.$ = [$$[$0]];
		                    break;
		                case 90:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 91:
		                    this.$ = [$$[$0]];
		                    break;
		                case 92:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		            }
		        },
		        table: [{ 3: 1, 4: 2, 5: [2, 43], 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: [1, 11], 14: [1, 18], 15: 16, 17: [1, 21], 22: 14, 25: 15, 27: [1, 19], 32: [1, 20], 37: [2, 2], 42: [2, 2], 45: [2, 2], 46: [1, 12], 49: [1, 13], 53: [1, 17] }, { 1: [2, 1] }, { 5: [2, 44], 13: [2, 44], 14: [2, 44], 17: [2, 44], 27: [2, 44], 32: [2, 44], 37: [2, 44], 42: [2, 44], 45: [2, 44], 46: [2, 44], 49: [2, 44], 53: [2, 44] }, { 5: [2, 3], 13: [2, 3], 14: [2, 3], 17: [2, 3], 27: [2, 3], 32: [2, 3], 37: [2, 3], 42: [2, 3], 45: [2, 3], 46: [2, 3], 49: [2, 3], 53: [2, 3] }, { 5: [2, 4], 13: [2, 4], 14: [2, 4], 17: [2, 4], 27: [2, 4], 32: [2, 4], 37: [2, 4], 42: [2, 4], 45: [2, 4], 46: [2, 4], 49: [2, 4], 53: [2, 4] }, { 5: [2, 5], 13: [2, 5], 14: [2, 5], 17: [2, 5], 27: [2, 5], 32: [2, 5], 37: [2, 5], 42: [2, 5], 45: [2, 5], 46: [2, 5], 49: [2, 5], 53: [2, 5] }, { 5: [2, 6], 13: [2, 6], 14: [2, 6], 17: [2, 6], 27: [2, 6], 32: [2, 6], 37: [2, 6], 42: [2, 6], 45: [2, 6], 46: [2, 6], 49: [2, 6], 53: [2, 6] }, { 5: [2, 7], 13: [2, 7], 14: [2, 7], 17: [2, 7], 27: [2, 7], 32: [2, 7], 37: [2, 7], 42: [2, 7], 45: [2, 7], 46: [2, 7], 49: [2, 7], 53: [2, 7] }, { 5: [2, 8], 13: [2, 8], 14: [2, 8], 17: [2, 8], 27: [2, 8], 32: [2, 8], 37: [2, 8], 42: [2, 8], 45: [2, 8], 46: [2, 8], 49: [2, 8], 53: [2, 8] }, { 18: 22, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 33, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 34, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 4: 35, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 12: 36, 14: [1, 18] }, { 18: 38, 54: 37, 58: 39, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 9], 13: [2, 9], 14: [2, 9], 16: [2, 9], 17: [2, 9], 27: [2, 9], 32: [2, 9], 37: [2, 9], 42: [2, 9], 45: [2, 9], 46: [2, 9], 49: [2, 9], 53: [2, 9] }, { 18: 41, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 42, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 43, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [2, 73], 47: 44, 59: [2, 73], 66: [2, 73], 74: [2, 73], 75: [2, 73], 76: [2, 73], 77: [2, 73], 78: [2, 73], 79: [2, 73] }, { 21: [2, 30], 31: [2, 30], 52: [2, 30], 59: [2, 30], 62: [2, 30], 66: [2, 30], 69: [2, 30], 74: [2, 30], 75: [2, 30], 76: [2, 30], 77: [2, 30], 78: [2, 30], 79: [2, 30] }, { 21: [2, 31], 31: [2, 31], 52: [2, 31], 59: [2, 31], 62: [2, 31], 66: [2, 31], 69: [2, 31], 74: [2, 31], 75: [2, 31], 76: [2, 31], 77: [2, 31], 78: [2, 31], 79: [2, 31] }, { 21: [2, 32], 31: [2, 32], 52: [2, 32], 59: [2, 32], 62: [2, 32], 66: [2, 32], 69: [2, 32], 74: [2, 32], 75: [2, 32], 76: [2, 32], 77: [2, 32], 78: [2, 32], 79: [2, 32] }, { 21: [2, 33], 31: [2, 33], 52: [2, 33], 59: [2, 33], 62: [2, 33], 66: [2, 33], 69: [2, 33], 74: [2, 33], 75: [2, 33], 76: [2, 33], 77: [2, 33], 78: [2, 33], 79: [2, 33] }, { 21: [2, 34], 31: [2, 34], 52: [2, 34], 59: [2, 34], 62: [2, 34], 66: [2, 34], 69: [2, 34], 74: [2, 34], 75: [2, 34], 76: [2, 34], 77: [2, 34], 78: [2, 34], 79: [2, 34] }, { 21: [2, 35], 31: [2, 35], 52: [2, 35], 59: [2, 35], 62: [2, 35], 66: [2, 35], 69: [2, 35], 74: [2, 35], 75: [2, 35], 76: [2, 35], 77: [2, 35], 78: [2, 35], 79: [2, 35] }, { 21: [2, 36], 31: [2, 36], 52: [2, 36], 59: [2, 36], 62: [2, 36], 66: [2, 36], 69: [2, 36], 74: [2, 36], 75: [2, 36], 76: [2, 36], 77: [2, 36], 78: [2, 36], 79: [2, 36] }, { 21: [2, 40], 31: [2, 40], 52: [2, 40], 59: [2, 40], 62: [2, 40], 66: [2, 40], 69: [2, 40], 74: [2, 40], 75: [2, 40], 76: [2, 40], 77: [2, 40], 78: [2, 40], 79: [2, 40], 81: [1, 45] }, { 66: [1, 32], 80: 46 }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 50: 47, 52: [2, 77], 59: [2, 77], 66: [2, 77], 74: [2, 77], 75: [2, 77], 76: [2, 77], 77: [2, 77], 78: [2, 77], 79: [2, 77] }, { 23: 48, 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 49, 45: [2, 49] }, { 26: 54, 41: 55, 42: [1, 53], 45: [2, 51] }, { 16: [1, 56] }, { 31: [2, 81], 55: 57, 59: [2, 81], 66: [2, 81], 74: [2, 81], 75: [2, 81], 76: [2, 81], 77: [2, 81], 78: [2, 81], 79: [2, 81] }, { 31: [2, 37], 59: [2, 37], 66: [2, 37], 74: [2, 37], 75: [2, 37], 76: [2, 37], 77: [2, 37], 78: [2, 37], 79: [2, 37] }, { 31: [2, 38], 59: [2, 38], 66: [2, 38], 74: [2, 38], 75: [2, 38], 76: [2, 38], 77: [2, 38], 78: [2, 38], 79: [2, 38] }, { 18: 58, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 28: 59, 31: [2, 53], 59: [2, 53], 66: [2, 53], 69: [2, 53], 74: [2, 53], 75: [2, 53], 76: [2, 53], 77: [2, 53], 78: [2, 53], 79: [2, 53] }, { 31: [2, 59], 33: 60, 59: [2, 59], 66: [2, 59], 69: [2, 59], 74: [2, 59], 75: [2, 59], 76: [2, 59], 77: [2, 59], 78: [2, 59], 79: [2, 59] }, { 19: 61, 21: [2, 45], 59: [2, 45], 66: [2, 45], 74: [2, 45], 75: [2, 45], 76: [2, 45], 77: [2, 45], 78: [2, 45], 79: [2, 45] }, { 18: 65, 31: [2, 75], 48: 62, 57: 63, 58: 66, 59: [1, 40], 63: 64, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 66: [1, 70] }, { 21: [2, 39], 31: [2, 39], 52: [2, 39], 59: [2, 39], 62: [2, 39], 66: [2, 39], 69: [2, 39], 74: [2, 39], 75: [2, 39], 76: [2, 39], 77: [2, 39], 78: [2, 39], 79: [2, 39], 81: [1, 45] }, { 18: 65, 51: 71, 52: [2, 79], 57: 72, 58: 66, 59: [1, 40], 63: 73, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 24: 74, 45: [1, 75] }, { 45: [2, 50] }, { 4: 76, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 45: [2, 19] }, { 18: 77, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 78, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 24: 79, 45: [1, 75] }, { 45: [2, 52] }, { 5: [2, 10], 13: [2, 10], 14: [2, 10], 17: [2, 10], 27: [2, 10], 32: [2, 10], 37: [2, 10], 42: [2, 10], 45: [2, 10], 46: [2, 10], 49: [2, 10], 53: [2, 10] }, { 18: 65, 31: [2, 83], 56: 80, 57: 81, 58: 66, 59: [1, 40], 63: 82, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 59: [2, 85], 60: 83, 62: [2, 85], 66: [2, 85], 74: [2, 85], 75: [2, 85], 76: [2, 85], 77: [2, 85], 78: [2, 85], 79: [2, 85] }, { 18: 65, 29: 84, 31: [2, 55], 57: 85, 58: 66, 59: [1, 40], 63: 86, 64: 67, 65: 68, 66: [1, 69], 69: [2, 55], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 31: [2, 61], 34: 87, 57: 88, 58: 66, 59: [1, 40], 63: 89, 64: 67, 65: 68, 66: [1, 69], 69: [2, 61], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 20: 90, 21: [2, 47], 57: 91, 58: 66, 59: [1, 40], 63: 92, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [1, 93] }, { 31: [2, 74], 59: [2, 74], 66: [2, 74], 74: [2, 74], 75: [2, 74], 76: [2, 74], 77: [2, 74], 78: [2, 74], 79: [2, 74] }, { 31: [2, 76] }, { 21: [2, 24], 31: [2, 24], 52: [2, 24], 59: [2, 24], 62: [2, 24], 66: [2, 24], 69: [2, 24], 74: [2, 24], 75: [2, 24], 76: [2, 24], 77: [2, 24], 78: [2, 24], 79: [2, 24] }, { 21: [2, 25], 31: [2, 25], 52: [2, 25], 59: [2, 25], 62: [2, 25], 66: [2, 25], 69: [2, 25], 74: [2, 25], 75: [2, 25], 76: [2, 25], 77: [2, 25], 78: [2, 25], 79: [2, 25] }, { 21: [2, 27], 31: [2, 27], 52: [2, 27], 62: [2, 27], 65: 94, 66: [1, 95], 69: [2, 27] }, { 21: [2, 89], 31: [2, 89], 52: [2, 89], 62: [2, 89], 66: [2, 89], 69: [2, 89] }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 67: [1, 96], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 21: [2, 41], 31: [2, 41], 52: [2, 41], 59: [2, 41], 62: [2, 41], 66: [2, 41], 69: [2, 41], 74: [2, 41], 75: [2, 41], 76: [2, 41], 77: [2, 41], 78: [2, 41], 79: [2, 41], 81: [2, 41] }, { 52: [1, 97] }, { 52: [2, 78], 59: [2, 78], 66: [2, 78], 74: [2, 78], 75: [2, 78], 76: [2, 78], 77: [2, 78], 78: [2, 78], 79: [2, 78] }, { 52: [2, 80] }, { 5: [2, 12], 13: [2, 12], 14: [2, 12], 17: [2, 12], 27: [2, 12], 32: [2, 12], 37: [2, 12], 42: [2, 12], 45: [2, 12], 46: [2, 12], 49: [2, 12], 53: [2, 12] }, { 18: 98, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 100, 44: 99, 45: [2, 71] }, { 31: [2, 65], 38: 101, 59: [2, 65], 66: [2, 65], 69: [2, 65], 74: [2, 65], 75: [2, 65], 76: [2, 65], 77: [2, 65], 78: [2, 65], 79: [2, 65] }, { 45: [2, 17] }, { 5: [2, 13], 13: [2, 13], 14: [2, 13], 17: [2, 13], 27: [2, 13], 32: [2, 13], 37: [2, 13], 42: [2, 13], 45: [2, 13], 46: [2, 13], 49: [2, 13], 53: [2, 13] }, { 31: [1, 102] }, { 31: [2, 82], 59: [2, 82], 66: [2, 82], 74: [2, 82], 75: [2, 82], 76: [2, 82], 77: [2, 82], 78: [2, 82], 79: [2, 82] }, { 31: [2, 84] }, { 18: 65, 57: 104, 58: 66, 59: [1, 40], 61: 103, 62: [2, 87], 63: 105, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 30: 106, 31: [2, 57], 68: 107, 69: [1, 108] }, { 31: [2, 54], 59: [2, 54], 66: [2, 54], 69: [2, 54], 74: [2, 54], 75: [2, 54], 76: [2, 54], 77: [2, 54], 78: [2, 54], 79: [2, 54] }, { 31: [2, 56], 69: [2, 56] }, { 31: [2, 63], 35: 109, 68: 110, 69: [1, 108] }, { 31: [2, 60], 59: [2, 60], 66: [2, 60], 69: [2, 60], 74: [2, 60], 75: [2, 60], 76: [2, 60], 77: [2, 60], 78: [2, 60], 79: [2, 60] }, { 31: [2, 62], 69: [2, 62] }, { 21: [1, 111] }, { 21: [2, 46], 59: [2, 46], 66: [2, 46], 74: [2, 46], 75: [2, 46], 76: [2, 46], 77: [2, 46], 78: [2, 46], 79: [2, 46] }, { 21: [2, 48] }, { 5: [2, 21], 13: [2, 21], 14: [2, 21], 17: [2, 21], 27: [2, 21], 32: [2, 21], 37: [2, 21], 42: [2, 21], 45: [2, 21], 46: [2, 21], 49: [2, 21], 53: [2, 21] }, { 21: [2, 90], 31: [2, 90], 52: [2, 90], 62: [2, 90], 66: [2, 90], 69: [2, 90] }, { 67: [1, 96] }, { 18: 65, 57: 112, 58: 66, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 22], 13: [2, 22], 14: [2, 22], 17: [2, 22], 27: [2, 22], 32: [2, 22], 37: [2, 22], 42: [2, 22], 45: [2, 22], 46: [2, 22], 49: [2, 22], 53: [2, 22] }, { 31: [1, 113] }, { 45: [2, 18] }, { 45: [2, 72] }, { 18: 65, 31: [2, 67], 39: 114, 57: 115, 58: 66, 59: [1, 40], 63: 116, 64: 67, 65: 68, 66: [1, 69], 69: [2, 67], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 23], 13: [2, 23], 14: [2, 23], 17: [2, 23], 27: [2, 23], 32: [2, 23], 37: [2, 23], 42: [2, 23], 45: [2, 23], 46: [2, 23], 49: [2, 23], 53: [2, 23] }, { 62: [1, 117] }, { 59: [2, 86], 62: [2, 86], 66: [2, 86], 74: [2, 86], 75: [2, 86], 76: [2, 86], 77: [2, 86], 78: [2, 86], 79: [2, 86] }, { 62: [2, 88] }, { 31: [1, 118] }, { 31: [2, 58] }, { 66: [1, 120], 70: 119 }, { 31: [1, 121] }, { 31: [2, 64] }, { 14: [2, 11] }, { 21: [2, 28], 31: [2, 28], 52: [2, 28], 62: [2, 28], 66: [2, 28], 69: [2, 28] }, { 5: [2, 20], 13: [2, 20], 14: [2, 20], 17: [2, 20], 27: [2, 20], 32: [2, 20], 37: [2, 20], 42: [2, 20], 45: [2, 20], 46: [2, 20], 49: [2, 20], 53: [2, 20] }, { 31: [2, 69], 40: 122, 68: 123, 69: [1, 108] }, { 31: [2, 66], 59: [2, 66], 66: [2, 66], 69: [2, 66], 74: [2, 66], 75: [2, 66], 76: [2, 66], 77: [2, 66], 78: [2, 66], 79: [2, 66] }, { 31: [2, 68], 69: [2, 68] }, { 21: [2, 26], 31: [2, 26], 52: [2, 26], 59: [2, 26], 62: [2, 26], 66: [2, 26], 69: [2, 26], 74: [2, 26], 75: [2, 26], 76: [2, 26], 77: [2, 26], 78: [2, 26], 79: [2, 26] }, { 13: [2, 14], 14: [2, 14], 17: [2, 14], 27: [2, 14], 32: [2, 14], 37: [2, 14], 42: [2, 14], 45: [2, 14], 46: [2, 14], 49: [2, 14], 53: [2, 14] }, { 66: [1, 125], 71: [1, 124] }, { 66: [2, 91], 71: [2, 91] }, { 13: [2, 15], 14: [2, 15], 17: [2, 15], 27: [2, 15], 32: [2, 15], 42: [2, 15], 45: [2, 15], 46: [2, 15], 49: [2, 15], 53: [2, 15] }, { 31: [1, 126] }, { 31: [2, 70] }, { 31: [2, 29] }, { 66: [2, 92], 71: [2, 92] }, { 13: [2, 16], 14: [2, 16], 17: [2, 16], 27: [2, 16], 32: [2, 16], 37: [2, 16], 42: [2, 16], 45: [2, 16], 46: [2, 16], 49: [2, 16], 53: [2, 16] }],
		        defaultActions: { 4: [2, 1], 49: [2, 50], 51: [2, 19], 55: [2, 52], 64: [2, 76], 73: [2, 80], 78: [2, 17], 82: [2, 84], 92: [2, 48], 99: [2, 18], 100: [2, 72], 105: [2, 88], 107: [2, 58], 110: [2, 64], 111: [2, 11], 123: [2, 70], 124: [2, 29] },
		        parseError: function parseError(str, hash) {
		            throw new Error(str);
		        },
		        parse: function parse(input) {
		            var self = this,
		                stack = [0],
		                vstack = [null],
		                lstack = [],
		                table = this.table,
		                yytext = "",
		                yylineno = 0,
		                yyleng = 0,
		                recovering = 0,
		                TERROR = 2,
		                EOF = 1;
		            this.lexer.setInput(input);
		            this.lexer.yy = this.yy;
		            this.yy.lexer = this.lexer;
		            this.yy.parser = this;
		            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
		            var yyloc = this.lexer.yylloc;
		            lstack.push(yyloc);
		            var ranges = this.lexer.options && this.lexer.options.ranges;
		            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
		            function popStack(n) {
		                stack.length = stack.length - 2 * n;
		                vstack.length = vstack.length - n;
		                lstack.length = lstack.length - n;
		            }
		            function lex() {
		                var token;
		                token = self.lexer.lex() || 1;
		                if (typeof token !== "number") {
		                    token = self.symbols_[token] || token;
		                }
		                return token;
		            }
		            var symbol,
		                preErrorSymbol,
		                state,
		                action,
		                a,
		                r,
		                yyval = {},
		                p,
		                len,
		                newState,
		                expected;
		            while (true) {
		                state = stack[stack.length - 1];
		                if (this.defaultActions[state]) {
		                    action = this.defaultActions[state];
		                } else {
		                    if (symbol === null || typeof symbol == "undefined") {
		                        symbol = lex();
		                    }
		                    action = table[state] && table[state][symbol];
		                }
		                if (typeof action === "undefined" || !action.length || !action[0]) {
		                    var errStr = "";
		                    if (!recovering) {
		                        expected = [];
		                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
		                            expected.push("'" + this.terminals_[p] + "'");
		                        }
		                        if (this.lexer.showPosition) {
		                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
		                        } else {
		                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
		                        }
		                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
		                    }
		                }
		                if (action[0] instanceof Array && action.length > 1) {
		                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
		                }
		                switch (action[0]) {
		                    case 1:
		                        stack.push(symbol);
		                        vstack.push(this.lexer.yytext);
		                        lstack.push(this.lexer.yylloc);
		                        stack.push(action[1]);
		                        symbol = null;
		                        if (!preErrorSymbol) {
		                            yyleng = this.lexer.yyleng;
		                            yytext = this.lexer.yytext;
		                            yylineno = this.lexer.yylineno;
		                            yyloc = this.lexer.yylloc;
		                            if (recovering > 0) recovering--;
		                        } else {
		                            symbol = preErrorSymbol;
		                            preErrorSymbol = null;
		                        }
		                        break;
		                    case 2:
		                        len = this.productions_[action[1]][1];
		                        yyval.$ = vstack[vstack.length - len];
		                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
		                        if (ranges) {
		                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
		                        }
		                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
		                        if (typeof r !== "undefined") {
		                            return r;
		                        }
		                        if (len) {
		                            stack = stack.slice(0, -1 * len * 2);
		                            vstack = vstack.slice(0, -1 * len);
		                            lstack = lstack.slice(0, -1 * len);
		                        }
		                        stack.push(this.productions_[action[1]][0]);
		                        vstack.push(yyval.$);
		                        lstack.push(yyval._$);
		                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
		                        stack.push(newState);
		                        break;
		                    case 3:
		                        return true;
		                }
		            }
		            return true;
		        }
		    };
		    /* Jison generated lexer */
		    var lexer = (function () {
		        var lexer = { EOF: 1,
		            parseError: function parseError(str, hash) {
		                if (this.yy.parser) {
		                    this.yy.parser.parseError(str, hash);
		                } else {
		                    throw new Error(str);
		                }
		            },
		            setInput: function setInput(input) {
		                this._input = input;
		                this._more = this._less = this.done = false;
		                this.yylineno = this.yyleng = 0;
		                this.yytext = this.matched = this.match = "";
		                this.conditionStack = ["INITIAL"];
		                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
		                if (this.options.ranges) this.yylloc.range = [0, 0];
		                this.offset = 0;
		                return this;
		            },
		            input: function input() {
		                var ch = this._input[0];
		                this.yytext += ch;
		                this.yyleng++;
		                this.offset++;
		                this.match += ch;
		                this.matched += ch;
		                var lines = ch.match(/(?:\r\n?|\n).*/g);
		                if (lines) {
		                    this.yylineno++;
		                    this.yylloc.last_line++;
		                } else {
		                    this.yylloc.last_column++;
		                }
		                if (this.options.ranges) this.yylloc.range[1]++;
	
		                this._input = this._input.slice(1);
		                return ch;
		            },
		            unput: function unput(ch) {
		                var len = ch.length;
		                var lines = ch.split(/(?:\r\n?|\n)/g);
	
		                this._input = ch + this._input;
		                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
		                //this.yyleng -= len;
		                this.offset -= len;
		                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
		                this.match = this.match.substr(0, this.match.length - 1);
		                this.matched = this.matched.substr(0, this.matched.length - 1);
	
		                if (lines.length - 1) this.yylineno -= lines.length - 1;
		                var r = this.yylloc.range;
	
		                this.yylloc = { first_line: this.yylloc.first_line,
		                    last_line: this.yylineno + 1,
		                    first_column: this.yylloc.first_column,
		                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
		                };
	
		                if (this.options.ranges) {
		                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
		                }
		                return this;
		            },
		            more: function more() {
		                this._more = true;
		                return this;
		            },
		            less: function less(n) {
		                this.unput(this.match.slice(n));
		            },
		            pastInput: function pastInput() {
		                var past = this.matched.substr(0, this.matched.length - this.match.length);
		                return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
		            },
		            upcomingInput: function upcomingInput() {
		                var next = this.match;
		                if (next.length < 20) {
		                    next += this._input.substr(0, 20 - next.length);
		                }
		                return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
		            },
		            showPosition: function showPosition() {
		                var pre = this.pastInput();
		                var c = new Array(pre.length + 1).join("-");
		                return pre + this.upcomingInput() + "\n" + c + "^";
		            },
		            next: function next() {
		                if (this.done) {
		                    return this.EOF;
		                }
		                if (!this._input) this.done = true;
	
		                var token, match, tempMatch, index, col, lines;
		                if (!this._more) {
		                    this.yytext = "";
		                    this.match = "";
		                }
		                var rules = this._currentRules();
		                for (var i = 0; i < rules.length; i++) {
		                    tempMatch = this._input.match(this.rules[rules[i]]);
		                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
		                        match = tempMatch;
		                        index = i;
		                        if (!this.options.flex) break;
		                    }
		                }
		                if (match) {
		                    lines = match[0].match(/(?:\r\n?|\n).*/g);
		                    if (lines) this.yylineno += lines.length;
		                    this.yylloc = { first_line: this.yylloc.last_line,
		                        last_line: this.yylineno + 1,
		                        first_column: this.yylloc.last_column,
		                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
		                    this.yytext += match[0];
		                    this.match += match[0];
		                    this.matches = match;
		                    this.yyleng = this.yytext.length;
		                    if (this.options.ranges) {
		                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
		                    }
		                    this._more = false;
		                    this._input = this._input.slice(match[0].length);
		                    this.matched += match[0];
		                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
		                    if (this.done && this._input) this.done = false;
		                    if (token) {
		                        return token;
		                    } else {
		                        return;
		                    }
		                }
		                if (this._input === "") {
		                    return this.EOF;
		                } else {
		                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
		                }
		            },
		            lex: function lex() {
		                var r = this.next();
		                if (typeof r !== "undefined") {
		                    return r;
		                } else {
		                    return this.lex();
		                }
		            },
		            begin: function begin(condition) {
		                this.conditionStack.push(condition);
		            },
		            popState: function popState() {
		                return this.conditionStack.pop();
		            },
		            _currentRules: function _currentRules() {
		                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
		            },
		            topState: function topState() {
		                return this.conditionStack[this.conditionStack.length - 2];
		            },
		            pushState: function begin(condition) {
		                this.begin(condition);
		            } };
		        lexer.options = {};
		        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
	
		            function strip(start, end) {
		                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
		            }
	
		            var YYSTATE = YY_START;
		            switch ($avoiding_name_collisions) {
		                case 0:
		                    if (yy_.yytext.slice(-2) === "\\\\") {
		                        strip(0, 1);
		                        this.begin("mu");
		                    } else if (yy_.yytext.slice(-1) === "\\") {
		                        strip(0, 1);
		                        this.begin("emu");
		                    } else {
		                        this.begin("mu");
		                    }
		                    if (yy_.yytext) {
		                        return 14;
		                    }break;
		                case 1:
		                    return 14;
		                    break;
		                case 2:
		                    this.popState();
		                    return 14;
	
		                    break;
		                case 3:
		                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
		                    this.popState();
		                    return 16;
	
		                    break;
		                case 4:
		                    return 14;
		                    break;
		                case 5:
		                    this.popState();
		                    return 13;
	
		                    break;
		                case 6:
		                    return 59;
		                    break;
		                case 7:
		                    return 62;
		                    break;
		                case 8:
		                    return 17;
		                    break;
		                case 9:
		                    this.popState();
		                    this.begin("raw");
		                    return 21;
	
		                    break;
		                case 10:
		                    return 53;
		                    break;
		                case 11:
		                    return 27;
		                    break;
		                case 12:
		                    return 45;
		                    break;
		                case 13:
		                    this.popState();return 42;
		                    break;
		                case 14:
		                    this.popState();return 42;
		                    break;
		                case 15:
		                    return 32;
		                    break;
		                case 16:
		                    return 37;
		                    break;
		                case 17:
		                    return 49;
		                    break;
		                case 18:
		                    return 46;
		                    break;
		                case 19:
		                    this.unput(yy_.yytext);
		                    this.popState();
		                    this.begin("com");
	
		                    break;
		                case 20:
		                    this.popState();
		                    return 13;
	
		                    break;
		                case 21:
		                    return 46;
		                    break;
		                case 22:
		                    return 67;
		                    break;
		                case 23:
		                    return 66;
		                    break;
		                case 24:
		                    return 66;
		                    break;
		                case 25:
		                    return 81;
		                    break;
		                case 26:
		                    // ignore whitespace
		                    break;
		                case 27:
		                    this.popState();return 52;
		                    break;
		                case 28:
		                    this.popState();return 31;
		                    break;
		                case 29:
		                    yy_.yytext = strip(1, 2).replace(/\\"/g, "\"");return 74;
		                    break;
		                case 30:
		                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 74;
		                    break;
		                case 31:
		                    return 79;
		                    break;
		                case 32:
		                    return 76;
		                    break;
		                case 33:
		                    return 76;
		                    break;
		                case 34:
		                    return 77;
		                    break;
		                case 35:
		                    return 78;
		                    break;
		                case 36:
		                    return 75;
		                    break;
		                case 37:
		                    return 69;
		                    break;
		                case 38:
		                    return 71;
		                    break;
		                case 39:
		                    return 66;
		                    break;
		                case 40:
		                    return 66;
		                    break;
		                case 41:
		                    return "INVALID";
		                    break;
		                case 42:
		                    return 5;
		                    break;
		            }
		        };
		        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{\/)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/];
		        lexer.conditions = { mu: { rules: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [5], inclusive: false }, raw: { rules: [3, 4], inclusive: false }, INITIAL: { rules: [0, 1, 42], inclusive: true } };
		        return lexer;
		    })();
		    parser.lexer = lexer;
		    function Parser() {
		        this.yy = {};
		    }Parser.prototype = parser;parser.Parser = Parser;
		    return new Parser();
		})();exports["default"] = handlebars;
		module.exports = exports["default"];
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
	
		var _Visitor = __webpack_require__(6);
	
		var _Visitor2 = _interopRequireWildcard(_Visitor);
	
		function WhitespaceControl() {}
		WhitespaceControl.prototype = new _Visitor2['default']();
	
		WhitespaceControl.prototype.Program = function (program) {
		  var isRoot = !this.isRootSeen;
		  this.isRootSeen = true;
	
		  var body = program.body;
		  for (var i = 0, l = body.length; i < l; i++) {
		    var current = body[i],
		        strip = this.accept(current);
	
		    if (!strip) {
		      continue;
		    }
	
		    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
		        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
		        openStandalone = strip.openStandalone && _isPrevWhitespace,
		        closeStandalone = strip.closeStandalone && _isNextWhitespace,
		        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
	
		    if (strip.close) {
		      omitRight(body, i, true);
		    }
		    if (strip.open) {
		      omitLeft(body, i, true);
		    }
	
		    if (inlineStandalone) {
		      omitRight(body, i);
	
		      if (omitLeft(body, i)) {
		        // If we are on a standalone node, save the indent info for partials
		        if (current.type === 'PartialStatement') {
		          // Pull out the whitespace from the final line
		          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
		        }
		      }
		    }
		    if (openStandalone) {
		      omitRight((current.program || current.inverse).body);
	
		      // Strip out the previous content node if it's whitespace only
		      omitLeft(body, i);
		    }
		    if (closeStandalone) {
		      // Always strip the next node
		      omitRight(body, i);
	
		      omitLeft((current.inverse || current.program).body);
		    }
		  }
	
		  return program;
		};
		WhitespaceControl.prototype.BlockStatement = function (block) {
		  this.accept(block.program);
		  this.accept(block.inverse);
	
		  // Find the inverse program that is involed with whitespace stripping.
		  var program = block.program || block.inverse,
		      inverse = block.program && block.inverse,
		      firstInverse = inverse,
		      lastInverse = inverse;
	
		  if (inverse && inverse.chained) {
		    firstInverse = inverse.body[0].program;
	
		    // Walk the inverse chain to find the last inverse that is actually in the chain.
		    while (lastInverse.chained) {
		      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
		    }
		  }
	
		  var strip = {
		    open: block.openStrip.open,
		    close: block.closeStrip.close,
	
		    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
		    // so our parent can determine if we actually are standalone
		    openStandalone: isNextWhitespace(program.body),
		    closeStandalone: isPrevWhitespace((firstInverse || program).body)
		  };
	
		  if (block.openStrip.close) {
		    omitRight(program.body, null, true);
		  }
	
		  if (inverse) {
		    var inverseStrip = block.inverseStrip;
	
		    if (inverseStrip.open) {
		      omitLeft(program.body, null, true);
		    }
	
		    if (inverseStrip.close) {
		      omitRight(firstInverse.body, null, true);
		    }
		    if (block.closeStrip.open) {
		      omitLeft(lastInverse.body, null, true);
		    }
	
		    // Find standalone else statments
		    if (isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
		      omitLeft(program.body);
		      omitRight(firstInverse.body);
		    }
		  } else if (block.closeStrip.open) {
		    omitLeft(program.body, null, true);
		  }
	
		  return strip;
		};
	
		WhitespaceControl.prototype.MustacheStatement = function (mustache) {
		  return mustache.strip;
		};
	
		WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
		  /* istanbul ignore next */
		  var strip = node.strip || {};
		  return {
		    inlineStandalone: true,
		    open: strip.open,
		    close: strip.close
		  };
		};
	
		function isPrevWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = body.length;
		  }
	
		  // Nodes that end with newlines are considered whitespace (but are special
		  // cased for strip operations)
		  var prev = body[i - 1],
		      sibling = body[i - 2];
		  if (!prev) {
		    return isRoot;
		  }
	
		  if (prev.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
		  }
		}
		function isNextWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = -1;
		  }
	
		  var next = body[i + 1],
		      sibling = body[i + 2];
		  if (!next) {
		    return isRoot;
		  }
	
		  if (next.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
		  }
		}
	
		// Marks the node to the right of the position as omitted.
		// I.e. {{foo}}' ' will mark the ' ' node as omitted.
		//
		// If i is undefined, then the first child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitRight(body, i, multiple) {
		  var current = body[i == null ? 0 : i + 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
		    return;
		  }
	
		  var original = current.value;
		  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
		  current.rightStripped = current.value !== original;
		}
	
		// Marks the node to the left of the position as omitted.
		// I.e. ' '{{foo}} will mark the ' ' node as omitted.
		//
		// If i is undefined then the last child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitLeft(body, i, multiple) {
		  var current = body[i == null ? body.length - 1 : i - 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
		    return;
		  }
	
		  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
		  var original = current.value;
		  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
		  current.leftStripped = current.value !== original;
		  return current.leftStripped;
		}
	
		exports['default'] = WhitespaceControl;
		module.exports = exports['default'];
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		var _interopRequireWildcard = __webpack_require__(8)['default'];
	
		exports.__esModule = true;
		exports.SourceLocation = SourceLocation;
		exports.id = id;
		exports.stripFlags = stripFlags;
		exports.stripComment = stripComment;
		exports.preparePath = preparePath;
		exports.prepareMustache = prepareMustache;
		exports.prepareRawBlock = prepareRawBlock;
		exports.prepareBlock = prepareBlock;
	
		var _Exception = __webpack_require__(11);
	
		var _Exception2 = _interopRequireWildcard(_Exception);
	
		function SourceLocation(source, locInfo) {
		  this.source = source;
		  this.start = {
		    line: locInfo.first_line,
		    column: locInfo.first_column
		  };
		  this.end = {
		    line: locInfo.last_line,
		    column: locInfo.last_column
		  };
		}
	
		function id(token) {
		  if (/^\[.*\]$/.test(token)) {
		    return token.substr(1, token.length - 2);
		  } else {
		    return token;
		  }
		}
	
		function stripFlags(open, close) {
		  return {
		    open: open.charAt(2) === '~',
		    close: close.charAt(close.length - 3) === '~'
		  };
		}
	
		function stripComment(comment) {
		  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
		}
	
		function preparePath(data, parts, locInfo) {
		  locInfo = this.locInfo(locInfo);
	
		  var original = data ? '@' : '',
		      dig = [],
		      depth = 0,
		      depthString = '';
	
		  for (var i = 0, l = parts.length; i < l; i++) {
		    var part = parts[i].part,
	
		    // If we have [] syntax then we do not treat path references as operators,
		    // i.e. foo.[this] resolves to approximately context.foo['this']
		    isLiteral = parts[i].original !== part;
		    original += (parts[i].separator || '') + part;
	
		    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
		      if (dig.length > 0) {
		        throw new _Exception2['default']('Invalid path: ' + original, { loc: locInfo });
		      } else if (part === '..') {
		        depth++;
		        depthString += '../';
		      }
		    } else {
		      dig.push(part);
		    }
		  }
	
		  return new this.PathExpression(data, depth, dig, original, locInfo);
		}
	
		function prepareMustache(path, params, hash, open, strip, locInfo) {
		  // Must use charAt to support IE pre-10
		  var escapeFlag = open.charAt(3) || open.charAt(2),
		      escaped = escapeFlag !== '{' && escapeFlag !== '&';
	
		  return new this.MustacheStatement(path, params, hash, escaped, strip, this.locInfo(locInfo));
		}
	
		function prepareRawBlock(openRawBlock, content, close, locInfo) {
		  if (openRawBlock.path.original !== close) {
		    var errorNode = { loc: openRawBlock.path.loc };
	
		    throw new _Exception2['default'](openRawBlock.path.original + ' doesn\'t match ' + close, errorNode);
		  }
	
		  locInfo = this.locInfo(locInfo);
		  var program = new this.Program([content], null, {}, locInfo);
	
		  return new this.BlockStatement(openRawBlock.path, openRawBlock.params, openRawBlock.hash, program, undefined, {}, {}, {}, locInfo);
		}
	
		function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
		  // When we are chaining inverse calls, we will not have a close path
		  if (close && close.path && openBlock.path.original !== close.path.original) {
		    var errorNode = { loc: openBlock.path.loc };
	
		    throw new _Exception2['default'](openBlock.path.original + ' doesn\'t match ' + close.path.original, errorNode);
		  }
	
		  program.blockParams = openBlock.blockParams;
	
		  var inverse = undefined,
		      inverseStrip = undefined;
	
		  if (inverseAndProgram) {
		    if (inverseAndProgram.chain) {
		      inverseAndProgram.program.body[0].closeStrip = close.strip;
		    }
	
		    inverseStrip = inverseAndProgram.strip;
		    inverse = inverseAndProgram.program;
		  }
	
		  if (inverted) {
		    inverted = inverse;
		    inverse = program;
		    program = inverted;
		  }
	
		  return new this.BlockStatement(openBlock.path, openBlock.params, openBlock.hash, program, inverse, openBlock.strip, inverseStrip, close && close.strip, this.locInfo(locInfo));
		}
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
	
		exports.__esModule = true;
		/*global define */
	
		var _isArray = __webpack_require__(12);
	
		var SourceNode = undefined;
	
		try {
		  /* istanbul ignore next */
		  if (false) {
		    // We don't support this in AMD environments. For these environments, we asusme that
		    // they are running on the browser and thus have no need for the source-map library.
		    var SourceMap = require('source-map');
		    SourceNode = SourceMap.SourceNode;
		  }
		} catch (err) {}
	
		/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
		if (!SourceNode) {
		  SourceNode = function (line, column, srcFile, chunks) {
		    this.src = '';
		    if (chunks) {
		      this.add(chunks);
		    }
		  };
		  /* istanbul ignore next */
		  SourceNode.prototype = {
		    add: function add(chunks) {
		      if (_isArray.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src += chunks;
		    },
		    prepend: function prepend(chunks) {
		      if (_isArray.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src = chunks + this.src;
		    },
		    toStringWithSourceMap: function toStringWithSourceMap() {
		      return { code: this.toString() };
		    },
		    toString: function toString() {
		      return this.src;
		    }
		  };
		}
	
		function castChunk(chunk, codeGen, loc) {
		  if (_isArray.isArray(chunk)) {
		    var ret = [];
	
		    for (var i = 0, len = chunk.length; i < len; i++) {
		      ret.push(codeGen.wrap(chunk[i], loc));
		    }
		    return ret;
		  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
		    // Handle primitives that the SourceNode will throw up on
		    return chunk + '';
		  }
		  return chunk;
		}
	
		function CodeGen(srcFile) {
		  this.srcFile = srcFile;
		  this.source = [];
		}
	
		CodeGen.prototype = {
		  prepend: function prepend(source, loc) {
		    this.source.unshift(this.wrap(source, loc));
		  },
		  push: function push(source, loc) {
		    this.source.push(this.wrap(source, loc));
		  },
	
		  merge: function merge() {
		    var source = this.empty();
		    this.each(function (line) {
		      source.add(['  ', line, '\n']);
		    });
		    return source;
		  },
	
		  each: function each(iter) {
		    for (var i = 0, len = this.source.length; i < len; i++) {
		      iter(this.source[i]);
		    }
		  },
	
		  empty: function empty() {
		    var loc = arguments[0] === undefined ? this.currentLocation || { start: {} } : arguments[0];
	
		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
		  },
		  wrap: function wrap(chunk) {
		    var loc = arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];
	
		    if (chunk instanceof SourceNode) {
		      return chunk;
		    }
	
		    chunk = castChunk(chunk, this, loc);
	
		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
		  },
	
		  functionCall: function functionCall(fn, type, params) {
		    params = this.generateList(params);
		    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
		  },
	
		  quotedString: function quotedString(str) {
		    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
		    .replace(/\u2029/g, '\\u2029') + '"';
		  },
	
		  objectLiteral: function objectLiteral(obj) {
		    var pairs = [];
	
		    for (var key in obj) {
		      if (obj.hasOwnProperty(key)) {
		        var value = castChunk(obj[key], this);
		        if (value !== 'undefined') {
		          pairs.push([this.quotedString(key), ':', value]);
		        }
		      }
		    }
	
		    var ret = this.generateList(pairs);
		    ret.prepend('{');
		    ret.add('}');
		    return ret;
		  },
	
		  generateList: function generateList(entries, loc) {
		    var ret = this.empty(loc);
	
		    for (var i = 0, len = entries.length; i < len; i++) {
		      if (i) {
		        ret.add(',');
		      }
	
		      ret.add(castChunk(entries[i], this, loc));
		    }
	
		    return ret;
		  },
	
		  generateArray: function generateArray(entries, loc) {
		    var ret = this.generateList(entries, loc);
		    ret.prepend('[');
		    ret.add(']');
	
		    return ret;
		  }
		};
	
		exports['default'] = CodeGen;
		module.exports = exports['default'];
	
		/* NOP */
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {//! moment.js
	//! version : 2.8.4
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	(function (undefined) {
	    /************************************
	        Constants
	    ************************************/
	
	    var moment,
	        VERSION = '2.8.4',
	        // the global-scope this is NOT the global object in Node.js
	        globalScope = typeof global !== 'undefined' ? global : this,
	        oldGlobalMoment,
	        round = Math.round,
	        hasOwnProperty = Object.prototype.hasOwnProperty,
	        i,
	
	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	
	        // internal storage for locale config files
	        locales = {},
	
	        // extra moment internal properties (plugins register props here)
	        momentProperties = [],
	
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module && module.exports),
	
	        // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
	
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
	
	        // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
	
	        // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO separator)
	        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	
	        //strict parsing regexes
	        parseTokenOneDigit = /\d/, // 0 - 9
	        parseTokenTwoDigits = /\d\d/, // 00 - 99
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
	        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
	        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf
	
	        // iso 8601 regex
	        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	
	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
	
	        isoDates = [
	            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	            ['YYYY-DDD', /\d{4}-\d{3}/]
	        ],
	
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],
	
	        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
	
	        // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },
	
	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            Q : 'quarter',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },
	
	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },
	
	        // format function strings
	        formatFunctions = {},
	
	        // default relative time thresholds
	        relativeTimeThresholds = {
	            s: 45,  // seconds to minute
	            m: 45,  // minutes to hour
	            h: 22,  // hours to day
	            d: 26,  // days to month
	            M: 11   // months to year
	        },
	
	        // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),
	
	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.localeData().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.localeData().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.localeData().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.localeData().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.localeData().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            YYYYYY : function () {
	                var y = this.year(), sign = y >= 0 ? '+' : '-';
	                return sign + leftZeroFill(Math.abs(y), 6);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return leftZeroFill(this.weekYear(), 4);
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 4);
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = -this.zone(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = -this.zone(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            x    : function () {
	                return this.valueOf();
	            },
	            X    : function () {
	                return this.unix();
	            },
	            Q : function () {
	                return this.quarter();
	            }
	        },
	
	        deprecations = {},
	
	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
	
	    // Pick the first defined of two or three arguments. dfl comes from
	    // default.
	    function dfl(a, b, c) {
	        switch (arguments.length) {
	            case 2: return a != null ? a : b;
	            case 3: return a != null ? a : b != null ? b : c;
	            default: throw new Error('Implement me');
	        }
	    }
	
	    function hasOwnProp(a, b) {
	        return hasOwnProperty.call(a, b);
	    }
	
	    function defaultParsingFlags() {
	        // We need to deep clone this object, and es5 standard is not very
	        // helpful.
	        return {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }
	
	    function printMsg(msg) {
	        if (moment.suppressDeprecationWarnings === false &&
	                typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }
	
	    function deprecate(msg, fn) {
	        var firstTime = true;
	        return extend(function () {
	            if (firstTime) {
	                printMsg(msg);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }
	
	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            printMsg(msg);
	            deprecations[name] = true;
	        }
	    }
	
	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.localeData().ordinal(func.call(this, a), period);
	        };
	    }
	
	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
	
	
	    /************************************
	        Constructors
	    ************************************/
	
	    function Locale() {
	    }
	
	    // Moment prototype object
	    function Moment(config, skipOverflow) {
	        if (skipOverflow !== false) {
	            checkOverflow(config);
	        }
	        copyConfig(this, config);
	        this._d = new Date(+config._d);
	    }
	
	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;
	
	        this._data = {};
	
	        this._locale = moment.localeData();
	
	        this._bubble();
	    }
	
	    /************************************
	        Helpers
	    ************************************/
	
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }
	
	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function copyConfig(to, from) {
	        var i, prop, val;
	
	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = from._pf;
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }
	
	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }
	
	        return to;
	    }
	
	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength, forceSign) {
	        var output = '' + Math.abs(number),
	            sign = number >= 0;
	
	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return (sign ? (forceSign ? '+' : '') : '-') + output;
	    }
	
	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};
	
	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }
	
	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	        return res;
	    }
	
	    function momentsDifference(base, other) {
	        var res;
	        other = makeAs(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }
	
	        return res;
	    }
	
	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }
	
	            val = typeof val === 'string' ? +val : val;
	            dur = moment.duration(val, period);
	            addOrSubtractDurationFromMoment(this, dur, direction);
	            return this;
	        };
	    }
	
	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            moment.updateOffset(mom, days || months);
	        }
	    }
	
	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return Object.prototype.toString.call(input) === '[object Date]' ||
	            input instanceof Date;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeList(field) {
	        var count, setter;
	
	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }
	
	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment._locale[field],
	                results = [];
	
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment._locale, m, format || '');
	            };
	
	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }
	
	        return value;
	    }
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
	    }
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
	                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
	                                           m._a[SECOND] !== 0 ||
	                                           m._a[MILLISECOND] !== 0)) ? HOUR :
	                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	
	            m._pf.overflow = overflow;
	        }
	    }
	
	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	                m._pf.overflow < 0 &&
	                !m._pf.empty &&
	                !m._pf.invalidMonth &&
	                !m._pf.nullInput &&
	                !m._pf.invalidFormat &&
	                !m._pf.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    m._pf.charsLeftOver === 0 &&
	                    m._pf.unusedTokens.length === 0 &&
	                    m._pf.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }
	
	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;
	
	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }
	
	    function loadLocale(name) {
	        var oldLocale = null;
	        if (!locales[name] && hasModule) {
	            try {
	                oldLocale = moment.locale();
	                __webpack_require__(9)("./" + name);
	                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
	                moment.locale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function makeAs(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (moment.isMoment(input) || isDate(input) ?
	                    +input : +moment(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            moment.updateOffset(res, false);
	            return res;
	        } else {
	            return moment(input).local();
	        }
	    }
	
	    /************************************
	        Locale
	    ************************************/
	
	
	    extend(Locale.prototype, {
	
	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	            // Lenient ordinal parsing accepts just a number in addition to
	            // number + (possibly) stuff coming from _ordinalParseLenient.
	            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
	        },
	
	        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        months : function (m) {
	            return this._months[m.month()];
	        },
	
	        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },
	
	        monthsParse : function (monthName, format, strict) {
	            var i, mom, regex;
	
	            if (!this._monthsParse) {
	                this._monthsParse = [];
	                this._longMonthsParse = [];
	                this._shortMonthsParse = [];
	            }
	
	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                mom = moment.utc([2000, i]);
	                if (strict && !this._longMonthsParse[i]) {
	                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	                }
	                if (!strict && !this._monthsParse[i]) {
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (!strict && this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },
	
	        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },
	
	        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },
	
	        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },
	
	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;
	
	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }
	
	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },
	
	        _longDateFormat : {
	            LTS : 'h:mm:ss A',
	            LT : 'h:mm A',
	            L : 'MM/DD/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY LT',
	            LLLL : 'dddd, MMMM D, YYYY LT'
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },
	
	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },
	
	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },
	
	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom, now) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom, [now]) : output;
	        },
	
	        _relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	
	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },
	
	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },
	
	        ordinal : function (number) {
	            return this._ordinal.replace('%d', number);
	        },
	        _ordinal : '%d',
	        _ordinalParse : /\d{1,2}/,
	
	        preparse : function (string) {
	            return string;
	        },
	
	        postformat : function (string) {
	            return string;
	        },
	
	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },
	
	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },
	
	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });
	
	    /************************************
	        Formatting
	    ************************************/
	
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }
	
	        format = expandFormat(format, m.localeData());
	
	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, locale) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	
	    /************************************
	        Parsing
	    ************************************/
	
	
	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a, strict = config._strict;
	        switch (token) {
	        case 'Q':
	            return parseTokenOneDigit;
	        case 'DDDD':
	            return parseTokenThreeDigits;
	        case 'YYYY':
	        case 'GGGG':
	        case 'gggg':
	            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
	        case 'Y':
	        case 'G':
	        case 'g':
	            return parseTokenSignedNumber;
	        case 'YYYYYY':
	        case 'YYYYY':
	        case 'GGGGG':
	        case 'ggggg':
	            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
	        case 'S':
	            if (strict) {
	                return parseTokenOneDigit;
	            }
	            /* falls through */
	        case 'SS':
	            if (strict) {
	                return parseTokenTwoDigits;
	            }
	            /* falls through */
	        case 'SSS':
	            if (strict) {
	                return parseTokenThreeDigits;
	            }
	            /* falls through */
	        case 'DDD':
	            return parseTokenOneToThreeDigits;
	        case 'MMM':
	        case 'MMMM':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            return parseTokenWord;
	        case 'a':
	        case 'A':
	            return config._locale._meridiemParse;
	        case 'x':
	            return parseTokenOffsetMs;
	        case 'X':
	            return parseTokenTimestampMs;
	        case 'Z':
	        case 'ZZ':
	            return parseTokenTimezone;
	        case 'T':
	            return parseTokenT;
	        case 'SSSS':
	            return parseTokenDigits;
	        case 'MM':
	        case 'DD':
	        case 'YY':
	        case 'GG':
	        case 'gg':
	        case 'HH':
	        case 'hh':
	        case 'mm':
	        case 'ss':
	        case 'ww':
	        case 'WW':
	            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
	        case 'M':
	        case 'D':
	        case 'd':
	        case 'H':
	        case 'h':
	        case 'm':
	        case 's':
	        case 'w':
	        case 'W':
	        case 'e':
	        case 'E':
	            return parseTokenOneOrTwoDigits;
	        case 'Do':
	            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
	        default :
	            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
	            return a;
	        }
	    }
	
	    function timezoneMinutesFromString(string) {
	        string = string || '';
	        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
	            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
	            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? -minutes : minutes;
	    }
	
	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;
	
	        switch (token) {
	        // QUARTER
	        case 'Q':
	            if (input != null) {
	                datePartArray[MONTH] = (toInt(input) - 1) * 3;
	            }
	            break;
	        // MONTH
	        case 'M' : // fall through to MM
	        case 'MM' :
	            if (input != null) {
	                datePartArray[MONTH] = toInt(input) - 1;
	            }
	            break;
	        case 'MMM' : // fall through to MMMM
	        case 'MMMM' :
	            a = config._locale.monthsParse(input, token, config._strict);
	            // if we didn't find a month name, mark the date as invalid.
	            if (a != null) {
	                datePartArray[MONTH] = a;
	            } else {
	                config._pf.invalidMonth = input;
	            }
	            break;
	        // DAY OF MONTH
	        case 'D' : // fall through to DD
	        case 'DD' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(input);
	            }
	            break;
	        case 'Do' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(parseInt(
	                            input.match(/\d{1,2}/)[0], 10));
	            }
	            break;
	        // DAY OF YEAR
	        case 'DDD' : // fall through to DDDD
	        case 'DDDD' :
	            if (input != null) {
	                config._dayOfYear = toInt(input);
	            }
	
	            break;
	        // YEAR
	        case 'YY' :
	            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
	            break;
	        case 'YYYY' :
	        case 'YYYYY' :
	        case 'YYYYYY' :
	            datePartArray[YEAR] = toInt(input);
	            break;
	        // AM / PM
	        case 'a' : // fall through to A
	        case 'A' :
	            config._isPm = config._locale.isPM(input);
	            break;
	        // HOUR
	        case 'h' : // fall through to hh
	        case 'hh' :
	            config._pf.bigHour = true;
	            /* falls through */
	        case 'H' : // fall through to HH
	        case 'HH' :
	            datePartArray[HOUR] = toInt(input);
	            break;
	        // MINUTE
	        case 'm' : // fall through to mm
	        case 'mm' :
	            datePartArray[MINUTE] = toInt(input);
	            break;
	        // SECOND
	        case 's' : // fall through to ss
	        case 'ss' :
	            datePartArray[SECOND] = toInt(input);
	            break;
	        // MILLISECOND
	        case 'S' :
	        case 'SS' :
	        case 'SSS' :
	        case 'SSSS' :
	            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	            break;
	        // UNIX OFFSET (MILLISECONDS)
	        case 'x':
	            config._d = new Date(toInt(input));
	            break;
	        // UNIX TIMESTAMP WITH MS
	        case 'X':
	            config._d = new Date(parseFloat(input) * 1000);
	            break;
	        // TIMEZONE
	        case 'Z' : // fall through to ZZ
	        case 'ZZ' :
	            config._useUTC = true;
	            config._tzm = timezoneMinutesFromString(input);
	            break;
	        // WEEKDAY - human
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            a = config._locale.weekdaysParse(input);
	            // if we didn't get a weekday name, mark the date as invalid
	            if (a != null) {
	                config._w = config._w || {};
	                config._w['d'] = a;
	            } else {
	                config._pf.invalidWeekday = input;
	            }
	            break;
	        // WEEK, WEEK DAY - numeric
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'd':
	        case 'e':
	        case 'E':
	            token = token.substr(0, 1);
	            /* falls through */
	        case 'gggg':
	        case 'GGGG':
	        case 'GGGGG':
	            token = token.substr(0, 2);
	            if (input) {
	                config._w = config._w || {};
	                config._w[token] = toInt(input);
	            }
	            break;
	        case 'gg':
	        case 'GG':
	            config._w = config._w || {};
	            config._w[token] = moment.parseTwoDigitYear(input);
	        }
	    }
	
	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;
	
	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;
	
	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
	            week = dfl(w.W, 1);
	            weekday = dfl(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;
	
	            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
	            week = dfl(w.w, 1);
	
	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
	
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate, yearToUse;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }
	
	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }
	
	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	        // Apply timezone offset from input. The actual zone can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
	        }
	
	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }
	
	    function dateFromObject(config) {
	        var normalizedInput;
	
	        if (config._d) {
	            return;
	        }
	
	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day || normalizedInput.date,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];
	
	        dateFromConfig(config);
	    }
	
	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }
	
	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	        if (config._f === moment.ISO_8601) {
	            parseISO(config);
	            return;
	        }
	
	        config._a = [];
	        config._pf.empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }
	
	        // clear _12h flag if hour is <= 12
	        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
	            config._pf.bigHour = undefined;
	        }
	        // handle am pm
	        if (config._isPm && config._a[HOUR] < 12) {
	            config._a[HOUR] += 12;
	        }
	        // if is 12 am, change hours to 0
	        if (config._isPm === false && config._a[HOUR] === 12) {
	            config._a[HOUR] = 0;
	        }
	        dateFromConfig(config);
	        checkOverflow(config);
	    }
	
	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._pf = defaultParsingFlags();
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);
	
	            if (!isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;
	
	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;
	
	            tempConfig._pf.score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    // date from iso format
	    function parseISO(config) {
	        var i, l,
	            string = config._i,
	            match = isoRegex.exec(string);
	
	        if (match) {
	            config._pf.iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    // match[5] should be 'T' or undefined
	                    config._f = isoDates[i][0] + (match[6] || ' ');
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(parseTokenTimezone)) {
	                config._f += 'Z';
	            }
	            makeDateFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }
	
	    // date from iso format or fallback
	    function makeDateFromString(config) {
	        parseISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            moment.createFromInputFallback(config);
	        }
	    }
	
	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }
	
	    function makeDateFromInput(config) {
	        var input = config._i, matched;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            dateFromConfig(config);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            moment.createFromInputFallback(config);
	        }
	    }
	
	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    function parseWeekday(input, locale) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = locale.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }
	
	    /************************************
	        Relative Time
	    ************************************/
	
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function relativeTime(posNegDuration, withoutSuffix, locale) {
	        var duration = moment.duration(posNegDuration).abs(),
	            seconds = round(duration.as('s')),
	            minutes = round(duration.as('m')),
	            hours = round(duration.as('h')),
	            days = round(duration.as('d')),
	            months = round(duration.as('M')),
	            years = round(duration.as('y')),
	
	            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < relativeTimeThresholds.h && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days < relativeTimeThresholds.d && ['dd', days] ||
	                months === 1 && ['M'] ||
	                months < relativeTimeThresholds.M && ['MM', months] ||
	                years === 1 && ['y'] || ['yy', years];
	
	        args[2] = withoutSuffix;
	        args[3] = +posNegDuration > 0;
	        args[4] = locale;
	        return substituteTimeAgo.apply({}, args);
	    }
	
	
	    /************************************
	        Week of Year
	    ************************************/
	
	
	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;
	
	
	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }
	
	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }
	
	        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
	
	        d = d === 0 ? 7 : d;
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
	
	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }
	
	    /************************************
	        Top Level Functions
	    ************************************/
	
	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f,
	            res;
	
	        config._locale = config._locale || moment.localeData(config._l);
	
	        if (input === null || (format === undefined && input === '')) {
	            return moment.invalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }
	
	        if (moment.isMoment(input)) {
	            return new Moment(input, true);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }
	
	        res = new Moment(config);
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }
	
	        return res;
	    }
	
	    moment = function (input, format, locale, strict) {
	        var c;
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._i = input;
	        c._f = format;
	        c._l = locale;
	        c._strict = strict;
	        c._isUTC = false;
	        c._pf = defaultParsingFlags();
	
	        return makeMoment(c);
	    };
	
	    moment.suppressDeprecationWarnings = false;
	
	    moment.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );
	
	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return moment();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }
	
	    moment.min = function () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isBefore', args);
	    };
	
	    moment.max = function () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isAfter', args);
	    };
	
	    // creating with utc
	    moment.utc = function (input, format, locale, strict) {
	        var c;
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._useUTC = true;
	        c._isUTC = true;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	        c._pf = defaultParsingFlags();
	
	        return makeMoment(c).utc();
	    };
	
	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };
	
	    // duration
	    moment.duration = function (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso,
	            diffRes;
	
	        if (moment.isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        } else if (typeof duration === 'object' &&
	                ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
	
	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }
	
	        ret = new Duration(duration);
	
	        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }
	
	        return ret;
	    };
	
	    // version number
	    moment.version = VERSION;
	
	    // default format
	    moment.defaultFormat = isoFormat;
	
	    // constant that refers to the ISO standard
	    moment.ISO_8601 = function () {};
	
	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    moment.momentProperties = momentProperties;
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};
	
	    // This function allows you to set a threshold for relative time strings
	    moment.relativeTimeThreshold = function (threshold, limit) {
	        if (relativeTimeThresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return relativeTimeThresholds[threshold];
	        }
	        relativeTimeThresholds[threshold] = limit;
	        return true;
	    };
	
	    moment.lang = deprecate(
	        'moment.lang is deprecated. Use moment.locale instead.',
	        function (key, value) {
	            return moment.locale(key, value);
	        }
	    );
	
	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    moment.locale = function (key, values) {
	        var data;
	        if (key) {
	            if (typeof(values) !== 'undefined') {
	                data = moment.defineLocale(key, values);
	            }
	            else {
	                data = moment.localeData(key);
	            }
	
	            if (data) {
	                moment.duration._locale = moment._locale = data;
	            }
	        }
	
	        return moment._locale._abbr;
	    };
	
	    moment.defineLocale = function (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            if (!locales[name]) {
	                locales[name] = new Locale();
	            }
	            locales[name].set(values);
	
	            // backwards compat for now: also set the locale
	            moment.locale(name);
	
	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    };
	
	    moment.langData = deprecate(
	        'moment.langData is deprecated. Use moment.localeData instead.',
	        function (key) {
	            return moment.localeData(key);
	        }
	    );
	
	    // returns locale data
	    moment.localeData = function (key) {
	        var locale;
	
	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }
	
	        if (!key) {
	            return moment._locale;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }
	
	        return chooseLocale(key);
	    };
	
	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment ||
	            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
	    };
	
	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };
	
	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }
	
	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };
	
	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }
	
	        return m;
	    };
	
	    moment.parseZone = function () {
	        return moment.apply(null, arguments).parseZone();
	    };
	
	    moment.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };
	
	    /************************************
	        Moment Prototype
	    ************************************/
	
	
	    extend(moment.fn = Moment.prototype, {
	
	        clone : function () {
	            return moment(this);
	        },
	
	        valueOf : function () {
	            return +this._d + ((this._offset || 0) * 60000);
	        },
	
	        unix : function () {
	            return Math.floor(+this / 1000);
	        },
	
	        toString : function () {
	            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	        },
	
	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },
	
	        toISOString : function () {
	            var m = moment(this).utc();
	            if (0 < m.year() && m.year() <= 9999) {
	                if ('function' === typeof Date.prototype.toISOString) {
	                    // native implementation is ~50x faster, use it when we can
	                    return this.toDate().toISOString();
	                } else {
	                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	                }
	            } else {
	                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        },
	
	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },
	
	        isValid : function () {
	            return isValid(this);
	        },
	
	        isDSTShifted : function () {
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }
	
	            return false;
	        },
	
	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },
	
	        invalidAt: function () {
	            return this._pf.overflow;
	        },
	
	        utc : function (keepLocalTime) {
	            return this.zone(0, keepLocalTime);
	        },
	
	        local : function (keepLocalTime) {
	            if (this._isUTC) {
	                this.zone(0, keepLocalTime);
	                this._isUTC = false;
	
	                if (keepLocalTime) {
	                    this.add(this._dateTzOffset(), 'm');
	                }
	            }
	            return this;
	        },
	
	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.localeData().postformat(output);
	        },
	
	        add : createAdder(1, 'add'),
	
	        subtract : createAdder(-1, 'subtract'),
	
	        diff : function (input, units, asFloat) {
	            var that = makeAs(input, this),
	                zoneDiff = (this.zone() - that.zone()) * 6e4,
	                diff, output, daysAdjust;
	
	            units = normalizeUnits(units);
	
	            if (units === 'year' || units === 'month') {
	                // average number of days in the months in the given dates
	                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
	                // difference in months
	                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
	                // adjust by taking difference in days, average number of days
	                // and dst in the given months.
	                daysAdjust = (this - moment(this).startOf('month')) -
	                    (that - moment(that).startOf('month'));
	                // same as above but with zones, to negate all dst
	                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
	                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;
	                output += daysAdjust / diff;
	                if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = (this - that);
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },
	
	        from : function (time, withoutSuffix) {
	            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        },
	
	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },
	
	        calendar : function (time) {
	            // We want to compare the start of today, vs this.
	            // Getting start-of-today depends on whether we're zone'd or not.
	            var now = time || moment(),
	                sod = makeAs(now, this).startOf('day'),
	                diff = this.diff(sod, 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                    diff < -1 ? 'lastWeek' :
	                    diff < 0 ? 'lastDay' :
	                    diff < 1 ? 'sameDay' :
	                    diff < 2 ? 'nextDay' :
	                    diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.localeData().calendar(format, this, moment(now)));
	        },
	
	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },
	
	        isDST : function () {
	            return (this.zone() < this.clone().month(0).zone() ||
	                this.zone() < this.clone().month(5).zone());
	        },
	
	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.localeData());
	                return this.add(input - day, 'd');
	            } else {
	                return day;
	            }
	        },
	
	        month : makeAccessor('Month', true),
	
	        startOf : function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'quarter':
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	                /* falls through */
	            }
	
	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }
	
	            // quarters are also special
	            if (units === 'quarter') {
	                this.month(Math.floor(this.month() / 3) * 3);
	            }
	
	            return this;
	        },
	
	        endOf: function (units) {
	            units = normalizeUnits(units);
	            if (units === undefined || units === 'millisecond') {
	                return this;
	            }
	            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	        },
	
	        isAfter: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this > +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return inputMs < +this.clone().startOf(units);
	            }
	        },
	
	        isBefore: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this < +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return +this.clone().endOf(units) < inputMs;
	            }
	        },
	
	        isSame: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(units || 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this === +input;
	            } else {
	                inputMs = +moment(input);
	                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	            }
	        },
	
	        min: deprecate(
	                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	                 function (other) {
	                     other = moment.apply(null, arguments);
	                     return other < this ? this : other;
	                 }
	         ),
	
	        max: deprecate(
	                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	                function (other) {
	                    other = moment.apply(null, arguments);
	                    return other > this ? this : other;
	                }
	        ),
	
	        // keepLocalTime = true means only change the timezone, without
	        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
	        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
	        // +0200, so we adjust the time as needed, to be valid.
	        //
	        // Keeping the time actually adds/subtracts (one hour)
	        // from the actual represented time. That is why we call updateOffset
	        // a second time. In case it wants us to change the offset again
	        // _changeInProgress == true case, then we have to adjust, because
	        // there is no such time in the given timezone.
	        zone : function (input, keepLocalTime) {
	            var offset = this._offset || 0,
	                localAdjust;
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = timezoneMinutesFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                if (!this._isUTC && keepLocalTime) {
	                    localAdjust = this._dateTzOffset();
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (localAdjust != null) {
	                    this.subtract(localAdjust, 'm');
	                }
	                if (offset !== input) {
	                    if (!keepLocalTime || this._changeInProgress) {
	                        addOrSubtractDurationFromMoment(this,
	                                moment.duration(offset - input, 'm'), 1, false);
	                    } else if (!this._changeInProgress) {
	                        this._changeInProgress = true;
	                        moment.updateOffset(this, true);
	                        this._changeInProgress = null;
	                    }
	                }
	            } else {
	                return this._isUTC ? offset : this._dateTzOffset();
	            }
	            return this;
	        },
	
	        zoneAbbr : function () {
	            return this._isUTC ? 'UTC' : '';
	        },
	
	        zoneName : function () {
	            return this._isUTC ? 'Coordinated Universal Time' : '';
	        },
	
	        parseZone : function () {
	            if (this._tzm) {
	                this.zone(this._tzm);
	            } else if (typeof this._i === 'string') {
	                this.zone(this._i);
	            }
	            return this;
	        },
	
	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).zone();
	            }
	
	            return (this.zone() - input) % 60 === 0;
	        },
	
	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },
	
	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	        },
	
	        quarter : function (input) {
	            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	        },
	
	        weekYear : function (input) {
	            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },
	
	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },
	
	        week : function (input) {
	            var week = this.localeData().week(this);
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },
	
	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },
	
	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	            return input == null ? weekday : this.add(input - weekday, 'd');
	        },
	
	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },
	
	        isoWeeksInYear : function () {
	            return weeksInYear(this.year(), 1, 4);
	        },
	
	        weeksInYear : function () {
	            var weekInfo = this.localeData()._week;
	            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },
	
	        set : function (units, value) {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                this[units](value);
	            }
	            return this;
	        },
	
	        // If passed a locale key, it will set the locale for this
	        // instance.  Otherwise, it will return the locale configuration
	        // variables for this instance.
	        locale : function (key) {
	            var newLocaleData;
	
	            if (key === undefined) {
	                return this._locale._abbr;
	            } else {
	                newLocaleData = moment.localeData(key);
	                if (newLocaleData != null) {
	                    this._locale = newLocaleData;
	                }
	                return this;
	            }
	        },
	
	        lang : deprecate(
	            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	            function (key) {
	                if (key === undefined) {
	                    return this.localeData();
	                } else {
	                    return this.locale(key);
	                }
	            }
	        ),
	
	        localeData : function () {
	            return this._locale;
	        },
	
	        _dateTzOffset : function () {
	            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	            // https://github.com/moment/moment/pull/1871
	            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
	        }
	    });
	
	    function rawMonthSetter(mom, value) {
	        var dayOfMonth;
	
	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }
	
	        dayOfMonth = Math.min(mom.date(),
	                daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }
	
	    function rawGetter(mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }
	
	    function rawSetter(mom, unit, value) {
	        if (unit === 'Month') {
	            return rawMonthSetter(mom, value);
	        } else {
	            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	
	    function makeAccessor(unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                rawSetter(this, unit, value);
	                moment.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return rawGetter(this, unit);
	            }
	        };
	    }
	
	    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
	    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
	    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
	    // moment.fn.month is defined separately
	    moment.fn.date = makeAccessor('Date', true);
	    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
	    moment.fn.year = makeAccessor('FullYear', true);
	    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));
	
	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	    moment.fn.quarters = moment.fn.quarter;
	
	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;
	
	    /************************************
	        Duration Prototype
	    ************************************/
	
	
	    function daysToYears (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        return days * 400 / 146097;
	    }
	
	    function yearsToDays (years) {
	        // years * 365 + absRound(years / 4) -
	        //     absRound(years / 100) + absRound(years / 400);
	        return years * 146097 / 400;
	    }
	
	    extend(moment.duration.fn = Duration.prototype, {
	
	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years = 0;
	
	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;
	
	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;
	
	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;
	
	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;
	
	            days += absRound(hours / 24);
	
	            // Accurately convert days to years, assume start from year 0.
	            years = absRound(daysToYears(days));
	            days -= absRound(yearsToDays(years));
	
	            // 30 days to a month
	            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
	            months += absRound(days / 30);
	            days %= 30;
	
	            // 12 months -> 1 year
	            years += absRound(months / 12);
	            months %= 12;
	
	            data.days = days;
	            data.months = months;
	            data.years = years;
	        },
	
	        abs : function () {
	            this._milliseconds = Math.abs(this._milliseconds);
	            this._days = Math.abs(this._days);
	            this._months = Math.abs(this._months);
	
	            this._data.milliseconds = Math.abs(this._data.milliseconds);
	            this._data.seconds = Math.abs(this._data.seconds);
	            this._data.minutes = Math.abs(this._data.minutes);
	            this._data.hours = Math.abs(this._data.hours);
	            this._data.months = Math.abs(this._data.months);
	            this._data.years = Math.abs(this._data.years);
	
	            return this;
	        },
	
	        weeks : function () {
	            return absRound(this.days() / 7);
	        },
	
	        valueOf : function () {
	            return this._milliseconds +
	              this._days * 864e5 +
	              (this._months % 12) * 2592e6 +
	              toInt(this._months / 12) * 31536e6;
	        },
	
	        humanize : function (withSuffix) {
	            var output = relativeTime(this, !withSuffix, this.localeData());
	
	            if (withSuffix) {
	                output = this.localeData().pastFuture(+this, output);
	            }
	
	            return this.localeData().postformat(output);
	        },
	
	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);
	
	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);
	
	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },
	
	        as : function (units) {
	            var days, months;
	            units = normalizeUnits(units);
	
	            if (units === 'month' || units === 'year') {
	                days = this._days + this._milliseconds / 864e5;
	                months = this._months + daysToYears(days) * 12;
	                return units === 'month' ? months : months / 12;
	            } else {
	                // handle milliseconds separately because of floating point math errors (issue #1867)
	                days = this._days + Math.round(yearsToDays(this._months / 12));
	                switch (units) {
	                    case 'week': return days / 7 + this._milliseconds / 6048e5;
	                    case 'day': return days + this._milliseconds / 864e5;
	                    case 'hour': return days * 24 + this._milliseconds / 36e5;
	                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
	                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
	                    // Math.floor prevents floating point math errors here
	                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
	                    default: throw new Error('Unknown unit ' + units);
	                }
	            }
	        },
	
	        lang : moment.fn.lang,
	        locale : moment.fn.locale,
	
	        toIsoString : deprecate(
	            'toIsoString() is deprecated. Please use toISOString() instead ' +
	            '(notice the capitals)',
	            function () {
	                return this.toISOString();
	            }
	        ),
	
	        toISOString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
	
	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }
	
	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        },
	
	        localeData : function () {
	            return this._locale;
	        }
	    });
	
	    moment.duration.fn.toString = moment.duration.fn.toISOString;
	
	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }
	
	    for (i in unitMillisecondFactors) {
	        if (hasOwnProp(unitMillisecondFactors, i)) {
	            makeDurationGetter(i.toLowerCase());
	        }
	    }
	
	    moment.duration.fn.asMilliseconds = function () {
	        return this.as('ms');
	    };
	    moment.duration.fn.asSeconds = function () {
	        return this.as('s');
	    };
	    moment.duration.fn.asMinutes = function () {
	        return this.as('m');
	    };
	    moment.duration.fn.asHours = function () {
	        return this.as('h');
	    };
	    moment.duration.fn.asDays = function () {
	        return this.as('d');
	    };
	    moment.duration.fn.asWeeks = function () {
	        return this.as('weeks');
	    };
	    moment.duration.fn.asMonths = function () {
	        return this.as('M');
	    };
	    moment.duration.fn.asYears = function () {
	        return this.as('y');
	    };
	
	    /************************************
	        Default Locale
	    ************************************/
	
	
	    // Set default locale, other locale will inherit from English.
	    moment.locale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    /* EMBED_LOCALES */
	
	    /************************************
	        Exposing Moment
	    ************************************/
	
	    function makeGlobal(shouldDeprecate) {
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        oldGlobalMoment = globalScope.moment;
	        if (shouldDeprecate) {
	            globalScope.moment = deprecate(
	                    'Accessing Moment through the global scope is ' +
	                    'deprecated, and will be removed in an upcoming ' +
	                    'release.',
	                    moment);
	        } else {
	            globalScope.moment = moment;
	        }
	    }
	
	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	            if (module.config && module.config() && module.config().noGlobal === true) {
	                // release the global variable
	                globalScope.moment = oldGlobalMoment;
	            }
	
	            return moment;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        makeGlobal(true);
	    } else {
	        makeGlobal();
	    }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(8)(module)))

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 10,
		"./af.js": 10,
		"./ar": 11,
		"./ar-ma": 12,
		"./ar-ma.js": 12,
		"./ar-sa": 13,
		"./ar-sa.js": 13,
		"./ar.js": 11,
		"./az": 14,
		"./az.js": 14,
		"./be": 15,
		"./be.js": 15,
		"./bg": 16,
		"./bg.js": 16,
		"./bn": 17,
		"./bn.js": 17,
		"./bo": 18,
		"./bo.js": 18,
		"./br": 19,
		"./br.js": 19,
		"./bs": 20,
		"./bs.js": 20,
		"./ca": 21,
		"./ca.js": 21,
		"./cs": 22,
		"./cs.js": 22,
		"./cv": 23,
		"./cv.js": 23,
		"./cy": 24,
		"./cy.js": 24,
		"./da": 25,
		"./da.js": 25,
		"./de": 26,
		"./de-at": 27,
		"./de-at.js": 27,
		"./de.js": 26,
		"./el": 28,
		"./el.js": 28,
		"./en-au": 29,
		"./en-au.js": 29,
		"./en-ca": 30,
		"./en-ca.js": 30,
		"./en-gb": 31,
		"./en-gb.js": 31,
		"./eo": 32,
		"./eo.js": 32,
		"./es": 33,
		"./es.js": 33,
		"./et": 34,
		"./et.js": 34,
		"./eu": 35,
		"./eu.js": 35,
		"./fa": 36,
		"./fa.js": 36,
		"./fi": 37,
		"./fi.js": 37,
		"./fo": 38,
		"./fo.js": 38,
		"./fr": 39,
		"./fr-ca": 40,
		"./fr-ca.js": 40,
		"./fr.js": 39,
		"./gl": 41,
		"./gl.js": 41,
		"./he": 42,
		"./he.js": 42,
		"./hi": 43,
		"./hi.js": 43,
		"./hr": 44,
		"./hr.js": 44,
		"./hu": 45,
		"./hu.js": 45,
		"./hy-am": 46,
		"./hy-am.js": 46,
		"./id": 47,
		"./id.js": 47,
		"./is": 48,
		"./is.js": 48,
		"./it": 49,
		"./it.js": 49,
		"./ja": 50,
		"./ja.js": 50,
		"./ka": 51,
		"./ka.js": 51,
		"./km": 52,
		"./km.js": 52,
		"./ko": 53,
		"./ko.js": 53,
		"./lb": 54,
		"./lb.js": 54,
		"./lt": 55,
		"./lt.js": 55,
		"./lv": 56,
		"./lv.js": 56,
		"./mk": 57,
		"./mk.js": 57,
		"./ml": 58,
		"./ml.js": 58,
		"./mr": 59,
		"./mr.js": 59,
		"./ms-my": 60,
		"./ms-my.js": 60,
		"./my": 61,
		"./my.js": 61,
		"./nb": 62,
		"./nb.js": 62,
		"./ne": 63,
		"./ne.js": 63,
		"./nl": 64,
		"./nl.js": 64,
		"./nn": 65,
		"./nn.js": 65,
		"./pl": 66,
		"./pl.js": 66,
		"./pt": 67,
		"./pt-br": 68,
		"./pt-br.js": 68,
		"./pt.js": 67,
		"./ro": 69,
		"./ro.js": 69,
		"./ru": 70,
		"./ru.js": 70,
		"./sk": 71,
		"./sk.js": 71,
		"./sl": 72,
		"./sl.js": 72,
		"./sq": 73,
		"./sq.js": 73,
		"./sr": 74,
		"./sr-cyrl": 75,
		"./sr-cyrl.js": 75,
		"./sr.js": 74,
		"./sv": 76,
		"./sv.js": 76,
		"./ta": 77,
		"./ta.js": 77,
		"./th": 78,
		"./th.js": 78,
		"./tl-ph": 79,
		"./tl-ph.js": 79,
		"./tr": 80,
		"./tr.js": 80,
		"./tzm": 81,
		"./tzm-latn": 82,
		"./tzm-latn.js": 82,
		"./tzm.js": 81,
		"./uk": 83,
		"./uk.js": 83,
		"./uz": 84,
		"./uz.js": 84,
		"./vi": 85,
		"./vi.js": 85,
		"./zh-cn": 86,
		"./zh-cn.js": 86,
		"./zh-tw": 87,
		"./zh-tw.js": 87
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 9;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : afrikaans (af)
	// author : Werner Mollentze : https://github.com/wernerm
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Mre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });
	}));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// Locale: Arabic (ar)
	// Author: Abdel Said: https://github.com/abdelsaid
	// Changes in months, weekdays: Ahmed Elkhatib
	// Native plural forms: forabi https://github.com/forabi
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        '  ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        '  ',
	        '  ',
	        '  '
	    ];
	
	    return moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Moroccan Arabic (ar-ma)
	// author : ElFadili Yassine : https://github.com/ElFadiliY
	// author : Abdel Said : https://github.com/abdelsaid
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ar-ma', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Arabic Saudi Arabia (ar-sa)
	// author : Suhail Alkowaileet : https://github.com/xsoh
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('ar-sa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : azerbaijani (az)
	// author : topchiyev : https://github.com/topchiyev
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	
	        3: '-nc',
	        4: '-nc',
	        100: '-nc',
	
	        6: '-nc',
	
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	
	        60: '-nc',
	        90: '-nc'
	    };
	    return moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gln hft] dddd [saat] LT',
	            lastDay : '[dnn] LT',
	            lastWeek : '[ken hft] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s vvl',
	            s : 'birne saniyy',
	            m : 'bir dqiq',
	            mm : '%d dqiq',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gec';
	            } else if (hour < 12) {
	                return 'shr';
	            } else if (hour < 17) {
	                return 'gndz';
	            } else {
	                return 'axam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : belarusian (be)
	// author : Dmitry Demidov : https://github.com/demidov91
	// author: Praleska: http://praleska.pro/
	// Author : Menelion Elensle : https://github.com/Oire
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': withoutSuffix ? '__' : '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return months[nounCase][m.month()];
	    }
	
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	
	        nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return weekdays[nounCase][m.day()];
	    }
	
	    return moment.defineLocale('be', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., LT',
	            LLLL : 'dddd, D MMMM YYYY ., LT'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function () {
	                return '[] dddd [] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	
	
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : bulgarian (bg)
	// author : Krasen Borisov : https://github.com/kraz
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('bg', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bengali (bn)
	// author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('bn', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        //Bengali is a vast language its spoken
	        //in different forms in various parts of the world.
	        //I have just generalized with most common one used
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : tibetan (bo)
	// author : Thupten N. Chakrishar : https://github.com/vajradog
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('bo', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[], LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : breton (br)
	// author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	        }
	    }
	
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }
	
	    return moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY LT',
	            LLLL : 'dddd, D [a viz] MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondenno',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(a|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'a' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : bosnian (bs)
	// author : Nedim Cholich : https://github.com/frontyard
	// based on (hr) translation by Bojan Markovi
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    return moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : catalan (ca)
	// author : Juan G. Hurtado : https://github.com/juanghurtado
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ca', {
	        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t||a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : '';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : czech (cs)
	// author : petrbela : https://github.com/petrbela
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dn');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'msce' : 'msc');
	            } else {
	                return result + 'msci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	        }
	    }
	
	    return moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (ervenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[ztra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve stedu v] LT';
	                case 4:
	                    return '[ve tvrtek v] LT';
	                case 5:
	                    return '[v ptek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[vera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulou nedli v] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [v] LT';
	                case 3:
	                    return '[minulou stedu v] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'ped %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : chuvash (cv)
	// author : Anatoly Mironov : https://github.com/mirontoli
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('cv', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [] MMMM [] D[-]',
	            LLL : 'YYYY [] MMMM [] D[-], LT',
	            LLLL : 'dddd, YYYY [] MMMM [] D[-], LT'
	        },
	        calendar : {
	            sameDay: '[] LT []',
	            nextDay: '[] LT []',
	            lastDay: '[] LT []',
	            nextWeek: '[] dddd LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	                return output + affix;
	            },
	            past : '%s ',
	            s : '- ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-/,
	        ordinal : '%d-',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Welsh (cy)
	// author : Robert Allen
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'LT:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd, D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn l',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : danish (da)
	// author : Ulrik Nielsen : https://github.com/mrbase
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd [d.] D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I gr kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'f sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'et r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : german (de)
	// author : lluchs : https://github.com/lluchs
	// author: Menelion Elensle: https://github.com/Oire
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    return moment.defineLocale('de', {
	        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : austrian german (de-at)
	// author : lluchs : https://github.com/lluchs
	// author: Menelion Elensle: https://github.com/Oire
	// author : Martin Groller : https://github.com/MadMG
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    return moment.defineLocale('de-at', {
	        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : modern greek (el)
	// author : Aggelos Karalias : https://github.com/mehiel
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('el', {
	        monthsNominativeEl : '___________'.split('_'),
	        monthsGenitiveEl : '___________'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? '' : '';
	            } else {
	                return isLower ? '' : '';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === '');
	        },
	        meridiemParse : /[]\.??\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendarEl : {
	            sameDay : '[ {}] LT',
	            nextDay : '[ {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[ {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[ ] dddd [{}] LT';
	                    default:
	                        return '[ ] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	
	            if (typeof output === 'function') {
	                output = output.apply(mom);
	            }
	
	            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : australian english (en-au)
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : canadian english (en-ca)
	// author : Jonathan Abourbih : https://github.com/jonbca
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM, YYYY',
	            LLL : 'D MMMM, YYYY LT',
	            LLLL : 'dddd, D MMMM, YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	}));


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : great britain english (en-gb)
	// author : Chris Gedrim : https://github.com/chrisgedrim
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : esperanto (eo)
	// author : Colin Dean : https://github.com/colindean
	// komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY LT',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodia je] LT',
	            nextDay : '[Morga je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hiera je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'anta %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : spanish (es)
	// author : Julio Napur : https://github.com/julionc
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	    return moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ao',
	            yy : '%d aos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : estonian (et)
	// author : Henry Kehlmann : https://github.com/madhenry
	// improvements : Illimar Tambek : https://github.com/ragulka
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	            'm' : ['he minuti', 'ks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['he tunni', 'tund aega', 'ks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['he peva', 'ks pev'],
	            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['he aasta', 'aasta', 'ks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }
	
	    return moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'LT:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[Tna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Jrgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s prast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d peva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : euskara (eu)
	// author : Eneko Illarramendi : https://github.com/eillarra
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] LT',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] LT',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] LT',
	            llll : 'ddd, YYYY[ko] MMM D[a] LT'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Persian (fa)
	// author : Ebrahim Byagowi : https://github.com/ebraminio
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('fa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '  ';
	            } else {
	                return '  ';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : 'dddd [] [] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[-]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : finnish (fi)
	// author : Tarmo Aidantausta : https://github.com/bleadof
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'pivn' : 'piv';
	        case 'dd':
	            result = isFuture ? 'pivn' : 'piv';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }
	
	    return moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] LT',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] LT',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] LT',
	            llll : 'ddd, Do MMM YYYY, [klo] LT'
	        },
	        calendar : {
	            sameDay : '[tnn] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pst',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : faroese (fo)
	// author : Ragnar Johannesen : https://github.com/ragnar123
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fo', {
	        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM, YYYY LT'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gjr kl.] LT',
	            lastWeek : '[sstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s sani',
	            s : 'f sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tmi',
	            hh : '%d tmar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mnai',
	            MM : '%d mnair',
	            y : 'eitt r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : french (fr)
	// author : John Fischer : https://github.com/jfroffice
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fr', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : canadian french (fr-ca)
	// author : Jonathan Abourbih : https://github.com/jonbca
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fr-ca', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        }
	    });
	}));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : galician (gl)
	// author : Juan G. Hurtado : https://github.com/juanghurtado
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Hebrew (he)
	// author : Tomer Cohen : https://github.com/tomer
	// author : Moshe Simantov : https://github.com/DevelopmentIL
	// author : Tal Ater : https://github.com/TalAter
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('he', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D []MMMM YYYY',
	            LLL : 'D []MMMM YYYY LT',
	            LLLL : 'dddd, D []MMMM YYYY LT',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY LT',
	            llll : 'ddd, D MMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[ ]LT',
	            nextDay : '[ ]LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ]LT',
	            lastWeek : '[] dddd [ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            d : '',
	            dd : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            M : '',
	            MM : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            y : '',
	            yy : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            }
	        }
	    });
	}));


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hindi (hi)
	// author : Mayank Singhal : https://github.com/mayanksinghal
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('hi', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hrvatski (hr)
	// author : Bojan Markovi : https://github.com/bmarkovic
	
	// based on (sl) translation by Robert Sedovek
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    return moment.defineLocale('hr', {
	        months : 'sjeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
	        monthsShort : 'sje._vel._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hungarian (hu)
	// author : Adam Brunner : https://github.com/adambrunner
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	
	        switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	        }
	
	        return '';
	    }
	
	    function week(isFuture) {
	        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }
	
	    return moment.defineLocale('hu', {
	        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D., LT',
	            LLLL : 'YYYY. MMMM D., dddd LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s mlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Armenian (hy-am)
	// author : Armendarabyan : https://github.com/armendarabyan
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return months[nounCase][m.month()];
	    }
	
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = '___________'.split('_');
	
	        return monthsShort[m.month()];
	    }
	
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = '______'.split('_');
	
	        return weekdays[m.day()];
	    }
	
	    return moment.defineLocale('hy-am', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., LT',
	            LLLL : 'dddd, D MMMM YYYY ., LT'
	        },
	        calendar : {
	            sameDay: '[] LT',
	            nextDay: '[] LT',
	            lastDay: '[] LT',
	            nextWeek: function () {
	                return 'dddd [ ] LT';
	            },
	            lastWeek: function () {
	                return '[] dddd [ ] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	
	        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-';
	                }
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bahasa Indonesia (id)
	// author : Mohammad Satrio Utomo : https://github.com/tyok
	// reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] LT',
	            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : icelandic (is)
	// author : Hinrik rn Sigursson : https://github.com/hinrik
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	        case 'm':
	            return withoutSuffix ? 'mnta' : 'mntu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	            } else if (withoutSuffix) {
	                return result + 'mnta';
	            }
	            return result + 'mntu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dgum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mnuur';
	            }
	            return isFuture ? 'mnu' : 'mnui';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mnuir';
	                }
	                return result + (isFuture ? 'mnui' : 'mnuum');
	            } else if (withoutSuffix) {
	                return result + 'mnuur';
	            }
	            return result + (isFuture ? 'mnu' : 'mnui');
	        case 'y':
	            return withoutSuffix || isFuture ? 'r' : 'ri';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	            }
	            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	        }
	    }
	
	    return moment.defineLocale('is', {
	        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] LT',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] LT'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gr kl.] LT',
	            lastWeek : '[sasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s san',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : italian (it)
	// author : Lorenzo : https://github.com/aliem
	// author: Mattia Larentis: https://github.com/nostalgiaz
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : japanese (ja)
	// author : LI Long : https://github.com/baryon
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ja', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahm',
	            LTS : 'LTs',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYYMD',
	            LLL : 'YYYYMDLT',
	            LLLL : 'YYYYMDLT dddd'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[]dddd LT',
	            lastDay : '[] LT',
	            lastWeek : '[]dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1',
	            mm : '%d',
	            h : '1',
	            hh : '%d',
	            d : '1',
	            dd : '%d',
	            M : '1',
	            MM : '%d',
	            y : '1',
	            yy : '%d'
	        }
	    });
	}));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Georgian (ka)
	// author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD] *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return months[nounCase][m.month()];
	    }
	
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	
	        nounCase = (/(|)/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return weekdays[nounCase][m.day()];
	    }
	
	    return moment.defineLocale('ka', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[] LT[-]',
	            nextDay : '[] LT[-]',
	            lastDay : '[] LT[-]',
	            nextWeek : '[] dddd LT[-]',
	            lastWeek : '[] dddd LT-',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(|||)/).test(s) ?
	                    s.replace(/$/, '') :
	                    s + '';
	            },
	            past : function (s) {
	                if ((/(||||)/).test(s)) {
	                    return s.replace(/(|)$/, ' ');
	                }
	                if ((//).test(s)) {
	                    return s.replace(/$/, ' ');
	                }
	            },
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	
	            if (number === 1) {
	                return number + '-';
	            }
	
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return '-' + number;
	            }
	
	            return number + '-';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });
	}));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : khmer (km)
	// author : Kruy Vanna : https://github.com/kruyvanna
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('km', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'LT:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd, D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] [] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%s',
	            past: '%s',
	            s: '',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : korean (ko)
	//
	// authors
	//
	// - Kyungwook, Park : https://github.com/kyungw00k
	// - Jeeeyul Lee <jeeeyul@gmail.com>
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ko', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h m',
	            LTS : 'A h m s',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D LT',
	            LLLL : 'YYYY MMMM D dddd LT'
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '' : '';
	        },
	        calendar : {
	            sameDay : ' LT',
	            nextDay : ' LT',
	            nextWeek : 'dddd LT',
	            lastDay : ' LT',
	            lastWeek : ' dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            ss : '%d',
	            m : '',
	            mm : '%d',
	            h : '',
	            hh : '%d',
	            d : '',
	            dd : '%d',
	            M : '',
	            MM : '%d',
	            y : '',
	            yy : '%d'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        meridiemParse : /(|)/,
	        isPM : function (token) {
	            return token === '';
	        }
	    });
	}));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Luxembourgish (lb)
	// author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz
	
	// Note: Luxembourgish has a very particular phonological rule ('Eifeler Regel') that causes the
	// deletion of the final 'n' in certain contexts. That's what the 'eifelerRegelAppliesToWeekday'
	// and 'eifelerRegelAppliesToNumber' methods are meant for
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }
	
	    return moment.defineLocale('lb', {
	        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Mint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Lithuanian (lt)
	// author : Mindaugas Mozras : https://github.com/mmozuras
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var units = {
	        'm' : 'minut_minuts_minut',
	        'mm': 'minuts_minui_minutes',
	        'h' : 'valanda_valandos_valand',
	        'hh': 'valandos_valand_valandas',
	        'd' : 'diena_dienos_dien',
	        'dd': 'dienos_dien_dienas',
	        'M' : 'mnuo_mnesio_mnes',
	        'MM': 'mnesiai_mnesi_mnesius',
	        'y' : 'metai_met_metus',
	        'yy': 'metai_met_metus'
	    },
	    weekDays = 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_');
	
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekunds';
	        } else {
	            return isFuture ? 'keli sekundi' : 'kelias sekundes';
	        }
	    }
	
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	
	    function forms(key) {
	        return units[key].split('_');
	    }
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	
	    function relativeWeekDay(moment, format) {
	        var nominative = format.indexOf('dddd HH:mm') === -1,
	            weekDay = weekDays[moment.day()];
	
	        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + '';
	    }
	
	    return moment.defineLocale('lt', {
	        months : 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : relativeWeekDay,
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], LT [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, LT [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], LT [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, LT [val.]'
	        },
	        calendar : {
	            sameDay : '[iandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Prajus] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prie %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : latvian (lv)
	// author : Kristaps Karlsons : https://github.com/skakri
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var units = {
	        'mm': 'minti_mintes_minte_mintes',
	        'hh': 'stundu_stundas_stunda_stundas',
	        'dd': 'dienu_dienas_diena_dienas',
	        'MM': 'mnesi_mneus_mnesis_mnei',
	        'yy': 'gadu_gadus_gads_gadi'
	    };
	
	    function format(word, number, withoutSuffix) {
	        var forms = word.split('_');
	        if (withoutSuffix) {
	            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
	        } else {
	            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
	        }
	    }
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	
	    return moment.defineLocale('lv', {
	        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, LT',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, LT'
	        },
	        calendar : {
	            sameDay : '[odien pulksten] LT',
	            nextDay : '[Rt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagju] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s vlk',
	            past : '%s agrk',
	            s : 'daas sekundes',
	            m : 'minti',
	            mm : relativeTimeWithPlural,
	            h : 'stundu',
	            hh : relativeTimeWithPlural,
	            d : 'dienu',
	            dd : relativeTimeWithPlural,
	            M : 'mnesi',
	            MM : relativeTimeWithPlural,
	            y : 'gadu',
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : macedonian (mk)
	// author : Borislav Mickov : https://github.com/B0k0
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('mk', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : 'e_o_____a'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : malayalam (ml)
	// author : Floyd Pink : https://github.com/floydpink
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ml', {
	        months : '___________'.split('_'),
	        monthsShort : '._._._.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -',
	            LTS : 'A h:mm:ss -',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return ' ';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        }
	    });
	}));


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Marathi (mr)
	// author : Harshad Kale : https://github.com/kalehv
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('mr', {
	        months : '___________'.split('_'),
	        monthsShort: '._._._._._._._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek: '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            m: ' ',
	            mm: '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiem: function (hour, minute, isLower)
	        {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bahasa Malaysia (ms-MY)
	// author : Weldan Jamili : https://github.com/weldan
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] LT',
	            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Burmese (my)
	// author : Squar team, mysquar.com
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	    return moment.defineLocale('my', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[.] LT []',
	            nextDay: '[] LT []',
	            nextWeek: 'dddd LT []',
	            lastDay: '[.] LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: ' %s ',
	            past: ' %s ',
	            s: '.',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : norwegian bokml (nb)
	// authors : Espen Hovlandsdal : https://github.com/rexxars
	//           Sigurd Gartmann : https://github.com/sigurdga
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_man_tirs_ons_tors_fre_lr'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'H.mm',
	            LTS : 'LT.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] LT',
	            LLLL : 'dddd D. MMMM YYYY [kl.] LT'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i gr kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : nepali/nepalese
	// author : suvash : https://github.com/suvash
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };
	
	    return moment.defineLocale('ne', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '._._._._._._.'.split('_'),
	        weekdaysMin : '._.__._._._.'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 15) {
	                return '';
	            } else if (hour < 18) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[] dddd[,] LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : dutch (nl)
	// author : Joris Rling : https://github.com/jjupiter
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	    return moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'n minuut',
	            mm : '%d minuten',
	            h : 'n uur',
	            hh : '%d uur',
	            d : 'n dag',
	            dd : '%d dagen',
	            M : 'n maand',
	            MM : '%d maanden',
	            y : 'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : norwegian nynorsk (nn)
	// author : https://github.com/mechuwind
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I gr klokka] LT',
	            lastWeek: '[Fregande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein mnad',
	            MM : '%d mnader',
	            y : 'eit r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : polish (pl)
	// author : Rafal Hirsz : https://github.com/evoL
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minut';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzin';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesice' : 'miesicy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }
	
	    return moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
	        weekdaysMin : 'N_Pn_Wt_r_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Dzi o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[W zesz niedziel o] LT';
	                case 3:
	                    return '[W zesz rod o] LT';
	                case 6:
	                    return '[W zesz sobot o] LT';
	                default:
	                    return '[W zeszy] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzie',
	            dd : '%d dni',
	            M : 'miesic',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : portuguese (pt)
	// author : Jefferson : https://github.com/jalex79
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('pt', {
	        months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	        weekdays : 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
	        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
	        weekdaysMin : 'dom_2_3_4_5_6_sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'h %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : brazilian portuguese (pt-br)
	// author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('pt-br', {
	        months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	        weekdays : 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
	        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
	        weekdaysMin : 'dom_2_3_4_5_6_sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [s] LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] LT'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrs',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d'
	    });
	}));


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : romanian (ro)
	// author : Vlad Gurdiga : https://github.com/gurdiga
	// author : Valentin Agachi : https://github.com/avaly
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	
	        return number + separator + format[key];
	    }
	
	    return moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s n urm',
	            s : 'cteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o or',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lun',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : russian (ru)
	// author : Viktorminator : https://github.com/Viktorminator
	// Author : Menelion Elensle : https://github.com/Oire
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return months[nounCase][m.month()];
	    }
	
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return monthsShort[nounCase][m.month()];
	    }
	
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	
	        nounCase = (/\[ ?[] ?(?:||)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return weekdays[nounCase][m.day()];
	    }
	
	    return moment.defineLocale('ru', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        monthsParse : [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., LT',
	            LLLL : 'dddd, D MMMM YYYY ., LT'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function () {
	                return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[] dddd [] LT';
	                    } else {
	                        return '[] dddd [] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	
	        meridiemParse: /|||/i,
	        isPM : function (input) {
	            return /^(|)$/.test(input);
	        },
	
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            case 'w':
	            case 'W':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : slovak (sk)
	// author : Martin Minka : https://github.com/k2s
	// based on work of petrbela : https://github.com/petrbela
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minty' : 'mint');
	            } else {
	                return result + 'mintami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodn');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'de' : 'dom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dn');
	            } else {
	                return result + 'dami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	        }
	    }
	
	    return moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (ervenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo tvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[vera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minul nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [o] LT';
	                case 3:
	                    return '[minul stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [o] LT';
	                case 6:
	                    return '[minul sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : slovenian (sl)
	// author : Robert Sedovek : https://github.com/sedovsek
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2) {
	                result += 'minuti';
	            } else if (number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minut';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += 'ura';
	            } else if (number === 2) {
	                result += 'uri';
	            } else if (number === 3 || number === 4) {
	                result += 'ure';
	            } else {
	                result += 'ur';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dni';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mesec';
	            } else if (number === 2) {
	                result += 'meseca';
	            } else if (number === 3 || number === 4) {
	                result += 'mesece';
	            } else {
	                result += 'mesecev';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'leto';
	            } else if (number === 2) {
	                result += 'leti';
	            } else if (number === 3 || number === 4) {
	                result += 'leta';
	            } else {
	                result += 'let';
	            }
	            return result;
	        }
	    }
	
	    return moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[veraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[prejnja] dddd [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ez %s',
	            past   : '%s nazaj',
	            s      : 'nekaj sekund',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'en dan',
	            dd     : translate,
	            M      : 'en mesec',
	            MM     : translate,
	            y      : 'eno leto',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Albanian (sq)
	// author : Flakrim Ismani : https://github.com/flakerimi
	// author: Menelion Elensle: https://github.com/Oire (tests)
	// author : Oerd Cukalla : https://github.com/oerd (fixes)
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Sot n] LT',
	            nextDay : '[Nesr n] LT',
	            nextWeek : 'dddd [n] LT',
	            lastDay : '[Dje n] LT',
	            lastWeek : 'dddd [e kaluar n] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'n %s',
	            past : '%s m par',
	            s : 'disa sekonda',
	            m : 'nj minut',
	            mm : '%d minuta',
	            h : 'nj or',
	            hh : '%d or',
	            d : 'nj dit',
	            dd : '%d dit',
	            M : 'nj muaj',
	            MM : '%d muaj',
	            y : 'nj vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Serbian-latin (sr)
	// author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    return moment.defineLocale('sr', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'etvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'et.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jue u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prole] [nedelje] [u] LT',
	                    '[prolog] [ponedeljka] [u] LT',
	                    '[prolog] [utorka] [u] LT',
	                    '[prole] [srede] [u] LT',
	                    '[prolog] [etvrtka] [u] LT',
	                    '[prolog] [petka] [u] LT',
	                    '[prole] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Serbian-cyrillic (sr-cyrl)
	// author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var translator = {
	        words: { //Different grammatical cases
	            m: [' ', ' '],
	            mm: ['', '', ''],
	            h: [' ', ' '],
	            hh: ['', '', ''],
	            dd: ['', '', ''],
	            MM: ['', '', ''],
	            yy: ['', '', '']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    return moment.defineLocale('sr-cyrl', {
	        months: ['', '', '', '', '', '', '', '', '', '', '', ''],
	        monthsShort: ['.', '.', '.', '.', '', '', '', '.', '.', '.', '.', '.'],
	        weekdays: ['', '', '', '', '', '', ''],
	        weekdaysShort: ['.', '.', '.', '.', '.', '.', '.'],
	        weekdaysMin: ['', '', '', '', '', '', ''],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[] [] [] LT';
	                case 3:
	                    return '[] [] [] LT';
	                case 6:
	                    return '[] [] [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	                }
	            },
	            lastDay  : '[ ] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past   : ' %s',
	            s      : ' ',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : '',
	            dd     : translator.translate,
	            M      : '',
	            MM     : translator.translate,
	            y      : '',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : swedish (sv)
	// author : Jens Alm : https://github.com/ulmus
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igr] LT',
	            nextWeek: 'dddd LT',
	            lastWeek: '[Frra] dddd[en] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'fr %s sedan',
	            s : 'ngra sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en mnad',
	            MM : '%d mnader',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : tamil (ta)
	// author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    /*var symbolMap = {
	            '1': '',
	            '2': '',
	            '3': '',
	            '4': '',
	            '5': '',
	            '6': '',
	            '7': '',
	            '8': '',
	            '9': '',
	            '0': ''
	        },
	        numberMap = {
	            '': '1',
	            '': '2',
	            '': '3',
	            '': '4',
	            '': '5',
	            '': '6',
	            '': '7',
	            '': '8',
	            '': '9',
	            '': '0'
	        }; */
	
	    return moment.defineLocale('ta', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[ ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : '  ',
	            hh : '%d  ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	/*        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },*/
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number + '';
	        },
	
	
	        // refer http://ta.wikipedia.org/s/1er1
	
	        meridiem : function (hour, minute, isLower) {
	            if (hour >= 6 && hour <= 10) {
	                return ' ';
	            } else if (hour >= 10 && hour <= 14) {
	                return ' ';
	            } else if (hour >= 14 && hour <= 18) {
	                return ' ';
	            } else if (hour >= 18 && hour <= 20) {
	                return ' ';
	            } else if (hour >= 20 && hour <= 24) {
	                return ' ';
	            } else if (hour >= 0 && hour <= 6) {
	                return ' ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : thai (th)
	// author : Kridsada Thanabulpong : https://github.com/sirn
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('th', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'), // yes, three characters difference
	        weekdaysMin : '._._._._._._.'.split('_'),
	        longDateFormat : {
	            LT : 'H  m ',
	            LTS : 'LT s ',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY  LT',
	            LLLL : 'dddd D MMMM YYYY  LT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd[ ] LT',
	            lastDay : '[ ] LT',
	            lastWeek : '[]dddd[ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        }
	    });
	}));


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Tagalog/Filipino (tl-ph)
	// author : Dan Hagman
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY LT',
	            LLLL : 'dddd, MMMM DD, YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : turkish (tr)
	// authors : Erhan Gundogan : https://github.com/erhangundogan,
	//           Burak Yiit Kaya: https://github.com/BYK
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	
	        3: '\'nc',
	        4: '\'nc',
	        100: '\'nc',
	
	        6: '\'nc',
	
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	
	        60: '\'nc',
	        90: '\'nc'
	    };
	
	    return moment.defineLocale('tr', {
	        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[yarn saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dn] LT',
	            lastWeek : '[geen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s nce',
	            s : 'birka saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yl',
	            yy : '%d yl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Morocco Central Atlas Tamazit (tzm)
	// author : Abdel Said : https://github.com/abdelsaid
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tzm', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '   %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d o',
	            M : 'o',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
	// author : Abdel Said : https://github.com/abdelsaid
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tzm-latn', {
	        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minu',
	            mm : '%d minu',
	            h : 'saa',
	            hh : '%d tassain',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : ukrainian (uk)
	// author : zemlanin : https://github.com/zemlanin
	// Author : Menelion Elensle : https://github.com/Oire
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': '__',
	            'hh': '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	
	        nounCase = (/D[oD]? *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	
	        return months[nounCase][m.month()];
	    }
	
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_'),
	            'genitive': '______'.split('_')
	        },
	
	        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	
	        return weekdays[nounCase][m.day()];
	    }
	
	    function processHoursFunction(str) {
	        return function () {
	            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	        };
	    }
	
	    return moment.defineLocale('uk', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., LT',
	            LLLL : 'dddd, D MMMM YYYY ., LT'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[ '),
	            nextDay: processHoursFunction('[ '),
	            lastDay: processHoursFunction('[ '),
	            nextWeek: processHoursFunction('[] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	
	        ordinalParse: /\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : uzbek (uz)
	// author : Sardor Muminov : https://github.com/muminoff
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('uz', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'D MMMM YYYY, dddd LT'
	        },
	        calendar : {
	            sameDay : '[ ] LT []',
	            nextDay : '[] LT []',
	            nextWeek : 'dddd [ ] LT []',
	            lastDay : '[ ] LT []',
	            lastWeek : '[] dddd [ ] LT []',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s ',
	            past : '  %s ',
	            s : '',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : vietnamese (vi)
	// author : Bang Nguyen : https://github.com/bangnk
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('vi', {
	        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [nm] YYYY',
	            LLL : 'D MMMM [nm] YYYY LT',
	            LLLL : 'dddd, D MMMM [nm] YYYY LT',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY LT',
	            llll : 'ddd, D MMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Hm nay lc] LT',
	            nextDay: '[Ngy mai lc] LT',
	            nextWeek: 'dddd [tun ti lc] LT',
	            lastDay: '[Hm qua lc] LT',
	            lastWeek: 'dddd [tun ri lc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ti',
	            past : '%s trc',
	            s : 'vi giy',
	            m : 'mt pht',
	            mm : '%d pht',
	            h : 'mt gi',
	            hh : '%d gi',
	            d : 'mt ngy',
	            dd : '%d ngy',
	            M : 'mt thng',
	            MM : '%d thng',
	            y : 'mt nm',
	            yy : '%d nm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : chinese (zh-cn)
	// author : suupic : https://github.com/suupic
	// author : Zeno Zeng : https://github.com/zenozeng
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('zh-cn', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDLT',
	            LLLL : 'YYYYMMMDddddLT',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDLT',
	            llll : 'YYYYMMMDddddLT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '';
	            } else if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1',
	            mm : '%d',
	            h : '1',
	            hh : '%d',
	            d : '1',
	            dd : '%d',
	            M : '1',
	            MM : '%d',
	            y : '1',
	            yy : '%d'
	        },
	        week : {
	            // GB/T 7408-1994ISO 8601:1988
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : traditional chinese (zh-tw)
	// author : Ben : https://github.com/ben-lin
	
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('zh-tw', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYYMMMD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDLT',
	            LLLL : 'YYYYMMMDddddLT',
	            l : 'YYYYMMMD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDLT',
	            llll : 'YYYYMMMDddddLT'
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[]LT',
	            nextDay : '[]LT',
	            nextWeek : '[]ddddLT',
	            lastDay : '[]LT',
	            lastWeek : '[]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '',
	            mm : '%d',
	            h : '',
	            hh : '%d',
	            d : '',
	            dd : '%d',
	            M : '',
	            MM : '%d',
	            y : '',
	            yy : '%d'
	        }
	    });
	}));


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
	  /** @namespace Plumage */
	  return {
	    /** @namespace Plumage.model */
	    model: {},
	    /** @namespace Plumage.collection */
	    collection: {},
	    /** @namespace Plumage.controller */
	    controller: {},
	    /** @namespace Plumage.util */
	    util: {},
	    /** @namespace Plumage.vendor */
	    vendor: {},
	    /** @namespace Plumage.view */
	    view: {
	      /** @namespace Plumage.view.comment */
	      comment: {},
	      /** @namespace Plumage.view.controller */
	      controller: {},
	      /** @namespace Plumage.view.form */
	      form: {
	        /** @namespace Plumage.view.form.fields */
	        fields: {
	          /** @namespace Plumage.view.form.fields.picker */
	          picker: {}
	        }
	      },
	      /** @namespace Plumage.view.grid */
	      grid: {},
	      /** @namespace Plumage.view.menu */
	      menu: {}
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(99),
	  __webpack_require__(103)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, Field, Picker, template) {
	
	  return  Plumage.view.form.fields.FieldWithPicker = Field.extend(
	  /** @lends Plumage.view.form.fields.FieldWithPicker.prototype */
	  {
	
	    template: template,
	
	    /** Options to instantiate the Picker with. You can even pass in subViews, so you don't have to subclass Picker. */
	    pickerCls: Picker,
	
	    /** Options to instantiate the Picker with. You can even pass in subViews, so you don't have to subclass Picker. */
	    pickerOptions: undefined,
	
	    events: {
	      'click input:first': 'onInputClick',
	      'click button:first': 'onButtonClick',
	    },
	
	    /**
	     * Base class for fields that show a picker (eg date picker, color picker etc.) when focused.
	     *
	     * Pass your Picker subclass as pickerCls, or customize the base Picker class by passing in pickerOptions (or do both).
	     *
	     * @constructs
	     * @extends Plumage.view.form.fields.Field
	     */
	    initialize:function(options) {
	      if (!this.subViews) {
	        this.subViews = [];
	      }
	      this.subViews = this.subViews.concat([_.extend({
	        viewCls: this.pickerCls,
	        name: 'picker',
	        selector: '.picker',
	        replaceEl: true
	      }, this.pickerOptions)]);
	
	      Field.prototype.initialize.apply(this, arguments);
	
	      var picker = this.getPicker();
	
	      picker.on('apply', this.onPickerApply, this);
	      picker.on('close', this.onPickerClose, this);
	    },
	
	    getPicker: function() {
	      return this.getSubView('picker');
	    },
	
	    getInputSelector: function() {
	      // skip the button
	      return 'input:first';
	    },
	
	    //update the picker model
	    valueChanged: function() {
	      this.getPicker().setValue(this.getValue());
	    },
	
	    //
	    // Dropdown
	    //
	
	    /** Is the dropdown open? */
	    isOpen: function() {
	      return this.$('.dropdown').hasClass('open');
	    },
	
	    /** Toggle dropdown open/closed */
	    toggle: function() {
	      if (this.isOpen()) {
	        this.close();
	      } else {
	        this.open();
	      }
	    },
	
	    open: function() {
	      this.update();
	      this.$('.dropdown:first').addClass('open');
	    },
	
	    /** Close the dropdown */
	    close: function() {
	      this.$('.dropdown').removeClass('open');
	    },
	
	    /** hook */
	    processPickerValue: function(value) {
	      return value;
	    },
	
	    //
	    // overrides
	    //
	
	    updateValueFromModel: function (model) {
	      Field.prototype.updateValueFromModel.apply(this, arguments);
	    },
	
	    //
	    // Events
	    //
	    onChange: function(e) {
	      //disable automatic updating from Field
	    },
	
	    onModelChange: function (e) {
	      Field.prototype.onModelChange.apply(this, arguments);
	    },
	
	    onModelLoad: function (e) {
	      this.updateValueFromModel();
	    },
	
	    onSubmit: function(e) {
	      this.updateValueFromDom();
	      Field.prototype.onSubmit.apply(this, arguments);
	    },
	
	    onInputClick: function(e) {
	      this.open();
	    },
	
	    onButtonClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.getInputEl().focus();
	    },
	
	    onFocus: function(e) {
	      this.open();
	    },
	
	    onBlur: function(e) {
	      this.close();
	      //don't update value from DOM if picker apply was clicked
	      if(this.applying) {
	        this.applying = false;
	      } else {
	        this.updateValueFromDom();
	      }
	      this.trigger('blur', this);
	    },
	
	    onPickerApply: function(picker, model) {
	      this.applying = true;
	      this.setValue(this.processPickerValue(picker.getValue()));
	      this.close();
	    },
	
	    onPickerClose: function() {
	      this.close();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(91),
	  __webpack_require__(93),
	  __webpack_require__(98)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, View, ModelView, template) {
	
	
	
	  return Plumage.view.form.fields.Field = ModelView.extend(
	  /** @lends Plumage.view.form.fields.Field.prototype */
	  {
	    className: 'control-group',
	
	    template: template,
	
	    fieldType: 'text',
	
	    /**
	     * Template for html input element.
	     * This template is separate so that it can be reused by subclasses.
	     */
	    fieldTemplate: '<input type="{{fieldType}}" name="{{valueAttr}}" {{#placeholder}}placeholder="{{.}}"{{/placeholder}} value="{{value}}" {{#readonly}}readonly="readonly"{{/readonly}} {{#disabled}}disabled=1{{/disabled}}/>',
	
	    /**
	     * optional. model attribute to display as label
	     */
	    labelAttr: undefined,
	
	    /**
	     * Value to display as label if no labelAttr
	     */
	    label: undefined,
	
	    /**
	     * model attribute to display and edit
	     */
	    valueAttr: undefined,
	
	    /**
	     * If updateModelOnChange is set, the model is updated on every change
	     */
	    updateModelOnChange: false,
	
	    /**
	     * The view value. It's separate from the model value, and used for rerendering.
	     *
	     * Because it comes from the dom, value is always a string.
	     */
	    value: '',
	
	    /** Text to show when blank */
	    placeholder: undefined,
	
	    /** required, minLength, maxLength, email, cc etc.*/
	    validationRules: undefined,
	
	    /** Template to show when validation fails */
	    validationMessages: {
	      required: 'required',
	      minLength: 'Must be at least {{param0}} chars',
	      maxLength: 'Must not be more than {{param0}} chars',
	      email: 'Not a valid email address',
	      number: 'Must be a number',
	      minValue: 'Must be >= {{param0}}',
	      maxValue: 'Must be <= {{param0}}'
	    },
	
	    /** error, warning, success. Cleared on model load */
	    validationState: undefined,
	
	    /** message to display next to field, eg error message */
	    message: undefined,
	
	
	    constructor: function(options){
	      options = options || {};
	
	      this.validationMessages = _.extend({},this.validationMessages, options.validationMessages);
	      delete options.validationMessages;
	
	      View.apply(this, arguments);
	    },
	
	    /**
	     * An editable view for displaying and editing a single value of a model.
	     *
	     * The value displayed (the view value) is allowed to differ from the model's value
	     * until updateModel is called.
	     *
	     * To automatically update the model on change set updateModelOnChange = true.
	     *
	     * Notes:
	     *  - In order to be used in a Form, Field subclasses must render an input element.
	     *  - The rendered dom also has state. The view value *must* be kept in sync with the
	     *    DOM value in case the field needs to be rerendered. By default this is done by setting
	     *    the view value to the result of getValueFromDom when the DOM value changes.
	     *     - Make sure to override getValueFromDom if your rendered DOM is not an input tag.
	     *  - When triggering a change event, make sure both DOM and backbone events are triggered.
	     *    Since a DOM event triggers a backbone event, do this by triggering a DOM event.
	     *
	     * @constructs
	     * @extends Plumage.view.ModelView
	     */
	    initialize: function(options) {
	      this.validationMessages = _.extend({},this.validationMessages, options.validationMessages);
	      delete options.validationMessages;
	
	      ModelView.prototype.initialize.apply(this, arguments);
	      this.className = this.className ? this.className + ' field' : 'field';
	    },
	
	    onRender: function() {
	      var inputEl = this.getInputEl();
	      var hasFocus = inputEl ? inputEl.is(':focus') : false;
	      Handlebars.registerPartial('field', this.fieldTemplate);
	      ModelView.prototype.onRender.apply(this, arguments);
	
	      this.$el.addClass(this.validationState);
	
	      inputEl = this.getInputEl();
	      if (inputEl && hasFocus) {
	        inputEl.focus();
	      }
	    },
	
	    // This implementation avoids rerendering (and losing cursor position),
	    // however, it has to be overridden frequently.
	    // Maybe move this into a subclass TextField?
	    update: function(isLoad) {
	      if (this.isRendered) {
	        var val = this.getInputEl().val(),
	          newVal = this.processValueForDom(this.getValue());
	        if (val !== newVal) {
	          this.getInputEl().val(newVal);
	        }
	      } else {
	        this.render();
	      }
	    },
	
	    //
	    // Init Events
	    //
	
	    delegateEvents: function(events) {
	      events = events || _.result(this, 'events');
	      var selector = this.getInputSelector();
	      if (selector) {
	        events = _.clone(events || {});
	        events['blur ' +selector] = 'onBlur';
	        events['focus ' +selector] = 'onFocus';
	        events['submit ' +selector] = 'onSubmit';
	        events['change ' +selector] = 'onChange';
	        events['input ' +selector] = 'onInput'; //for text fields
	        events['keydown ' +selector] = 'onKeyDown'; //detect enter/escape etc
	        events['mouseup ' +selector] = 'onChange'; //for select/checkbox etc
	      }
	      Backbone.View.prototype.delegateEvents.apply(this, [events]);
	    },
	
	    undelegateEvents: function() {
	      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
	      var inputEl = this.getInputEl();
	      if (inputEl) {
	        inputEl.off('.field');
	      }
	    },
	
	    getInputSelector: function() {
	      return this.$el.is(':input') ? '' : ':input:first';
	    },
	
	    getInputEl: function() {
	      var selector = this.getInputSelector();
	      return selector ? this.$(selector).first() : this.$el;
	    },
	
	    hasValue: function() {
	      var value = this.getValue();
	      return value !== null && value !== undefined && value !== '';
	    },
	
	    //
	    // Modifiers
	    //
	
	    focus: function() {
	      this.getInputEl().focus();
	    },
	
	    setDisabled: function(disabled) {
	      if (this.disabled !== disabled) {
	        this.disabled = disabled;
	        this.render();
	      }
	    },
	
	    //
	    // Overrides
	    //
	
	    getTemplateData: function() {
	      var data = {
	        fieldType: this.fieldType,
	        label: this.getLabel(),
	        valueAttr: this.valueAttr,
	        value: this.processValueForDom(this.getValue()),
	        hasValue: this.hasValue(),
	        placeholder: this.placeholder,
	        readonly: this.readonly,
	        disabled: this.disabled,
	        validationState: this.validationState,
	        message: this.message
	      };
	      return data;
	    },
	
	    setModel: function() {
	      ModelView.prototype.setModel.apply(this, arguments);
	      this.setValidationState(null, null);
	      this.updateValueFromModel();
	    },
	
	    ensureData: function() {
	      ModelView.prototype.ensureData.apply(this, arguments);
	    },
	
	    //
	    // Attributes
	    //
	
	    getValue: function() {
	      return this.value;
	    },
	
	    processValueForDom: function(value) {
	      return value;
	    },
	
	    /**
	     * updates the field value, and triggers change (both plumage and dom events)
	     *
	     * Note: This is not the only path to change the field value. The field value can also be changed by
	     * updateValueFromModel, so do not update non-model view state here. Do that in valueChanged.
	     */
	    setValue: function(newValue, options) {
	      options = options || {};
	      if (this.getValue() === newValue) {
	        return;
	      }
	      this.value = newValue;
	
	      if (this.updateModelOnChange && this.model) {
	        this.updateModel(this.rootModel);
	      } else {
	        this.update();
	      }
	
	      this.valueChanged();
	
	      if (!options.silent) {
	        this.changing = true;
	        this.trigger('change', this, this.getValue());
	
	        //for catching in form
	        this.triggerChange();
	        this.changing = false;
	      }
	    },
	
	    getLabel: function() {
	      if (this.labelAttr) {
	        return this.model ? this.model.get(this.labelAttr) : null;
	      }
	      return this.label;
	    },
	
	    blur: function() {
	      this.$el.blur();
	    },
	
	    onShow: function() {
	      ModelView.prototype.onShow.apply(this, arguments);
	    },
	
	    //
	    // Validation
	    //
	
	    validators: {
	      required: function(value, params) {
	        return value !== undefined && value !== null && value !== '';
	      },
	      minLength: function(value, params) {
	        return value.length >= params;
	      },
	      maxLength: function(value, params) {
	        return value.length <= params;
	      },
	      email: function(value) {
	        return value ? (/^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/).test(value) : true;
	      },
	      number: function(value) {
	        return !isNaN(value) && !isNaN(Number(value));
	      },
	      minValue: function(value, params) {
	        return value >= params[0];
	      },
	      maxValue: function(value, params) {
	        return value <= params[0];
	      }
	    },
	
	    setValidationState: function(state, message) {
	      if (this.validationState) {
	        this.$el.removeClass(this.validationState);
	      }
	      this.validationState = state;
	      this.message = message;
	
	      this.$el.addClass(this.validationState);
	      this.$('.help-inline').html(this.message);
	    },
	
	    validate: function() {
	      return this.validateValue(this.getValue());
	    },
	
	    validateValue: function(value) {
	      var rules = this.validationRules;
	
	      if (rules) {
	        if (!$.isPlainObject(rules)) {
	          //eg 'required'
	          var newRules = {};
	          newRules[rules] = true;
	          rules = newRules;
	        }
	
	        var success = true;
	        //check required first
	        if (rules.required) {
	          success = this.applyValidator(value, rules.required, 'required');
	        }
	        if (success) {
	          _.keys(rules).every(function(k) {
	            if (k === 'required') {
	              return true;
	            }
	            return success = this.applyValidator(value, rules[k], k);
	          }.bind(this));
	        }
	        if (success) {
	          this.setValidationState(null,null);
	        }
	        return success;
	      }
	      return true;
	    },
	
	    applyValidator: function(value, params, name) {
	      var validator;
	      if ($.isFunction(params)) {
	        validator = params;
	        params = [];
	      } else {
	        params = $.isArray(params) ? params : [params];
	        validator = this.validators[name];
	      }
	
	      if (!validator(value, params)) {
	        var message = this.getValidationMessage(name, params);
	        this.setValidationState('error', message);
	        return false;
	      }
	      return true;
	    },
	
	    getValidationMessage: function(name, params) {
	      var message = this.validationMessages[name] || 'invalid';
	      return Handlebars.compile(message)(_.object(_.map(params, function(x, i) {return ['param' + i, x];})));
	    },
	
	    ////
	    //
	    // Helpers
	    //
	    ////
	
	
	    //
	    // View value <--> Model
	    //
	
	    isValid: function() {
	      return this.validate();
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.disabled ? null : this.getValue();
	      return model.set(this.valueAttr, value) !== false;
	    },
	
	    updateValueFromModel: function() {
	      this.value = '';
	      if (this.model) {
	        this.value = this.getValueFromModel();
	        this.valueChanged(true);
	
	        if (this.isRendered) {
	          this.update();
	        }
	      }
	    },
	
	    getValueFromModel: function() {
	      if (this.model) {
	        var result = this.model.get(this.valueAttr);
	        return result === undefined ? '' : result;
	      }
	    },
	
	    //
	    // View value <--> DOM value
	    //
	
	    getValueFromDom: function() {
	      var inputEl = this.getInputEl();
	      if (inputEl && inputEl.val) {
	        return inputEl.val();
	      }
	    },
	
	    processDomValue: function(value) {
	      return value;
	    },
	
	    //
	    // Gets current value from model
	    //
	
	    triggerChange: function(query) {
	      //trigger change by blurring to prevent 2nd change event on blur
	      var el = this.getInputEl();
	      if (el.is(':focus')) {
	        el.blur();
	        el.focus();
	      } else {
	        el.change();
	      }
	    },
	
	    /**
	     * Use this to completely disallow invalid values from being set.
	     * this is different from validationRules. If a value doesn't pass isDomValueValid, it will be reverted before
	     * validation happens.
	     */
	    isDomValueValid: function(value) {
	      if (this.updateModelOnChange) {
	        return this.validateValue(value);
	      }
	      return true;
	    },
	
	    updateValueFromDom: function() {
	      var newValue = this.getValueFromDom();
	
	      if (this.isDomValueValid(newValue)) {
	        newValue = this.processDomValue(newValue);
	        if (!this.changing) {
	          this.setValue(newValue, {silent: true});
	        }
	        this.trigger('change', this, this.getValue());
	      } else {
	        this.update();
	      }
	    },
	
	    /**
	     * Hook called when value changes. Useful for keeping view state in sync.
	     * @param {Boolean} fromModel Being called from updateValueFromModel?
	     */
	    valueChanged: function(fromModel) {
	      return;
	    },
	
	    //
	    // Event handlers
	    //
	
	    onChange: function(e) {
	      this.updateValueFromDom();
	    },
	
	    onInput: function(e) {
	      this.updateValueFromDom();
	    },
	
	    onKeyDown: function(e) {
	      //do nothing
	    },
	
	    onBlur: function(e) {
	      this.updateValueFromDom();
	      this.validate();
	      this.trigger('blur', this);
	    },
	
	    onFocus: function(e){
	      //do nothing
	    },
	
	    onSubmit: function(e) {
	      this.trigger('submit', this);
	    },
	
	    onModelChange: function (e) {
	      if (e.changed[this.valueAttr] !== undefined) {
	        this.updateValueFromModel();
	      }
	    },
	
	    onModelLoad: function () {
	      this.setValidationState(null, null);
	      this.updateValueFromModel();
	    },
	
	    onModelInvalid: function(model, validationError) {
	      if (validationError) {
	        var message = validationError[this.valueAttr];
	        if (message) {
	          if ($.isArray(message)) {
	            message = message[0];
	          }
	          this.setValidationState('error', message);
	        }
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(92),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Spinner, Plumage) {
	
	  return Plumage.view.View = Backbone.View.extend(
	  /** @lends Plumage.view.View.prototype */
	  {
	
	    /** Has this view been rendered? */
	    isRendered: false,
	
	    /** Is this view loading (showing loading animation)? */
	    isLoading: false,
	
	    /** Is this view currently shown? */
	    shown: false,
	
	    /** handlebars template string or template function to render. */
	    template: undefined,
	
	    /** If specified, and this view is a top level view,
	     * bodyCls is added to the DOM body when this view is shown by a Controller (and removed when hidden).
	     * See [BaseController.showView]{@link Plumage.controller.BaseController#showView}))
	     */
	    bodyCls: undefined,
	
	    /**
	     * If set, don't render until [onShow]{@link Plumage.view.View#onShow} is called.
	     * Normally a view will be rendered when its parent is rendered.
	     */
	    deferRender: false,
	
	    /**
	     * Options passed into [spin.js]{@link http://fgnass.github.io/spin.js/}
	     */
	    loadingAnimationOptions: undefined,
	
	    //
	    // Life Cycle
	    ///////////////
	
	    constructor: function(options) {
	      options = options || {};
	      _.extend(this, options);
	
	      Backbone.View.apply(this, arguments);
	    },
	
	    /**
	     * View class that renders to a DOM element.
	     * Very basic. Most of the time you'll want to use/extend [ContainerView]{@link Plumage.view.ContainerView} or [ModelView]{@link Plumage.view.ModelView}.
	     *
	     * CAUTION: Do not override [render]{@link Plumage.view.View#render} like you would with a Backbone.View. Override the template method [onRender]{@link Plumage.view.View#onRender} instead.
	     *
	     * In addition to what Backbone.View does, Plumage.view.View adds:
	     *
	     *  - default [onRender]{@link Plumage.view.View#onRender} that renders a handlerbars template with data from [getTemplateData]{@link Plumage.view.View#getTemplateData}.
	     *  - beforeRender and afterRender events and hooks.
	     *  - [deferRender]{@link Plumage.view.View#deferRender} flag which defers rendering until [onShow]{@link Plumage.view.View#onShow} is called. Good for tabs etc which aren't visible initially.
	     *  - [onShow]{@link Plumage.view.View#onShow} and [onHide]{@link Plumage.view.View#onHide} hooks. These are called automatically by [BaseController]{@link Plumage.controller.BaseController}.
	     *
	     * @constructs
	     * @extends Backbone.View
	     */
	    initialize:function (options) {
	      this.template = this.initTemplate(this.template);
	    },
	
	    initTemplate: function(template) {
	      if (typeof(template) === 'string') {
	        template = Handlebars.compile(template);
	      }
	      return template;
	    },
	
	    /** Hook called before render. Does nothing. */
	    beforeRender: function() {
	    },
	
	    /**
	     * Instead of rendering in this method, render triggers render hooks and events, then calls
	     * the template method onRender to do the actual rendering.
	     * @returns this;
	     */
	    render: function() {
	      if (this.deferRender && !this.shown) {
	        return;
	      }
	
	      this.beforeRender();
	      this.trigger('beforeRender', this);
	
	      this.onRender();
	      this.hideLoadingAnimation();
	
	      this.isRendered = true;
	      this.trigger('afterRender', this);
	      return this;
	    },
	
	    /**
	     * Template method that returns data to pass into the handlebars template.
	     *
	     * Override to provide custom data.
	     *
	     * @returns {Object} Map of template data.
	     */
	    getTemplateData: function() {
	      return {};
	    },
	
	    /**
	     * Perform actually rendering here.
	     *
	     * Default implementation renders [template]{@link Plumage.view.View#template}
	     * with data from [getTemplateData]{@link Plumage.view.View#getTemplateData}.
	     */
	    onRender:function () {
	      if (this.template) {
	        var data = this.getTemplateData();
	        $(this.el).html(this.template(data));
	      }
	    },
	
	    /**
	     * Update when already rendered.
	     * Default to just render again, but can be made more efficient by only updating what's changed.
	     *
	     * @param {Boolean} isLoad Context of update. True if loading, false if changing.
	     */
	    update: function(isLoad) {
	      this.render();
	    },
	
	    remove: function() {
	      Backbone.View.prototype.remove.apply(this, arguments);
	      this.hideLoadingAnimation();
	      return this;
	    },
	
	    /**
	     * Hook called when this view is shown.
	     *
	     * Sets the shown flag, triggers deferred rendering and delegates events.
	     *
	     * If overriding, make sure to call super.
	     */
	    onShow: function() {
	      this.shown = true;
	      if (this.deferRender && !this.isRendered) {
	        this.render();
	      }
	      this.delegateEvents();
	    },
	
	
	    /**
	     * Hook called when this view is hidden.
	     *
	     * Unsets the shown flag, hides loading animation and undelegates events.
	     *
	     * If overriding, make sure to call super.
	     */
	    onHide: function() {
	      if (this.shown) {
	        this.undelegateEvents();
	        this.shown = false;
	      }
	      this.hideLoadingAnimation();
	    },
	
	    /**
	     * Handle link clicks by triggering navigate on the Router instead of reloading the page.
	     * Not used by default. Add to events if necessary.
	     */
	    onLinkClick: function(e) {
	      var a = $(e.target).closest('a');
	      if (!a.hasClass('outlink')) {
	        e.preventDefault();
	        e.stopPropagation();
	        var url = a.prop('pathname') + a.prop('search');
	        window.router.navigateWithQueryParams(url, {trigger:true});
	      }
	    },
	
	    /**
	     * Handle anchor clicks by scrolling to the anchor in the page element.
	     * Necessary because body has height: 100%
	     */
	    onAnchorClick: function(e) {
	      e.preventDefault();
	      var a = $(e.target).closest('a');
	      var href = a.attr('href'); //should already have #
	      $('#page').animate({scrollTop: $(href).offset().top - 50}, 400);
	    },
	
	    callOrRecurse: function(methodName, params) {
	      if (this[methodName]) {
	        return this[methodName].apply(this, params);
	      }
	      return true;
	    },
	
	    /** Show the loading animation. Uses spin.js */
	    showLoadingAnimation: function() {
	      var width = $(this.el).width(), height = $(this.el).height();
	      if (!this.isRendered || width === 0 && height === 0) {
	        this.on('afterRender', this.showLoadingAnimation.bind(this));
	        return;
	      }
	
	      var opts = {
	          lines: 13, // The number of lines to draw
	          length: 7, // The length of each line
	          width: 4, // The line thickness
	          radius: 10, // The radius of the inner circle
	          corners: 1, // Corner roundness (0..1)
	          rotate: 0, // The rotation offset
	          color: '#000', // #rgb or #rrggbb
	          speed: 1, // Rounds per second
	          trail: 60, // Afterglow percentage
	          shadow: false, // Whether to render a shadow
	          hwaccel: false, // Whether to use hardware acceleration
	          className: 'spinner', // The CSS class to assign to the spinner
	          zIndex: 2e9, // The z-index (defaults to 2000000000)
	          top: 'auto', // Top position relative to parent in px
	          left: 'auto' // Left position relative to parent in px
	        };
	
	      opts = _.extend(opts, this.loadingAnimationOptions);
	
	      var offset = $(this.el).offset();
	      if(!this.loader){
	        this.loader = $('<div class="loader"> <div class="spinner-box"></div> </div>');
	        $('body').append(this.loader);
	        this.spinner = new Spinner(opts);
	      }
	      this.spinner.spin($('.spinner-box', this.loader)[0]);
	      this.loader.css({
	        left: offset.left,
	        top: offset.top,
	        width: width,
	        height: height
	      });
	      this.loader.show();
	      this.spinner.spin($('.spinner-box', this.loader)[0]);
	      this.isLoading = true;
	    },
	
	    /** Hide the loading animation. */
	    hideLoadingAnimation: function() {
	      this.off('afterRender', this.showLoadingAnimation.bind(this));
	      if(this.loader){
	        this.loader.fadeOut('fast', function() {
	          this.spinner.stop();
	        }.bind(this));
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2011-2013 Felix Gnass
	 * Licensed under the MIT license
	 */
	(function(root, factory) {
	
	  /* CommonJS */
	  if (true)  module.exports = factory()
	
	  /* AMD module */
	  else if (typeof define == 'function' && define.amd) define(factory)
	
	  /* Browser global */
	  else root.Spinner = factory()
	}
	(this, function() {
	  "use strict";
	
	  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
	    , animations = {} /* Animation rules keyed by their name */
	    , useCssAnimations /* Whether to use CSS animations or setTimeout */
	
	  /**
	   * Utility function to create elements. If no tag name is given,
	   * a DIV is created. Optionally properties can be passed.
	   */
	  function createEl(tag, prop) {
	    var el = document.createElement(tag || 'div')
	      , n
	
	    for(n in prop) el[n] = prop[n]
	    return el
	  }
	
	  /**
	   * Appends children and returns the parent.
	   */
	  function ins(parent /* child1, child2, ...*/) {
	    for (var i=1, n=arguments.length; i<n; i++)
	      parent.appendChild(arguments[i])
	
	    return parent
	  }
	
	  /**
	   * Insert a new stylesheet to hold the @keyframe or VML rules.
	   */
	  var sheet = (function() {
	    var el = createEl('style', {type : 'text/css'})
	    ins(document.getElementsByTagName('head')[0], el)
	    return el.sheet || el.styleSheet
	  }())
	
	  /**
	   * Creates an opacity keyframe animation rule and returns its name.
	   * Since most mobile Webkits have timing issues with animation-delay,
	   * we create separate rules for each line/segment.
	   */
	  function addAnimation(alpha, trail, i, lines) {
	    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
	      , start = 0.01 + i/lines * 100
	      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
	      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
	      , pre = prefix && '-' + prefix + '-' || ''
	
	    if (!animations[name]) {
	      sheet.insertRule(
	        '@' + pre + 'keyframes ' + name + '{' +
	        '0%{opacity:' + z + '}' +
	        start + '%{opacity:' + alpha + '}' +
	        (start+0.01) + '%{opacity:1}' +
	        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
	        '100%{opacity:' + z + '}' +
	        '}', sheet.cssRules.length)
	
	      animations[name] = 1
	    }
	
	    return name
	  }
	
	  /**
	   * Tries various vendor prefixes and returns the first supported property.
	   */
	  function vendor(el, prop) {
	    var s = el.style
	      , pp
	      , i
	
	    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
	    for(i=0; i<prefixes.length; i++) {
	      pp = prefixes[i]+prop
	      if(s[pp] !== undefined) return pp
	    }
	    if(s[prop] !== undefined) return prop
	  }
	
	  /**
	   * Sets multiple style properties at once.
	   */
	  function css(el, prop) {
	    for (var n in prop)
	      el.style[vendor(el, n)||n] = prop[n]
	
	    return el
	  }
	
	  /**
	   * Fills in default values.
	   */
	  function merge(obj) {
	    for (var i=1; i < arguments.length; i++) {
	      var def = arguments[i]
	      for (var n in def)
	        if (obj[n] === undefined) obj[n] = def[n]
	    }
	    return obj
	  }
	
	  /**
	   * Returns the absolute page-offset of the given element.
	   */
	  function pos(el) {
	    var o = { x:el.offsetLeft, y:el.offsetTop }
	    while((el = el.offsetParent))
	      o.x+=el.offsetLeft, o.y+=el.offsetTop
	
	    return o
	  }
	
	  /**
	   * Returns the line color from the given string or array.
	   */
	  function getColor(color, idx) {
	    return typeof color == 'string' ? color : color[idx % color.length]
	  }
	
	  // Built-in defaults
	
	  var defaults = {
	    lines: 12,            // The number of lines to draw
	    length: 7,            // The length of each line
	    width: 5,             // The line thickness
	    radius: 10,           // The radius of the inner circle
	    rotate: 0,            // Rotation offset
	    corners: 1,           // Roundness (0..1)
	    color: '#000',        // #rgb or #rrggbb
	    direction: 1,         // 1: clockwise, -1: counterclockwise
	    speed: 1,             // Rounds per second
	    trail: 100,           // Afterglow percentage
	    opacity: 1/4,         // Opacity of the lines
	    fps: 20,              // Frames per second when using setTimeout()
	    zIndex: 2e9,          // Use a high z-index by default
	    className: 'spinner', // CSS class to assign to the element
	    top: 'auto',          // center vertically
	    left: 'auto',         // center horizontally
	    position: 'relative'  // element position
	  }
	
	  /** The constructor */
	  function Spinner(o) {
	    if (typeof this == 'undefined') return new Spinner(o)
	    this.opts = merge(o || {}, Spinner.defaults, defaults)
	  }
	
	  // Global defaults that override the built-ins:
	  Spinner.defaults = {}
	
	  merge(Spinner.prototype, {
	
	    /**
	     * Adds the spinner to the given target element. If this instance is already
	     * spinning, it is automatically removed from its previous target b calling
	     * stop() internally.
	     */
	    spin: function(target) {
	      this.stop()
	
	      var self = this
	        , o = self.opts
	        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})
	        , mid = o.radius+o.length+o.width
	        , ep // element position
	        , tp // target position
	
	      if (target) {
	        target.insertBefore(el, target.firstChild||null)
	        tp = pos(target)
	        ep = pos(el)
	        css(el, {
	          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',
	          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'
	        })
	      }
	
	      el.setAttribute('role', 'progressbar')
	      self.lines(el, self.opts)
	
	      if (!useCssAnimations) {
	        // No CSS animation support, use setTimeout() instead
	        var i = 0
	          , start = (o.lines - 1) * (1 - o.direction) / 2
	          , alpha
	          , fps = o.fps
	          , f = fps/o.speed
	          , ostep = (1-o.opacity) / (f*o.trail / 100)
	          , astep = f/o.lines
	
	        ;(function anim() {
	          i++;
	          for (var j = 0; j < o.lines; j++) {
	            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)
	
	            self.opacity(el, j * o.direction + start, alpha, o)
	          }
	          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))
	        })()
	      }
	      return self
	    },
	
	    /**
	     * Stops and removes the Spinner.
	     */
	    stop: function() {
	      var el = this.el
	      if (el) {
	        clearTimeout(this.timeout)
	        if (el.parentNode) el.parentNode.removeChild(el)
	        this.el = undefined
	      }
	      return this
	    },
	
	    /**
	     * Internal method that draws the individual lines. Will be overwritten
	     * in VML fallback mode below.
	     */
	    lines: function(el, o) {
	      var i = 0
	        , start = (o.lines - 1) * (1 - o.direction) / 2
	        , seg
	
	      function fill(color, shadow) {
	        return css(createEl(), {
	          position: 'absolute',
	          width: (o.length+o.width) + 'px',
	          height: o.width + 'px',
	          background: color,
	          boxShadow: shadow,
	          transformOrigin: 'left',
	          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',
	          borderRadius: (o.corners * o.width>>1) + 'px'
	        })
	      }
	
	      for (; i < o.lines; i++) {
	        seg = css(createEl(), {
	          position: 'absolute',
	          top: 1+~(o.width/2) + 'px',
	          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
	          opacity: o.opacity,
	          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'
	        })
	
	        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))
	        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
	      }
	      return el
	    },
	
	    /**
	     * Internal method that adjusts the opacity of a single line.
	     * Will be overwritten in VML fallback mode below.
	     */
	    opacity: function(el, i, val) {
	      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
	    }
	
	  })
	
	
	  function initVML() {
	
	    /* Utility function to create a VML tag */
	    function vml(tag, attr) {
	      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
	    }
	
	    // No CSS transforms but VML support, add a CSS rule for VML elements:
	    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')
	
	    Spinner.prototype.lines = function(el, o) {
	      var r = o.length+o.width
	        , s = 2*r
	
	      function grp() {
	        return css(
	          vml('group', {
	            coordsize: s + ' ' + s,
	            coordorigin: -r + ' ' + -r
	          }),
	          { width: s, height: s }
	        )
	      }
	
	      var margin = -(o.width+o.length)*2 + 'px'
	        , g = css(grp(), {position: 'absolute', top: margin, left: margin})
	        , i
	
	      function seg(i, dx, filter) {
	        ins(g,
	          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),
	            ins(css(vml('roundrect', {arcsize: o.corners}), {
	                width: r,
	                height: o.width,
	                left: o.radius,
	                top: -o.width>>1,
	                filter: filter
	              }),
	              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),
	              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
	            )
	          )
	        )
	      }
	
	      if (o.shadow)
	        for (i = 1; i <= o.lines; i++)
	          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')
	
	      for (i = 1; i <= o.lines; i++) seg(i)
	      return ins(el, g)
	    }
	
	    Spinner.prototype.opacity = function(el, i, val, o) {
	      var c = el.firstChild
	      o = o.shadow && o.lines || 0
	      if (c && i+o < c.childNodes.length) {
	        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild
	        if (c) c.opacity = val
	      }
	    }
	  }
	
	  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})
	
	  if (!vendor(probe, 'transform') && probe.adj) initVML()
	  else useCssAnimations = vendor(probe, 'animation')
	
	  return Spinner
	
	}));


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(91),
	  __webpack_require__(94),
	  __webpack_require__(95),
	  __webpack_require__(96),
	  __webpack_require__(97)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, View, ContainerView, ModelUtil, ViewBuilder, errorTemplate) {
	
	
	
	  return Plumage.view.ModelView = ContainerView.extend(
	  /** @lends Plumage.view.ModelView.prototype */
	  {
	
	    /**
	     * Class of model to bind to. Ignores all other models passed into setModel.
	     *
	     * Useful for preventing a subView from getting bound to a superview's model.
	     */
	    modelCls: undefined,
	
	    /**
	     * The relationship path in the root model to get the model for this view.
	     *
	     * Doesn't support dot notation but should at some point.
	     */
	    relationship: undefined,
	
	    /**
	     * Should [render]{@link Plumage.view.View#render} by called on model change?
	     *
	     * If left unset, update will be called on change only if this view has no subViews.
	     */
	    renderOnChange: undefined,
	
	
	    /**
	     * Should [render]{@link Plumage.view.View#render} by called on model load?
	     *
	     * If left unset, update will be called on load only if this view has no subViews.
	     */
	    renderOnLoad: undefined,
	
	    /**
	     * Instead of a View, ModelView can take config object as a subView, and instantiate
	     * a View from it. If no viewCls is specified, defaultSubViewCls is used.
	     */
	    defaultSubViewCls: undefined,
	
	    defaultSubViewOptions: undefined,
	
	    /**
	     * Adding to the functionality of ConainerView, ModelView supports binding of Models to it.
	     *
	     * This is the default View to use. Most of the time you should be
	     * binding models to your views.
	     *
	     * Bind a [Model]{@link Plumage.model.Model} to ModelView using [setModel]{@link Plumage.view.ModelView#setModel}.
	     * This will connect the various model events, with some default handling, eg render on load.
	     *
	     * setModel is a [ContainerView]{@link Plumage.view.ContainerView} composite method.
	     * i.e. calling setModel on the root ModelView will recursively call setModel with the same model object
	     * on all child ModelViews.
	     *
	     *  - A child ModelView can specify which part of the model to bind to using the [relationship]{@link Plumage.view.ModelView#relationship}
	     *    param (leave it blank to have it bind to the root model).
	     *  - If a child ModelView should only be bound to a certain Model class, specifiy
	     *    [modelCls]{@link Plumage.view.ModelView#modelCls} with the Model class to restrict it to.
	     *
	     *    eg. a child view might be located under a parent ModelView in the DOM, but not be related in the data
	     *    structure. In this case set modelCls on the child so it doesn't get the parent's Model set on it.
	     *
	     * ModelView also uses ViewBuilder automatically, for intantiating subviews. If passed a config
	     * object instead of a View in subViews, it will be instantiated by ViewBuilder.
	     *
	     * @constructs
	     * @extends Plumage.view.ContainerView
	     */
	    initialize:function (options) {
	      ContainerView.prototype.initialize.apply(this, arguments);
	
	      this.buildSubViews();
	
	      //Backbone.View constructor will already set model if it's passed in.
	      if (this.model) {
	        throw 'Do not pass model into constructor. call setModel';
	      }
	    },
	
	    buildSubViews: function() {
	      if (this.subViews === undefined) {
	        return;
	      }
	
	      var viewBuilder = new ViewBuilder({
	        defaultViewCls: this.defaultSubViewCls || View,
	        defaultViewOptions: this.defaultSubViewOptions
	      });
	
	      this.subViews = _.map(this.subViews, function(subView) {
	        return viewBuilder.buildView(subView);
	      }.bind(this));
	    },
	
	    /**
	     * Gets model to bind to from the root model.
	     * @param {Plumage.model.Model} model The root model.
	     * @param {string} relationship The relationship path in the root model to get the model for this view.
	     */
	    getModelFromRoot: function(relationship, model, parentModel) {
	      if (!model) {
	        return;
	      }
	      if (!relationship) {
	        return model;
	      }
	
	      if (relationship.slice(0,1) === '.') {
	        if (parentModel) {
	          return parentModel.getRelated(relationship.slice(1));
	        }
	        return undefined;
	      }
	
	      return model.getRelated(relationship);
	    },
	
	    //
	    // Life Cycle
	    //
	
	    /**
	     * Bind a model if applicable. Call setModel on your top level view in your Controller.
	     *
	     * Calls onModelLoad if the model has changed (set model != this.model) and is already loaded.
	     *
	     * @params {Plumage.model.Model} rootModel The root model
	     * @params {Plumage.model.Model} parentModel The model the parent view bound to. For relative relationships.
	     * @params {Boolean} force Ignore modelCls. Normally used when modelCls = false.
	     */
	    setModel: function(rootModel, parentModel, force) {
	      if (!force) {
	        if (this.rootModelCls && rootModel) {
	          if (!(rootModel instanceof this.rootModelCls)) {
	            return;
	          }
	        }
	        this.rootModel = rootModel;
	      }
	
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        changed = true;
	      if (!force && this.modelCls !== undefined) {
	        if (this.modelCls === false) {
	          return;
	        }
	        if (model && !(model instanceof this.modelCls)) {
	          return;
	        }
	      }
	
	      if (model && this.model &&
	          model.id !== undefined && this.model.id !== undefined && model.id === this.model.id) {
	        changed = false;
	      }
	      if (this.model) {
	        this.model.off(null,null,this);
	      }
	      this.model = model;
	      if (this.model) {
	        this.model.on('beginLoad', this.onModelBeginLoad, this);
	        this.model.on('change', this.onModelChange, this);
	        this.model.on('load', this.onModelLoad, this);
	        this.model.on('add', this.onModelAdd, this);
	        this.model.on('remove', this.onModelRemove, this);
	        this.model.on('destroy', this.onModelDestroy, this);
	        this.model.on('invalid', this.onModelInvalid, this);
	        this.model.on('error', this.onModelError, this);
	
	        if (changed && this.model && this.model.fetched) {
	          this.onModelLoad();
	        }
	
	        if (this.shown) {
	          this.ensureData();
	        }
	      }
	
	
	
	      //recurse
	      this.eachSubView(function(subView) {
	        subView.callOrRecurse('setModel', [rootModel, this.model]);
	      }.bind(this));
	    },
	
	    /** triggers loading of loadOnShow Models. */
	    ensureData: function() {
	      if (this.model && this.model.loadOnShow) {
	        if(!this.model.fetched) {
	          this.model.fetchIfAvailable();
	        }
	        delete this.model.loadOnShow;
	      }
	    },
	
	    /**
	     * Provides template data to render with.
	     *
	     * ModelView's implemenation returns the result of this.model.toViewJSON
	     * @override
	     */
	    getTemplateData: function() {
	      if (this.model) {
	        return this.model.toViewJSON();
	      }
	      return {};
	    },
	
	    /**
	     * Update given model with any changes eg from forms
	     * @param {Plumage.model.Model} model Model to update.
	     */
	    updateModel: function(rootModel, parentModel) {
	      var success = true;
	      this.eachSubView(function(subView) {
	        success = subView.callOrRecurse('updateModel', [rootModel, this.model]) && success;
	      });
	      return success;
	    },
	
	    isValid: function(rootModel, parentModel) {
	      var valid = true;
	      this.eachSubView(function(subView) {
	        valid = subView.callOrRecurse('isValid', [rootModel, this.model]) && valid;
	      });
	      return valid;
	    },
	
	    /** Hook to modify view state on model load */
	    updateViewState: function(model) {
	
	    },
	
	    hideLoadingAnimation: function() {
	      ContainerView.prototype.hideLoadingAnimation.apply(this, arguments);
	    },
	
	    shouldRender: function(isLoad) {
	      var hasSubViews = this.subViews && this.subViews.length > 0;
	      var shouldRenderFlag = isLoad ? this.renderOnLoad : this.renderOnChange;
	      return shouldRenderFlag !== undefined && shouldRenderFlag ||
	        shouldRenderFlag === undefined && !hasSubViews;
	    },
	
	    update: function(isLoad) {
	      if (this.isRendered && this.shouldRender(isLoad)) {
	        this.render();
	      }
	    },
	
	    //
	    // Event Handlers
	    //
	
	    onModelBeginLoad: function() {
	      this.loading = true;
	    },
	
	    onModelChange: function(event, model) {
	      this.update(false);
	    },
	
	    onModelLoad: function(model, options) {
	      this.loading = false;
	      this.updateViewState(model);
	      this.update(true);
	      this.hideLoadingAnimation();
	    },
	
	    onModelAdd: function(event, model) {
	      this.onModelChange(event, model);
	    },
	
	    onModelRemove: function(event, model) {
	      this.onModelChange(event, model);
	    },
	
	    onModelDestroy: function(event, model) {
	    },
	
	    onModelInvalid: function(model, validationErrors) {
	    },
	
	    onModelError: function(model, response, options) {
	      $(this.el).html(Handlebars.compile(errorTemplate)(options.data));
	
	      //needs rerendering after rendering error template
	      this.isRendered = false;
	    },
	
	    remove: function() {
	      ContainerView.prototype.remove.apply(this, arguments);
	      if (this.model) {
	        this.model.off(null, null, this);
	      }
	      return this;
	    },
	
	    onShow: function() {
	      ContainerView.prototype.onShow.apply(this, arguments);
	      this.ensureData();
	    },
	
	    onHide: function() {
	      ContainerView.prototype.onHide.apply(this, arguments);
	    },
	
	    /** override to short circuit changes to view state only */
	    onLinkClick: function(e) {
	      var a = $(e.target).closest('a');
	      if (!a.hasClass('outlink')) {
	        if (a.attr('href')[0] === '?') {
	          e.preventDefault();
	          e.stopPropagation();
	          var params = ModelUtil.parseQueryString(a.attr('href').slice(1));
	          this.model.set(params);
	          this.model.updateUrl({replace: false});
	        } else {
	          ContainerView.prototype.onLinkClick.apply(this, arguments);
	        }
	      }
	    },
	
	    delegateEvents: function(events) {
	      Backbone.View.prototype.delegateEvents.apply(this, arguments);
	    },
	
	    undelegateEvents: function(events) {
	      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(91),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, View) {
	
	  return Plumage.view.ContainerView = View.extend(
	  /** @lends Plumage.view.ContainerView.prototype */
	  {
	
	    /** Array of subViews. */
	    subViews: undefined,
	
	    rootModelCls: undefined,
	
	    /**
	     * View that contains subViews.
	     *
	     * Implements composite pattern, i.e. calling render on ContainerView will call render
	     * on all it's subViews and their subViews etc, in depth first order.
	     *
	     * Composite methods like render must call super to ensure recursion.
	     *
	     * To add a new compositable method (eg updateModel) add it to the ContainerView subclass,
	     * and use callOrRecurse to propagate the call even when some subViews don't have the new method.
	     * This allows adding new methods without having to have every view implement them.
	     * @constructs
	     * @extends Plumage.view.View
	     */
	    initialize:function (options) {
	      View.prototype.initialize.apply(this, arguments);
	    },
	
	    buildSubViews: function() {
	      if (this.subViews === undefined) {
	        return;
	      }
	
	      var viewBuilder = new ViewBuilder({
	        defaultViewCls: this.defaultSubViewCls || ContainerView,
	        defaultViewOptions: this.defaultSubViewOptions
	      });
	
	      this.subViews = _.map(this.subViews, function(subView) {
	        return viewBuilder.buildView(subView);
	      }.bind(this));
	    },
	
	    /**
	     * Get subView by name
	     */
	    getSubView: function(name) {
	      var result = this.doGetSubView(name);
	      if (!result) {
	        console.warn('Failed getting subview with name: ' + name);
	      }
	      return result;
	    },
	
	    doGetSubView: function(name) {
	      var names = typeof(name) === 'string' ? name.split('.') : name;
	      if (!names) {
	        return undefined;
	      }
	      var result = _.findWhere(this.subViews, {name: names[0]});
	      names.shift();
	      if (result && names.length) {
	        result = result.doGetSubView(names);
	      }
	      return result;
	    },
	
	    /**
	     * Detach rendered subviews so they don't get clobbered.
	     * @override
	     */
	    beforeRender: function() {
	      this.eachSubView(function(subView, selector) {
	        if(subView.isRendered) {
	          subView.$el.detach();
	        }
	      });
	    },
	
	    /**
	     * Composite method.
	     * Triggers render events, calls onRender, and recurses to subviews.
	     * @override
	     */
	    render: function() {
	      if (this.deferRender && !this.shown) {
	        return;
	      }
	      this.beforeRender();
	      this.trigger('beforeRender', this);
	
	      this.onRender();
	      this.renderSubViews();
	
	      this.isRendered = true;
	      this.trigger('afterRender', this);
	      return this;
	    },
	
	    onRender: function() {
	      View.prototype.onRender.apply(this, arguments);
	    },
	
	    /**
	     * Render and add subViews to this.el based on their selector property.
	     */
	    renderSubViews: function() {
	      var me = this;
	      this.eachSubView(function(subView) {
	        if (subView.replaceEl) {
	          subView.setElement(me.$(subView.selector)[0]);
	          if (subView.className) {
	            subView.$el.addClass(subView.className);
	          }
	          subView.render();
	        } else {
	          var containerEl = me.$el;
	          if (subView.selector) {
	            containerEl = me.$(subView.selector);
	          }
	          subView.render();
	          if (subView.el) {
	            containerEl.append(subView.el);
	          }
	        }
	      });
	    },
	
	    remove: function() {
	      View.prototype.remove.apply(this, arguments);
	      return this;
	    },
	
	    hideLoadingAnimation: function() {
	      View.prototype.hideLoadingAnimation.apply(this, arguments);
	    },
	
	
	    //
	    // Hooks
	    //
	
	    /**
	     * Composite method.
	     * @override
	     */
	    onShow: function() {
	      View.prototype.onShow.apply(this, arguments);
	      this.eachSubView(function(subView) {
	        subView.onShow();
	      });
	    },
	
	    /**
	     * Composite method.
	     * @override
	     */
	    onHide: function() {
	      View.prototype.onHide.apply(this, arguments);
	      this.eachSubView(function(subView) {
	        subView.onHide();
	      });
	    },
	
	    onLinkClick: function(e) {
	      View.prototype.onLinkClick.apply(this, arguments);
	    },
	
	    //
	    // Util
	    //
	
	    /**
	     * Helper method that calls a callback with each subView.
	     * @param {function} callback Callback to call on each subView
	     * @param {Object} scope Scope for callback. or just use bind.
	     */
	    eachSubView: function(callback, scope) {
	      _.each(this.subViews, function(subView) {
	        if (scope) {
	          callback.call(scope, subView);
	        } else {
	          callback(subView);
	        }
	      }, this);
	    },
	
	    /**
	     * Calls a method on ContainerView if it exists or calls it on its subViews.
	     * Eliminates need for ContainerView to know about composite methods provided by subclasses.
	     * @param {string} methodName Name of method to call.
	     * @param {Array} params Params to pass into method.
	     */
	    callOrRecurse: function(methodName, params) {
	      if (this[methodName]) {
	        return this[methodName].apply(this, params);
	      } else {
	        var success = true;
	        this.eachSubView(function(subView) {
	          success = subView.callOrRecurse(methodName, params) && success;
	        });
	        return success;
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1), __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Plumage) {
	  return Plumage.util.ModelUtil = {
	
	    /**
	     * Merge options arguments with class values, including deeper prototypes if specified
	     * @param {string} name Name of option to merge
	     * @param {Model} model Model to set the option on
	     * @param {object} options Options argument
	     * @param {boolean} deep Merge deeper prototype values?
	     */
	    mergeOption: function(name, model, options, deep) {
	
	      var args = [options[name] || {}];
	
	      if (deep) {
	        var proto = model;
	        while (proto) {
	          if (proto.hasOwnProperty(name)) {
	            args.unshift(proto[name]);
	          }
	          proto = Object.getPrototypeOf(proto);
	        }
	      } else {
	        args.unshift(model[name] || {});
	      }
	      var result = $.extend.apply(null, [true, {}].concat(args));
	      delete options[name];
	      model[name] = result;
	    },
	
	    parseQueryString: function(queryString) {
	      if (!queryString) {
	        return undefined;
	      }
	      var result = {};
	      queryString = decodeURIComponent(queryString.replace(/\+/g, '%20'));
	      if(queryString) {
	        $.each(queryString.split('&'), function(index, value) {
	          if(value) {
	            var param = value.split('=');
	            result[param[0]] = param[1];
	          }
	        });
	      }
	      return result;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(3), __webpack_require__(2),
	  __webpack_require__(88), __webpack_require__(91)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage,
	  View
	) {
	
	  var ViewBuilder = function() {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(ViewBuilder.prototype,
	  /** @lends Plumage.ViewBuilder.prototype */
	  {
	    defaultViewCls: undefined,
	    defaultViewOptions: undefined,
	
	    initialize: function(options) {
	      options = options || {};
	      _.extend(this, options);
	    },
	
	    buildView: function(config) {
	      if (config instanceof View) {
	        return config;
	      }
	
	      config = _.extend({}, this.defaultViewOptions, config);
	
	      var viewCls = config.viewCls || this.defaultViewCls;
	      if (viewCls === undefined) {
	        throw "No view class";
	      }
	      delete config.viewCls;
	
	      return new viewCls(config);
	    }
	  });
	
	
	  return Plumage.ViewBuilder = ViewBuilder;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"load-error {{#message}}with-message{{/message}}\">\n  <div class=\"error-icon\">&times;</div>\n  <div class=\"error-text\">\n    <div>Error loading resource</div>\n    {{#message}}\n      <div class=\"message\">{{.}}</div>\n    {{/message}}\n  </div>\n</div>"

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "{{#if label}}\n<label class=\"control-label\" for=\"{{valueAttr}}\">{{label}}</label>\n<div class=\"controls\">\n  <span class=\"field\">{{> field}}</span>\n  <span class=\"help-inline\">{{#if message}}{{message}}{{/if}}</span>\n</div>\n{{else}}\n  {{> field}}\n  <span class=\"help-inline\">{{#if message}}{{message}}{{/if}}</span>\n{{/if}}\n"

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(100),
	  __webpack_require__(93)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model, ModelView) {
	
	  return  Plumage.view.form.fields.picker.Picker = ModelView.extend(
	  /** @lends Plumage.view.form.fields.picker.Picker.prototype */
	  {
	
	
	    modelCls: false, //never bind via setModel
	
	    className: 'dropdown-menu',
	
	    pickerModelAttr: 'value',
	
	    opens: 'right',
	
	    applyOnChange: false,
	
	    events: {
	      'mousedown': 'onMouseDown'
	    },
	
	    defaultSubViewOptions: {
	      updateModelOnChange: true
	    },
	
	    /**
	     * @constructs
	     * @extends Plumage.view.ModelView
	     */
	    initialize: function(options) {
	      this.defaultSubViewOptions = {
	        updateModelOnChange: true,
	        valueAttr: options.pickerModelAttr || this.pickerModelAttr
	      };
	      ModelView.prototype.initialize.apply(this, arguments);
	      this.setModel(new Model({}, {urlRoot: '/'}), null, true);
	    },
	
	    onModelChange: function() {
	      ModelView.prototype.onModelChange.apply(this, arguments);
	      if (this.applyOnChange) {
	        this.trigger('apply', this, this.model);
	      }
	    },
	
	    getValue: function() {
	      return this.model.get(this.pickerModelAttr);
	    },
	
	    setValue: function(value) {
	      this.model.set(this.pickerModelAttr, value);
	    },
	
	    onRender: function() {
	      ModelView.prototype.onRender.apply(this, arguments);
	      this.$el.addClass('opens' + this.opens);
	    },
	
	    getTemplateData: function() {
	      return ModelView.prototype.getTemplateData.apply(this, arguments);
	    },
	
	    update: function() {
	      ModelView.prototype.update.apply(this, arguments);
	    },
	
	    //
	    // Events
	    //
	
	    onMouseDown: function(e) {
	      //do nothing so input doesn't lose focus
	      e.preventDefault();
	      e.stopPropagation();
	    },
	
	    onKeyDown: function(e) {
	      if (e.keyCode === 13) { //on enter
	        e.preventDefault();
	        this.close();
	        this.updateValueFromDom();
	      } else if(e.keyCode === 27) {
	        this.close();
	        this.update();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(101),
	  __webpack_require__(95),
	  __webpack_require__(102)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, requestManager, ModelUtil, BufferedCollection) {
	
	  return Plumage.model.Model = Backbone.Model.extend(
	  /** @lends Plumage.model.Model.prototype */
	  {
	    /**
	     * eg
	     * [{
	     *   addresses: {
	     *     modelCls: Address, forceCreate: true
	     *   }
	     * }]
	     *
	     * params:
	     *  - forceCreate: create the related model even if it doesn't exist in the initial data. This way
	     *      They can be set on views, in preparation for later updates.
	     *  - remote: The related model needs to be loaded after the current model loads. Can be of the values:
	     *     - 'autoload' => Load as soon as url is available.
	     *     - 'loadOnShow' => Load when first shown in a view.
	     *     - 'manual' => Loaded manually.
	     */
	    relationships: {},
	
	    /** actual related model instances */
	    related: undefined,
	
	    queryAttrs: [],
	
	    /** attributes to include in url query params. */
	    viewAttrs: [],
	
	    /** Path where to find the response data in the response JSON.*/
	    resultsPath: 'results',
	
	    /** Attribute to display when shown in a general View, like a title */
	    displayNameAttr: undefined,
	
	    /** Has this Model been loaded yet? */
	    fetched: false,
	
	    /** Criterium for uniqueness is always href */
	    idAttribute: 'href',
	
	    /** field use of for url when href is undefined, ie urlRoot + '/' + urlId */
	    urlIdAttribute: 'id',
	
	
	    /**
	     * Base Model class for Plumage models.
	     *
	     * Based on Backbone.Model, with some interface changes and some additional features.
	     *
	     * #### Life Cycle ####
	     *
	     * ##### Load #####
	     *
	     *  - Create a new instance with the id of the record you want to load.
	     *  - Set the Model on any [ModelViews]{@link Plumage.view.ModelView} you want to bind it to before calling
	     *    load. This allows the views to bind to the Model's load event.
	     *  - Call [load]{@link Plumage.model.Model#load}, to async load model data from the server.
	     *  - On success, the load method [sets]{@link Plumage.model.Model#set} the Model's attributes and instantiates related models
	     *     that maybe been included in the JSON response (see [instantiateRelationship]{@link Plumage.model.Model#instantiateRelationship}).
	     *
	     * ##### Display #####
	     *
	     *  - [ModelViews]{@link Plumage.view.ModelView} will generally render a Model into a template, calling [toViewJSON]{@link Plumage.model.Model#toViewJSON} to get the template params.
	     *
	     * ##### Update #####
	     *
	     *  - Call [set]{@link Plumage.model.Model#set} with new attributes or related model data. Normally done by
	     *    [ModelView.updateModel]{@link Plumage.view.ModelView#updateModel}.
	     *  - This triggers a change event so other views can update.
	     *
	     * ##### Save/Create #####
	     *
	     *  - Call [sync]{@link Plumage.model.Model#sync} to POST model state to the server.
	     *  - POST data is determined by [toJSON]{@link Plumage.model.Model#toJSON}.
	     *
	     *
	     * #### Additional Features ####
	     *
	     * ##### Relationships #####
	     *
	     *  - Specify relationships in the [relationships]{@link Plumage.model.Model#relationships} attribute.
	     *  - Related Models and Collections are automatically populated from nested JSON on load.
	     *
	     * ##### View state #####
	     *  - View state stores model state that is not persisted to the server in the url query string. This allows
	     *    a customized view (eg sorted) to be linked to in its customized state.
	     *  - Model attributes specified in [viewAttrs]{@link Plumage.model.Model#viewAttrs} are automatically
	     *    added as query params returned from [getQueryParams]{@link Plumage.model.Model#getQueryParams}.
	     *
	     * @constructs
	     */
	    constructor : function (attributes, options ) {
	      options = options || {};
	      this.related = {};
	      Backbone.Model.apply( this, arguments );
	    },
	
	    /**
	     * Overridable initialization logic
	     */
	    initialize: function(attributes, options) {
	      options = options || {};
	      if (options.urlRoot) {
	        this.urlRoot = options.urlRoot;
	      }
	      if (options.url) {
	        this.urlRoot = options.url;
	      }
	    },
	
	    /**
	     * Gets attributes that are to be including in url query params
	     * @returns {Object}
	     */
	    getQueryParams: function () {
	      var params = {};
	      for ( var i = 0; i < this.viewAttrs.length; i++) {
	        var viewAttr = this.viewAttrs[i];
	        if (this.get(viewAttr) !== undefined) {
	          params[viewAttr] = this.get(viewAttr);
	        }
	      }
	      return params;
	    },
	
	    /**
	     * Convenience function to update the location bar and trigger the route for this model
	     * @param {Object} options Router.navigate options.
	     */
	    navigate: function(options) {
	      options = _.extend({trigger: true}, options);
	      if (window.router) {
	        window.router.navigateWithQueryParams(this.viewUrlWithParams(), options);
	      }
	    },
	
	    navigateToIndex: function(options) {
	      options = _.extend({trigger: true}, options);
	      if (window.router) {
	        window.router.navigateWithQueryParams(this.urlRoot, options);
	      }
	    },
	
	    /**
	     * Convenience function to update the location bar when the view state has changed.
	     * Does not trigger routes.
	     * @param {Object} options Router.navigate options.
	     */
	    updateUrl: function(options) {
	      options = _.extend({replace: true, trigger: false}, options);
	      if (window.router) {
	        window.router.navigateWithQueryParams(this.viewUrlWithParams(), options);
	      }
	    },
	
	    /**
	     * Saves model state to server. See Backbone.Model
	     */
	    sync: function(method, model, options) {
	      options.cache = false;
	      return Backbone.sync.apply(this, [method, model, options]);
	    },
	
	    get: function(attr) {
	      if (!attr) {
	        return;
	      }
	      var parts = attr.split('.');
	      if (parts.length > 1) {
	        var related = this.getRelated(parts[0]);
	        if (related) {
	          return related.get(parts.slice(1).join('.'));
	        }
	      } else {
	        return this.attributes[attr];
	      }
	    },
	
	    /**
	     * Sets model attributes and constructs related models from provided data. Fires `"change"` unless
	     * you choose to silenced with options.silent.
	     */
	    set: function(key, val, options) {
	      var attr, attrs, unset, changes, silent, changing, prev, current;
	      if (key === null) {
	        return this;
	      }
	
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options = options || {};
	
	      // Run validation.
	      if (!this._validate(attrs, options)) {
	        return false;
	      }
	
	      // Extract attributes and options.
	      unset           = options.unset;
	      silent          = options.silent;
	      changes         = [];
	      changing        = this._changing;
	      this._changing  = true;
	
	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }
	      current = this.attributes;
	      prev = this._previousAttributes;
	
	      /*
	       * changes
	       ******************************************/
	
	      // add valid view state to attrs
	      if (options.viewState) {
	        var viewState = this.processViewState(options.viewState);
	        _.extend(attrs, viewState);
	      }
	
	      var relatedAttrs = {};
	      attrs = _.clone(attrs);
	      //get rel data, but don't instantiate only after initializing this
	      _.each(this.relationships, function(relationship, key) {
	        relatedAttrs[key] = attrs[key];
	        delete attrs[key];
	        //skip normal set for relationships
	      }, this);
	
	      /* **************************************** */
	
	
	      // Check for changes of `id`.
	      if (this.idAttribute in attrs) {
	        this.id = attrs[this.idAttribute];
	      }
	
	      // For each `set` attribute, update or delete the current value.
	      for (attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) {
	          changes.push(attr);
	        }
	        if (!_.isEqual(prev[attr], val)) {
	          this.changed[attr] = val;
	        } else {
	          delete this.changed[attr];
	        }
	        if (unset) {
	          delete current[attr];
	        } else {
	          current[attr] = val;
	        }
	      }
	
	      /*
	       * changes
	       ******************************************/
	      _.each(this.relationships, function(relationship, key) {
	        var relatedData = relatedAttrs[key];
	        if (relatedData !== undefined || relationship.forceCreate && this.getRelated(key) === undefined) {
	          if (this.instantiateRelationship(key, relatedData, relationship)) {
	            changes.push(key, true);
	          }
	        }
	      }, this);
	      /* **************************************** */
	
	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) {
	          this._pending = options;
	        }
	        for (var i = 0, l = changes.length; i < l; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }
	
	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) {
	        return this;
	      }
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },
	
	    /** set view state
	     * @param {Object} viewState
	     */
	    setViewState: function(viewState, options) {
	      this.set(this.processViewState(viewState), options);
	    },
	
	    processViewState: function(viewState) {
	      var results = {};
	      for ( var iAttrs = 0; iAttrs < this.viewAttrs.length; iAttrs++) {
	        var viewAttr = this.viewAttrs[iAttrs], value = viewState[viewAttr];
	        if (value) {
	          results[viewAttr] = value;
	        }
	      }
	      return results;
	    },
	
	    /**
	     * Instantiates or updates a related Model from nested data being set on the model.
	     *
	     * Nested JSON objects that match the key of a relationship are extracted data, and
	     * used to recursively instantiate related models.
	     *
	     * If the related Model doesn't exist yet, instantiateRelationship will call [createRelatedModel]{@link Plumage.model.Model#createRelatedModel}
	     * or [createRelatedCollection]{@link Plumage.model.Model#createRelatedCollection} as appropriate.
	     *
	     * @param {String} key Relationship key
	     * @param {Object} data The original data being [set]{@link Plumage.model.Model#set} on this Model.
	     * @param {Object} relationship Relationship config, as defined in the [relationships]{@link Plumage.model.Model#relationships} attribute.
	     */
	    instantiateRelationship: function(key, data, relationship) {
	      var related = this.getRelated(key);
	      if (related === undefined) {
	        if (relationship.remote && ['autoload', 'loadOnShow', 'manual'].indexOf(relationship.remote) === -1) {
	          throw 'invalid remote relationship param';
	        }
	        var RelatedClass = relationship.modelCls;
	
	        if (RelatedClass.prototype instanceof Plumage.collection.Collection) {
	          related = this.createRelatedCollection(RelatedClass, relationship, data);
	        } else {
	          related = this.createRelatedModel(RelatedClass, relationship, data);
	        }
	        if (relationship.remote === 'loadOnShow') {
	          related.loadOnShow = true;
	        }
	        this.setRelated(key, related);
	        return true;
	      } else {
	        return this.updateRelatedModel(relationship, related, data);
	      }
	    },
	
	    /**
	     * Returns true if this Model has a related model related by the relationship key.
	     * @param {String} key Relationship key
	     */
	    hasRelated: function(key) {
	      return this.related && this.related[key] ||
	        this.collection && this.collection.getRelated(key);
	    },
	
	    /**
	     * Returns true if this Model has a relationship with the key, whether or not it's instantiated.
	     *
	     * Because of reverse relationships, it's possible for a model can have a relationship even though it's
	     * not defined in the [relationships]{@link Plumage.model.Model#relationships} attribute.
	     *
	     * @param {String} key Relationship key
	     */
	    hasRelationship: function(key) {
	      return this.related[key] !== undefined || this.relationships[key] !== undefined;
	    },
	
	    /**
	     * Get the related model for relationship 'key'. If it doesn't exist, tries to getRelated on
	     * the parent collection if there is one.
	     *
	     * @param {String} key Relationship key
	     */
	    getRelated: function(key) {
	      var keyParts = key.split('.'),
	        keyPart = keyParts[0],
	        related;
	
	      if (this.related && this.related[keyPart]) {
	        related = this.related[keyPart];
	      } else if (this.collection && this.collection.hasRelationship(keyPart) && this.collection.getRelated(keyPart)) {
	        related = this.collection.getRelated(keyPart);
	      } else {
	        if (!this.hasRelationship(keyPart)) {
	          throw 'unknown relationship';
	        }
	      }
	
	      if (related && keyParts.length > 1) {
	        return related.getRelated(keyParts.slice(1).join('.'));
	      }
	      return related;
	    },
	
	    setRelated: function(key, model) {
	      this.related = this.related || {};
	      //TODO update event handlers
	      this.related[key] = model;
	    },
	
	    /**
	     * Helper: Create a related Model according to the relationship config.
	     * @param {Class} RelatedClass Model class to create
	     * @param {Object} relationship Relationship config
	     * @param {Object} data Initial data to set on the related model
	     */
	    createRelatedModel: function(RelatedClass, relationship, data) {
	
	      var options = relationship.options || {};
	      if ($.isFunction(options)) {
	        options = options(this);
	      }
	      var attributes = relationship.attributes || {};
	      if ($.isFunction(attributes)) {
	        attributes = attributes(this);
	      }
	      var relatedModel = new RelatedClass(attributes, options);
	
	      if (relationship.reverse) {
	        relatedModel.setRelated(relationship.reverse, this);
	      }
	      this.updateRelatedModel(relationship, relatedModel, data);
	      return relatedModel;
	    },
	
	    /**
	     * Helper: Create a related Collection according to the relationship config.
	     * @param {Class} RelatedClass Collection class to create
	     * @param {Object} relationship Relationship config
	     * @param {Object} data Initial data to set on the related model
	     */
	    createRelatedCollection: function(RelatedClass, relationship, data) {
	      var options = relationship.options || {};
	      if ($.isFunction(options)) {
	        options = options(this);
	      }
	      var relatedCollection = new RelatedClass(null, options);
	
	      if (relationship.buffered) {
	        if (!relationship.remote) {
	          throw 'if buffered, must also be remote';
	        }
	        relatedCollection = new BufferedCollection(relatedCollection);
	      }
	
	      if (relationship.propagateEvents) {
	        //TODO different events for collection/model
	        relatedCollection.on('destroy', this.onRelationChange.bind(this));
	        relatedCollection.on('add', this.onRelationChange.bind(this));
	        relatedCollection.on('remove', this.onRelationChange.bind(this));
	        relatedCollection.on('change', this.onRelationChange.bind(this));
	      }
	
	      relatedCollection.processInMemory = !relationship.remote;
	      if (relationship.reverse) {
	        relatedCollection.setRelated(relationship.reverse, this);
	      }
	      if (relationship.foreignKey) {
	        relatedCollection.setFilter(relationship.foreignKey, this.id);
	      }
	
	      this.updateRelatedModel(relationship, relatedCollection, data);
	      return relatedCollection;
	    },
	
	    /**
	     * Helper: Update a related child model.
	     * Note: Does not call model.onLoad, which should only be called after the entire model tree is updated.
	     *
	     * @param {Object} relationship Relationship config
	     * @param {Plumage.model.Model} model Related model to update
	     * @param {Object} data Data to set on Model.
	     */
	    updateRelatedModel: function(relationship, model, data) {
	      if (model instanceof Plumage.collection.Collection) {
	        if ($.isArray(data)) {
	          data = {models: data};
	        }
	      }
	      model.set(data, {silent: true}); //silent to prevent double render with subsequent load event.
	      return !$.isEmptyObject(model.changed);
	    },
	
	    /**
	     * Predicate for whether this model matches a search query.
	     * Not sure this is a good idea. Might remove it.
	     * @param {string} query The search query
	     */
	    matchesQuery: function(query) {
	      var attrs = [], i, attrName, value;
	      var queryAttrs = this.queryAttrs;
	      if (!queryAttrs || !queryAttrs.length) {
	        queryAttrs = _.keys(this.attributes);
	      }
	      for (i = 0;i<queryAttrs.length;i++) {
	        attrName = queryAttrs[i];
	        value = this.get(attrName);
	        if (value) {
	          attrs[queryAttrs[i]] = value;
	        }
	      }
	      return this.attrsMatchQuery(attrs, null, query);
	    },
	
	    attrsMatchQuery: function(attrs, queryAttrs, query) {
	      if (!query || query.length === 0) { return true; }
	
	      //only check attrs in queryAttrs
	      var filteredAttrs = {}, i,
	        attrName, value;
	      if (queryAttrs) {
	        for (i = 0;i<queryAttrs.length;i++) {
	          attrName = queryAttrs[i];
	          value = attrs[attrName];
	          if (value) {
	            filteredAttrs[attrName] = value;
	          }
	        }
	        attrs = filteredAttrs;
	      }
	      for (attrName in attrs) {
	        if (attrs.hasOwnProperty(attrName)) {
	          if(String(attrs[attrName]).match(new RegExp(query, 'i')) !== null) {
	            return true;
	          }
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Does this model have an url?
	     * @returns {boolean}
	     */
	    hasUrl: function() {
	      return Boolean(_.result(this, 'url') || _.result(this, 'urlRoot'));
	    },
	
	    /**
	     * This Model's url. Returns an attribute named 'href' if it exists.
	     * Otherwise uses urlRoot from backbone.
	     *
	     * Do not override this method. Override urlFromAttributes instead.
	     * @returns {string} Url or null
	     * @see Plumage.model.Model#fetchIfAvailable
	     * @see Plumage.model.Model#urlFromAttributes
	     */
	    url: function() {
	      var href = this.get('href');
	      if (href) {
	        return href;
	      }
	      return this.urlFromAttributes();
	    },
	
	    newUrl: function() {
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url');
	
	      if (base) {
	        var a = document.createElement('a');
	        a.href = base;
	        return a.pathname + '/new' + a.search;
	      }
	      return null;
	    },
	
	    getUrlId: function() {
	      var urlId = this.get(this.urlIdAttribute);
	      if (urlId) {
	        return encodeURIComponent(urlId);
	      }
	    },
	
	    /**
	     * Generate the url for this model from its attributes. By default this returns
	     * urlRoot/urlIdAttribute. If no urlRoot is specified it returns null. This is so prevent loading models
	     * whose urls' can't be derived from attributed. (eg when url depends a parent model's url)
	     *
	     * Override this method if you have custom urls.
	     * Return null if attributes for url are not yet available.
	     * @returns {string} Url or null
	     */
	    urlFromAttributes: function() {
	       //no url so do nothing
	      if (!this.urlRoot) {
	        return null;
	      }
	
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url');
	      if (!base) {
	        throw new Error('A "url" property or function must be specified');
	      }
	      if (this.isNew()) {
	        return this.newUrl();
	      }
	      return base.replace(/([^\/])$/, '$1/') + this.getUrlId();
	    },
	
	    /**
	     * Get url, including query params.
	     * @returns {string} Url with query params or null
	     * @see Plumage.model.Model#getQueryParams
	     *
	     */
	    urlWithParams: function (extras) {
	      extras = extras || {};
	      var url = this.url.apply(this, arguments);
	      if (url === null || url === undefined) {
	        return null;
	      }
	      var params = this.getQueryParams();
	      params = _.extend({}, params, extras);
	      return this._appendParamsToUrl(url, params);
	    },
	
	    /**
	     * Sometimes you want the view url to be different than the server resource url (eg appending a subview nav id).
	     * Called by navigate and updateUrl.
	     *
	     * By default just calls urlWithParams.
	     */
	    viewUrlWithParams: function(extras) {
	      return this.urlWithParams(extras);
	    },
	
	    isNew: function() {
	      var href = this.get('href');
	      if (href) {
	        return href.match(/\/new$/) !== null;
	      }
	      return !this.getUrlId();
	    },
	
	    /**
	     * Extracts model data from JSON response.
	     * @param {Object} resp XHR response
	     * @param {Object} options original request options
	     */
	    parse: function(resp, options) {
	      if(this.resultsPath && resp[this.resultsPath]) {
	        return resp[this.resultsPath];
	      }
	      return resp;
	    },
	
	    /**
	     * Async load model from the server. Calls [onLoad]{@link Plumage.model.Model#onLoad} on success.
	     * @param {Object} options Backbone.sync options
	     * @fires beginLoad
	     * @see Plumage.model.Model#onLoad
	     */
	    load: function(options) {
	      options = options || {};
	      options.data = _.extend(this.getQueryParams(), options.data);
	
	      if (_.isEqual(this.latestLoadParams, options.data)) {
	        return;
	      }
	      //save params to prevent multiple identical requests
	      this.latestLoadParams = options.data;
	
	      this._wrapHandlers(options);
	
	      this.fireBeginLoad();
	      return this.fetch(options).then(function(resp, result, xhr) {
	        return $.Deferred().resolve(this, resp).promise();
	      }.bind(this));
	    },
	
	    save: function(key, val, options) {
	      var attrs;
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (key === null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	      options = options || {};
	      this._wrapHandlers(options);
	      var xhr = Backbone.Model.prototype.save.apply(this, [attrs, options]);
	      if (xhr) {
	        xhr.then(function(resp){
	          return $.Deferred().resolve(this, resp).promise();
	        }.bind(this));
	      }
	      return false;
	    },
	
	    /**
	     * Sets fetches=true triggers 'load' and recurses down to related models.
	     * @param {Object} options Original load options. Passed to load event handlers
	     * @param {Object} visited Record of which models onLoad has been called on to prevent an infinite loop.
	     * @fires load
	     */
	    onLoad: function(options, visited) {
	      options = options || {};
	      this.fetched = true;
	
	      visited = visited || {};
	      visited[this.cid] = true;
	
	      if (!options.silent) {
	        this.trigger('load', this, options);
	      }
	
	      _.each(this.relationships, function(relationship, key) {
	        var rel = this.getRelated(key);
	        if (rel && !visited[rel.cid]) {
	          if (relationship.remote) {
	            if (relationship.remote === 'autoload' || relationship.remote === 'loadOnShow' && !rel.loadOnShow) {
	              rel.fetchIfAvailable();
	            }
	          } else {
	            rel.onLoad(options, visited);
	          }
	        }
	      }, this);
	    },
	
	    /**
	     * Convenience function to trigger beginLoad
	     */
	    fireBeginLoad: function() {
	      this.trigger('beginLoad', this);
	      _.each(this.relationships, function(relationship, key) {
	        var rel = this.getRelated(key);
	        if (rel && relationship.remote === 'autoload') {
	          rel.fireBeginLoad();
	        }
	      }, this);
	    },
	
	    /**
	     * Load if [urlWithParams]{@link Plumage.model.Model#urlWithParams} returns an url.
	     * A remote related Model might not have a complete url yet if its parent has not yet loaded.
	     */
	    fetchIfAvailable: function() {
	      var url = this.urlWithParams();
	      if (url) {
	        return requestManager.loadModel(this);
	      }
	    },
	
	    /**
	     * Gets a 'display name'/title for this model
	     * @returns {string}
	     */
	    getDisplayName: function() {
	      if (this.displayNameAttr !== undefined) {
	        return this.get(this.displayNameAttr);
	      }
	    },
	
	    /**
	     * Returns attributes to be persisted to the server.
	     * TODO: persist related Models depending on a relatonship config flag.
	     *
	     * @see Plumage.model.Model#sync
	     */
	    toJSON: function(options) {
	      var json = _.clone(this.attributes);
	      for ( var i = 0; i < this.viewAttrs.length; i++) {
	        delete json[this.viewAttrs[i]];
	      }
	      return json;
	    },
	
	    /**
	     * Returns an object containing state for rendering into a [ModelView]{@link Plumage.view.ModelView}.
	     */
	    toViewJSON: function(options) {
	      var result = _.clone(this.attributes);
	      if (result.url === undefined && this.hasUrl()) {
	        result.url = this.viewUrlWithParams();
	      }
	      var displayName = this.getDisplayName();
	      if (displayName !== undefined) {
	        result.displayName = displayName;
	      }
	      _.each(this.relationships, function(relationship, key) {
	        var related = this.getRelated(key);
	        if (related) {
	          result[key] = related.toViewJSON();
	        }
	      }, this);
	      return result;
	    },
	
	
	    /**
	     * Listen to relationships
	     */
	    onRelationChange: function() {
	      this.trigger('change', this);
	    },
	
	    //
	    // Helpers
	    //
	
	    _appendParamsToUrl: function(url, params) {
	      if (params && !$.isEmptyObject(params)) {
	        params = $.param(params, true);
	        if (url.indexOf('?') >= 0) {
	          return url + '&' + params;
	        } else {
	          return url + '?' + params;
	        }
	      }
	      return url;
	    },
	
	    _wrapHandlers: function(options) {
	      var success = options.success,
	        error = options.error;
	
	      options.success = function(model, resp, options) {
	        if (resp.meta && resp.meta.success === false) {
	          var seenRelated = {};
	          if (resp.meta.validationError) {
	            model.validationError = resp.meta.validationError;
	            _.each(model.validationError, function(v,k) {
	              var parts = k.split('.');
	              if (parts.length > 1) {
	                var field = parts.pop();
	                var related = model.getRelated(parts.join('.'));
	                if (related) {
	                  related.validationError = related.validationError || {};
	                  related.validationError[field] = v;
	                  seenRelated[related.id] = related;
	                }
	              }
	            });
	          }
	          model.trigger('invalid',
	            model,
	            model.validationError,
	            resp.meta.message,
	            resp.meta.message_class
	          );
	
	          _.each(seenRelated, function(related) {
	            related.trigger('invalid', related, related.validationError);
	          });
	
	        } else {
	          model.latestLoadParams = undefined;
	          model.onLoad(options);
	          if (typeof theApp !== 'undefined' && resp.meta && resp.meta.message) {
	            theApp.dispatch.trigger('message', resp.meta.message, resp.meta.message_class);
	          }
	
	          if (success) {
	            success(model, resp, options);
	          }
	        }
	
	      };
	
	      //NOTE: backbone triggers 'error'
	      options.error = function(model, xhr, options) {
	        if (typeof theApp !== 'undefined' && theApp.logger) {
	          if (xhr.statusText !== 'abort') {
	            theApp.logger.error(xhr.statusText, 'Model load error');
	          }
	        }
	        if (error) {
	          error(model, xhr, options);
	        }
	      };
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	
	
	  var instance;
	  /**
	   * Singleton object. Call loadModel to load a Model, and have RequestManager keep a reference to the request so it
	   * can be cancelled if necessary.
	   *
	   * Request manager also triggers 'message' on the Plumage.App for flash messages if the response contains a message.
	   *
	   * @constructs Plumage.RequestManager
	   */
	  var RequestManager = function() {
	    this.requests = [];
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(RequestManager.prototype,
	  /** @lends Plumage.RequestManager.prototype */
	  {
	    /** Does nothing. Override to provide initialization logic. */
	    initialize: function() {
	    },
	
	    /** Load the given model, keeping a reference to the request. */
	    loadModel: function(model, options) {
	      options = _.defaults({}, options, {reset: true});
	
	      var xhr = model.load(options);
	      if (xhr) {
	        this.requests.push({xhr: xhr, url: model.url()});
	      }
	      return xhr;
	    },
	
	    /** cancel all uncompleted requests. */
	    abortOutstandingRequests: function() {
	      for(var i=0;i<this.requests.length;i++) {
	        var xhr = this.requests[i].xhr;
	        var url = this.requests[i].url;
	        if (xhr.abort){
	          xhr.abort();
	        }
	      }
	      this.requests = [];
	    }
	  });
	
	  if (instance === undefined) {
	    instance = new RequestManager();
	  }
	
	  return Plumage.requestManager = instance;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	
	
	  /**
	   * Wraps a collection to cache pages.
	   *
	   * @constructs Plumage.collection.BufferedCollection
	   */
	  var BufferedCollection = function(collection) {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(BufferedCollection.prototype, Backbone.Events,
	  /** @lends Plumage.collection.BufferedCollection.prototype */
	  {
	
	    /** buffer of pages */
	    buffer: undefined,
	
	    /** Map of id to index for everything in cache */
	    idToIndex: undefined,
	
	    /** Running requests */
	    requests: undefined,
	
	    /** Total rows on the server. */
	    total: 0,
	
	    initialize: function(collection, options) {
	      this.requests = [];
	      this.clearBuffer();
	
	      this.collection = collection;
	      this.collection.on('load', this.onCollectionLoad, this);
	      this.collection.on('all', this.onCollectionEvent, this);
	
	    },
	
	    // wrapped overrides
	
	    at: function(index) {
	      return this.buffer[index];
	    },
	
	    getById: function(id) {
	      return this.at(this.idToIndex[id]);
	    },
	
	    indexOf: function(model) {
	      return this.idToIndex[model.id];
	    },
	
	    size: function() {
	      return this.total;
	    },
	
	    /**
	     * Loads missing pages
	     */
	    ensureData: function(from, to) {
	      if (!this.collection.fetched) {
	        //regular load first to get meta data
	        this.trigger('beginPageLoad', this, 0);
	
	        this.collection.once('load', function() {
	          this.ensureData(from, to);
	        }.bind(this));
	
	        this.collection.load();
	
	        return;
	      }
	
	      var pageSize = this.collection.get('pageSize');
	      if (from < 0) {
	        from = 0;
	      }
	      if (!to) {
	        to = from + pageSize-1;
	      }
	      var fromPage = Math.floor(from / pageSize);
	      var toPage = Math.floor(to / pageSize);
	
	      while (this.buffer[fromPage * pageSize] !== undefined && fromPage < toPage) {
	        fromPage += 1;
	      }
	
	      while (this.buffer[toPage * pageSize] !== undefined && fromPage < toPage) {
	        toPage -= 1;
	      }
	
	      if (fromPage > toPage || ((fromPage === toPage) && this.buffer[fromPage * pageSize] !== undefined)) {
	        // already have it
	        return;
	      }
	
	      this.trigger('beginLoad', this, from, to);
	
	      for (var i=fromPage;i<=toPage;i++) {
	        this.loadPage(i);
	      }
	    },
	
	    /** Load page number 'page' */
	    loadPage: function(pageIndex) {
	      //already requesting?
	      if (this.requests[pageIndex] !== undefined) {
	        return;
	      }
	
	      var options = {
	        data: _.extend(this.collection.getQueryParams(), {page: pageIndex, noTotal: true}),
	        success: function (resp) {
	          //silent because so we don't trigger this.onLoad
	          this.collection.reset(resp, {parse: true, silent: true});
	          this.collection.onLoad({silent: true});
	          this.onBufferLoad(this.collection, pageIndex);
	        }.bind(this)
	      };
	
	      this.trigger('beginPageLoad', this, pageIndex);
	      //calling sync directly instead of load so we don't trigger load event
	      this.requests[pageIndex] = this.collection.sync('read', this.collection, options);
	    },
	
	    // Handlers
	
	    /** Loads models into the buffer after a page load request. */
	    onBufferLoad: function(collection, pageIndex) {
	      delete this.requests[pageIndex];
	
	      this.addModelsToBuffer(collection.models, pageIndex, this.collection.get('pageSize'));
	    },
	
	    /**
	     * Propagate all events except load. Triggering of load event is special cased in [onCollectionLoad]{@link Plumage.collection.BufferedCollection#onLoad}
	     */
	    onCollectionEvent: function(e, collection, resp) {
	      // load is handled separately in onCollectionLoad (because named handlers are triggered before all handlers)
	      if (e !== 'load') {
	        this.trigger(e);
	      }
	    },
	
	    /**
	     * Handle collection's initial load event
	     * Clears the buffer and adds the collection's models when the Collection emits the load event.
	     * Does not occur when loading subsequent pages.
	     */
	    onCollectionLoad: function(collection, resp) {
	      this.clearBuffer();
	      this.total = collection.get('total') || collection.size();
	      this.addModelsToBuffer(collection.models, collection.get('page'), collection.get('pageSize'));
	    },
	
	    clearBuffer: function() {
	      this.buffer = [];
	      this.idToIndex = {};
	    },
	
	    /**
	     * Helper that adds a list of models to the buffer.
	     * @private
	     */
	    addModelsToBuffer: function(models, pageIndex, pageSize) {
	      for (var i=0; i<models.length;i++) {
	        var model = models[i];
	        var index = pageIndex * pageSize + i;
	        this.buffer[index] = model;
	        this.idToIndex[model.id] = index;
	      }
	      var from = pageIndex * pageSize;
	      var to = from + models.length;
	      this.trigger('pageLoad', this, from, to);
	    }
	
	
	  });
	
	  var passThroughMethods = ['getRelated', 'setSort'];
	  _.each(passThroughMethods, function(method) {
	    BufferedCollection.prototype[method] = function() {this.collection[method].apply(this.collection, arguments);};
	  });
	
	
	  return Plumage.collection.BufferedCollection = BufferedCollection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 103 */
/***/ function(module, exports) {

	module.exports = "{{#if label}}\n<div class=\"control-group\">\n  <label class=\"control-label\" for=\"{{valueAttr}}\">{{label}}</label>\n  <div class=\"controls\">\n    <span class=\"field\">\n\t    <span class=\"dropdown\">\n\t      {{> field}}\n\t      <div class=\"picker\"></div>\n\t    </span>\n    </span>\n    <span class=\"help-inline\">{{#if message}}{{message}}{{/if}}</span>\n  </div>\n</div>\n{{else}}\n<span class=\"field\">\n<span class=\"dropdown picker-dropdown\">\n  {{> field}}\n  <div class=\"picker\"></div>\n</span>\n</span>\n{{/if}}\n"

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(99),
	  __webpack_require__(90),
	  __webpack_require__(105),
	  __webpack_require__(111),
	  __webpack_require__(114),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, Picker, Field, HourSelect, Calendar, template) {
	
	  return  Plumage.view.form.fields.picker.DateRangePicker = Picker.extend(
	  /** @lends Plumage.view.form.fields.picker.DateRangePicker.prototype */
	  {
	    template: template,
	
	    className: 'date-range-picker dropdown-menu form-inline',
	
	    showHourSelect: false,
	
	    /** min selectable date, inclusive. */
	    minDate: undefined,
	
	    /** min selectable date, inclusive. */
	    maxDate: undefined,
	
	    /**
	     * Date format for text fields. Other formats can be typed into the main field, as long it can be
	     * parsed by moment.js
	     */
	    dateFormat: 'MMM D, YYYY',
	
	    utc: false,
	
	    /**
	     * Preset ranges. Shown as buttons on the side.
	     * Array of json objects with attributes:
	     *  - name: Text of the button
	     *  - from: moment date object for the start of the range.
	     *  - to: moment date object for the end of the range.
	     *
	     *  from and to can also be 'today' or 'yesterday'
	     */
	    ranges: [
	      {name: 'Today', from:'today', to:'today'},
	      {name: 'Yesterday', from:{day: -1}, to:{day: -1}},
	      {name: 'Last 7 Days', from:{day: -6}, to:'today'},
	      {name: 'Last 30 Days', from:{day: -29}, to:'today'},
	      {name: 'Last 90 Days', from:{day: -89}, to:'today'}
	    ],
	
	    events: {
	      'click .ranges a': 'onRangeClick',
	      'click .apply': 'onApplyClick',
	      'click .cancel': 'onCancelClick',
	      'mousedown': 'onMouseDown'
	    },
	
	    subViews: [{
	      viewCls: Calendar,
	      name: 'fromCal',
	      selector: '.from-calendar',
	      valueAttr: 'fromDate',
	      fromAttr: 'fromDate',
	      toAttr: 'toDate',
	      minDateAttr: 'minDate',
	      maxDateAttr: 'toDate',
	    }, {
	      viewCls: Calendar,
	      name: 'toCal',
	      selector: '.to-calendar',
	      valueAttr: 'toDate',
	      fromAttr: 'fromDate',
	      toAttr: 'toDate',
	      minDateAttr: 'fromDate',
	      maxDateAttr: 'maxDate',
	    }, {
	      viewCls: Field,
	      selector: '.from-date',
	      name: 'fromDate',
	      valueAttr: 'fromDate',
	      readonly: true,
	      replaceEl: true
	    }, {
	      viewCls: Field,
	      selector: '.to-date',
	      name: 'toDate',
	      valueAttr: 'toDate',
	      readonly: true,
	      replaceEl: true
	    }, {
	      viewCls: HourSelect,
	      name: 'fromHour',
	      selector: '.from-hour',
	      valueAttr: 'fromDate',
	      minDateAttr: 'minDate',
	      maxDateAttr: 'toDate',
	      fromAttr: 'fromDate',
	      toAttr: 'toDate',
	      preventFocus: true,
	      replaceEl: true
	    }, {
	      viewCls: HourSelect,
	      name: 'toHour',
	      selector: '.to-hour',
	      valueAttr: 'toDate',
	      minDateAttr: 'fromDate',
	      maxDateAttr: 'maxDate',
	      fromAttr: 'fromDate',
	      toAttr: 'toDate',
	      preventFocus: true,
	      replaceEl: true
	    }],
	
	    /**
	     * @constructs
	     * @extends Plumage.view.ModelView
	     */
	    initialize: function(options) {
	      if (this.utc) {
	        this.subViews = _.map(this.subViews, _.clone);
	        _.each(this.subViews, function(x){x.utc = true;});
	      }
	
	      Picker.prototype.initialize.apply(this, arguments);
	
	      var formatDate = function(date) {
	        var m = this.utc ? moment.utc(date) : moment(date);
	        return m.format(this.dateFormat);
	      }.bind(this);
	
	      this.getSubView('fromDate').processValueForDom = formatDate;
	      this.getSubView('toDate').processValueForDom = formatDate;
	    },
	
	    onRender: function() {
	      Picker.prototype.onRender.apply(this, arguments);
	      this.$el.toggleClass('show-hour-select', this.showHourSelect);
	    },
	
	    getTemplateData: function() {
	      var data = Picker.prototype.getTemplateData.apply(this, arguments);
	
	      return _.extend(data, {
	        ranges: this.ranges,
	        opens: this.opens,
	        showHourSelect: this.showHourSelect
	      });
	    },
	
	    setShowHourSelect: function(showHourSelect) {
	      this.showHourSelect = showHourSelect;
	      if(this.isRendered) {
	        this.render();
	      }
	    },
	
	    //
	    // override Picker
	    //
	
	    getValue: function() {
	      return [this.model.get('fromDate'), this.model.get('toDate')];
	    },
	
	    setValue: function(value) {
	      var data = {fromDate: undefined, toDate: undefined};
	      if (value && value.length) {
	        data = {fromDate: value[0], toDate: value[1]};
	      }
	      this.model.set(data);
	    },
	
	    //
	    // Helpers
	    //
	
	    /** Helper: select the specified preset (value from [ranges]{@link Plumage.view.form.fields.DateRangePicker#ranges}) */
	    selectPresetRange: function(range) {
	      var value = [range.from, range.to];
	      var today = this.utc ? moment.utc({hour: 0}) : moment({hour: 0});
	      for (var i=0; i<value.length; i++) {
	        if (value[i] === 'today') {
	          value[i] = today;
	        } else {
	          value[i] = today.clone().add(value[i]);
	        }
	      }
	      this.setValue([value[0].startOf('day').valueOf(), value[1].endOf('day').valueOf()]);
	      this.update();
	    },
	
	    //
	    // Events
	    //
	
	    onRangeClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var range = _.findWhere(this.ranges, {name: e.target.text});
	      this.selectPresetRange(range);
	    },
	
	    onApplyClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.trigger('apply', this, this.model);
	    },
	
	    onCancelClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.trigger('close');
	    },
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(106),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, DropdownSelect, template) {
	
	  return Plumage.view.form.fields.HourSelect = DropdownSelect.extend({
	    className: 'hour-select',
	
	    minDate: undefined,
	    maxDate: undefined,
	
	    minDateAttr: undefined,
	    maxDateAttr: undefined,
	
	    /** optional. For displaying a selected range. */
	    fromAttr: undefined,
	
	    /** optional. For displaying a selected range. */
	    toAttr: undefined,
	
	    hourFormat: 'ha',
	
	    utc: false,
	
	    initialize: function(options) {
	      this.listValues = _.map(_.range(24), function(x){
	        return {
	          value: x,
	          label: moment({hour: x}).format(this.hourFormat)
	        };
	      }.bind(this));
	      DropdownSelect.prototype.initialize.apply(this, arguments);
	    },
	
	
	
	    getTemplateData: function() {
	      var data = DropdownSelect.prototype.getTemplateData.apply(this, arguments);
	      _.each(data.listValues, function(x) {
	        x.classes = this.getClassesForHour(x.value).join(' ');
	      }, this);
	      return data;
	    },
	
	    getValueFromModel: function() {
	      if (this.model) {
	        var result = this.model.get(this.valueAttr);
	        if (result > 1000) {
	          var m = this.utc ? moment.utc(result) : moment(result);
	          result = m.hour();
	        }
	        return result === undefined ? '' : result;
	      }
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.getValue();
	
	      var modelValue = model.get(this.valueAttr);
	      var m = this.utc ? moment.utc(modelValue) : moment(modelValue);
	      value = m.hour(value).valueOf();
	
	      return model.set(this.valueAttr, value);
	    },
	
	    getMinDate: function() {
	      if (this.model && this.minDateAttr) {
	        return this.model.get(this.minDateAttr);
	      }
	      return this.minDate;
	    },
	
	    setMinDate: function(minDate) {
	      this.minDate = minDate;
	      this.update();
	    },
	
	    /**
	     * Set the maximum selectable date (inclusive)
	     */
	    getMaxDate: function() {
	      if (this.model && this.maxDateAttr) {
	        return this.model.get(this.maxDateAttr);
	      }
	      return this.maxDate;
	    },
	
	    setMaxDate: function(maxDate) {
	      this.maxDate = maxDate;
	      this.update();
	    },
	
	    setValue: function(value) {
	      if (!this.isHourInMinMax(value)) {
	        return;
	      }
	      DropdownSelect.prototype.setValue.apply(this, arguments);
	    },
	
	    //
	    // Helpers
	    //
	
	    getClassesForHour: function(hour) {
	      var m = this.getDate(hour);
	      var classes = [
	        this.isHourInMinMax(hour) ? null : 'disabled',
	        hour === this.getValue() ? 'selected' : null,
	        this.isHourInSelectedRange(hour) ? 'in-range' : null,
	        this.isHourOtherSelection(hour) ? 'other-selected' : null
	      ];
	      return _.compact(classes);
	    },
	
	    isHourInMinMax: function(hour) {
	      if (!this.model) {
	        return true;
	      }
	
	      var minDate = this.getMinDate(),
	        maxDate = this.getMaxDate();
	
	      var m = this.getDate(hour);
	
	      return (!minDate || m >= moment(minDate)) && (!maxDate || m <= moment(maxDate));
	    },
	
	    isHourInSelectedRange: function(hour) {
	      if (!this.model || !this.fromAttr || !this.toAttr) {
	        return false;
	      }
	      var fromDate = this.model.get(this.fromAttr),
	        toDate = this.model.get(this.toAttr);
	
	      if (!fromDate || !toDate) {
	        return false;
	      }
	
	      var m = this.getDate(hour);
	      return m.valueOf() >= fromDate &&  m.valueOf() <= toDate;
	    },
	
	    isHourOtherSelection: function(hour) {
	      if (!this.model || !this.fromAttr || !this.toAttr || hour === this.getValue()) {
	        return false;
	      }
	      var fromDate = this.model.get(this.fromAttr),
	        toDate = this.model.get(this.toAttr);
	
	      if (!fromDate || !toDate) {
	        return false;
	      }
	      var m = this.getDate(hour);
	      return m.valueOf() === fromDate ||  m.valueOf() === toDate;
	    },
	
	    getDate: function(hour) {
	      var modelValue = this.model && this.model.get(this.valueAttr), m;
	      if (modelValue !== undefined) {
	        m = this.utc ? moment.utc(modelValue) : moment(modelValue);
	      } else {
	        m = this.utc ? moment.utc() : moment();
	      }
	      return m.hour(hour);
	    },
	
	
	    onModelChange: function (e) {
	      if (e.changed[this.valueAttr] !== undefined || e.changed[this.minDateAttr] !== undefined || e.changed[this.maxDateAttr] !== undefined) {
	        this.updateValueFromModel();
	      }
	    },
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(107),
	  __webpack_require__(109),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, Select, template) {
	
	  return Plumage.view.form.fields.DropdownSelect = Select.extend({
	
	    template: template,
	
	    modelAttr: 'filter',
	
	    noSelectionText: 'Click to select',
	
	    noSelectionValue: '',
	
	    buttonCls: undefined,
	
	    iconCls: undefined,
	
	    opens: 'right',
	
	    preventFocus: false,
	
	
	    events:{
	      'click li a': 'onItemClick',
	      'click .dropdown-toggle': 'onToggleClick'
	    },
	
	    initialize: function() {
	      Select.prototype.initialize.apply(this, arguments);
	    },
	
	    onRender: function() {
	      Select.prototype.onRender.apply(this, arguments);
	    },
	
	    getTemplateData: function() {
	      var data = Select.prototype.getTemplateData.apply(this, arguments);
	      data = _.extend(data, {
	        buttonCls: this.buttonCls,
	        iconCls: this.iconCls,
	        opens: this.opens
	      });
	      return data;
	    },
	
	    onToggleClick: function(e) {
	      if (this.preventFocus) {
	        e.preventDefault();
	        e.stopPropagation();
	        this.$('.dropdown').toggleClass('open');
	      }
	    },
	
	    onItemClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var li = $(e.target).closest('li'),
	        value = li && li.data('value');
	
	      this.$el.removeClass('open');
	      this.setValue(value);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(90),
	  __webpack_require__(108)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModelView, Field, template) {
	
	
	  return Plumage.view.form.fields.Select = Field.extend(
	  /** @lends Plumage.view.form.fields.Select.prototype */
	  {
	    /**
	     * List of {label:"", value:""} objects to use as select choices.
	     * Use either this, listModel or listRelationship
	     */
	    listValues: undefined,
	
	    /**
	     * Model to get select choices from. Which attributes are used label and value are determined by
	     * listLabelAttr and listValueAttr.
	     * Use either this, or listValues, or listRelationship
	     */
	    listModel: undefined,
	
	    /**
	     * Relationship of this.model to use as listModel.
	     * Use either this, or listValues, or listRelationship
	     */
	    listRelationship: undefined,
	
	    /**
	     * Attribute from listModel items to use as the selection value
	     */
	    listValueAttr: undefined,
	
	    /**
	     * Attribute from listModel items to render as the item label
	     */
	    listLabelAttr: undefined,
	
	    selectSize: undefined,
	
	    noSelectionText: undefined,
	    noSelectionValue: '',
	
	    noItemsText: 'No Items',
	
	    fieldTemplate: template,
	
	    defaultToFirst: false,
	
	    /**
	     * Field with extra listModel for possible selections.
	     *
	     * This class is the base class for all fields that allow choosing from a list.
	     *  eg. checkbox, radio, select, combobox, tabs etc
	     *
	     * By default renders <select> but there are a large number of possible representations.
	     *
	     * The regular model (representing the selection) is normally, populated by the model hierarchy.
	     * The list model needs to be populated manually.
	     *
	     * @constructs
	     * @extends Plumage.view.form.fields.Field
	     */
	    initialize: function() {
	      Field.prototype.initialize.apply(this, arguments);
	      this.updateDefault();
	    },
	
	    /**
	     * Rendering
	     **************/
	
	    onRender: function() {
	      Field.prototype.onRender.apply(this, arguments);
	    },
	
	    update: function(isLoad) {
	      ModelView.prototype.update.apply(this, arguments);
	    },
	
	    getTemplateData: function() {
	      var data = Field.prototype.getTemplateData.apply(this, arguments);
	
	      _.extend(data, {
	        valueLabel: this.getValueLabel(data.value),
	        noSelectionValue: this.noSelectionValue,
	        noSelectionText: this.noSelectionText,
	        noItemsText: this.noItemsText,
	        hasSelection: this.hasSelection(),
	        defaultToFirst: this.defaultToFirst,
	        selectSize: this.selectSize,
	        listValues: this.getListValues(this.model)
	      });
	
	      return data;
	    },
	
	    getListValues: function(model) {
	      if (this.listModel) {
	        return this.listModel.map(function(model){
	          return this.getItemData(model);
	        }, this);
	      } else {
	        return this.listValues;
	      }
	    },
	
	    getValueLabel: function(value) {
	      var i,
	        listValues = this.getListValues(this.model);
	      if (listValues) {
	        for (i=0;i<listValues.length;i++) {
	          if (listValues[i].value === value) {
	            return listValues[i].label;
	          }
	        }
	      }
	    },
	
	    setValue: function(value) {
	      Field.prototype.setValue.apply(this, arguments);
	    },
	
	    onShow: function() {
	      Field.prototype.onShow.apply(this, arguments);
	      this.ensureListData();
	    },
	
	    /** Ensure listModel is loaded */
	    ensureListData: function() {
	      if (this.listModel && this.listModel.loadOnShow && !this.listModel.fetched) {
	        this.listModel.fetchIfAvailable();
	      }
	    },
	
	    /**
	     * Rendering Helpers/Hooks
	     * - override these as needed
	     */
	
	    getItemData: function(item) {
	      var data = {
	        value: this.getListItemValue(item),
	        label: this.getListItemLabel(item),
	        url: item.viewUrlWithParams() || '#'
	      };
	      data.selected = this.isValueSelected(data.value);
	      return data;
	    },
	
	    isValueSelected: function(value) {
	      return value === this.getValue();
	    },
	
	
	    getListItemValue: function(item) {
	      return item.get(this.listValueAttr);
	    },
	
	    getListItemLabel: function(item) {
	      return item.get(this.listLabelAttr);
	    },
	
	    hasSelection: function() {
	      var value = this.getValue();
	      return value !== null && value !== undefined && value !== this.noSelectionValue;
	    },
	
	    updateDefault: function() {
	      var listValues = this.getListValues(this.model);
	      if (!this.hasSelection() && this.defaultToFirst && listValues && listValues.length) {
	        this.setValue(listValues[0].value, {silent: true});
	      }
	    },
	
	
	    /**
	     * List Model
	     **************/
	
	    setModel: function(rootModel, parentModel) {
	      Field.prototype.setModel.apply(this, arguments);
	      if (this.listRelationship) {
	        var listModel = this.getModelFromRoot(this.listRelationship, rootModel, parentModel);
	        if (listModel) {
	          this.setListModel(listModel);
	          if (this.shown) {
	            this.ensureListData();
	          }
	        }
	      }
	      this.updateDefault();
	    },
	
	    setListModel: function(listModel) {
	      if (this.listModel) {
	        this.listModel.off(null,null,this);
	      }
	      this.listModel = listModel;
	      if (this.listModel) {
	        this.listModel.on('change', this.onListModelChange, this);
	        this.listModel.on('load', this.onListModelLoad, this);
	        this.listModel.on('destroy', this.onListModelDestroy, this);
	        this.listModel.on('error', this.onListModelError, this);
	      }
	
	      if (this.listModel.size()) {
	        this.onListModelLoad(this.listModel);
	      }
	    },
	
	    getListItemForValue: function(value) {
	      var items = this.listModel.select(function(item){return this.getListItemValue(item) === value;}.bind(this));
	      return items && items[0];
	    },
	
	    /**
	     * Event Handlers
	     *****************/
	
	    onListModelChange: function(model, options) {
	      this.update();
	    },
	
	    onListModelLoad: function(model, options) {
	      if (this.getValue() === '' && this.defaultToFirst && this.listModel.size() > 0) {
	        this.setValue(this.getListItemValue(this.listModel.at(0)));
	      } else {
	        this.update();
	      }
	    },
	
	    onListModelDestroy: function(model, options) {
	    },
	
	    onListModelError: function(model, response, options) {
	      this.onModelError(model, response, options);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "<select name=\"{{valueAttr}}\" {{#selectSize}}size=\"{{.}}\"{{/selectSize}}>\n{{#if noSelectionText}}\n<option value=\"{{noSelectionValue}}\" {{^hasSelection}}selected=\"true\"{{/hasSelection}}>{{noSelectionText}}</option>\n{{/if}}\n\n{{#listValues}}\n<option value=\"{{value}}\" class=\"{{value}}\" {{#selected}}selected{{/selected}}>{{label}}</option>\n{{/listValues}}\n</select>"

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "\n{{#if label}}\n<div class=\"control-group\">\n  <label class=\"control-label\" for=\"{{valueAttr}}\">{{label}}</label>\n  <div class=\"controls\">\n{{/if}}\n\n<span class=\"dropdown-select dropdown\">\n<input type=\"hidden\" {{#if fieldName}}name=\"{{fieldName}}\"{{/if}} value=\"{{value}}\"/>\n<a class=\"btn dropdown-toggle {{buttonCls}}\" data-toggle=\"dropdown\" href=\"#\">\n  {{#iconCls}}\n    <i class=\"{{.}} icon-white\"></i>\n  {{/iconCls}}\n  {{#if hasSelection}}\n    {{valueLabel}}\n  {{else}}\n    {{noSelectionText}}\n  {{/if}}\n  <span class=\"caret\"></span>\n</a>\n<ul class=\"dropdown-menu opens{{opens}}\">\n{{#listValues}}\n  <li data-value=\"{{value}}\" class=\"{{value}}{{#selected}} active{{/selected}} {{#disabled}}disabled{{/disabled}} {{classes}}\">\n    <a href=\"#\">{{label}}</a>\n  </li>\n{{/listValues}}\n</ul>\n</span>\n\n{{#if label}}\n  </div>\n</div>\n{{/if}}"

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/* ===================================================
	 * bootstrap-transition.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#transitions
	 * ===================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
	   * ======================================================= */
	
	  $(function () {
	
	    $.support.transition = (function () {
	
	      var transitionEnd = (function () {
	
	        var el = document.createElement('bootstrap')
	          , transEndEventNames = {
	               'WebkitTransition' : 'webkitTransitionEnd'
	            ,  'MozTransition'    : 'transitionend'
	            ,  'OTransition'      : 'oTransitionEnd otransitionend'
	            ,  'transition'       : 'transitionend'
	            }
	          , name
	
	        for (name in transEndEventNames){
	          if (el.style[name] !== undefined) {
	            return transEndEventNames[name]
	          }
	        }
	
	      }())
	
	      return transitionEnd && {
	        end: transitionEnd
	      }
	
	    })()
	
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* ==========================================================
	 * bootstrap-alert.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#alerts
	 * ==========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* ALERT CLASS DEFINITION
	  * ====================== */
	
	  var dismiss = '[data-dismiss="alert"]'
	    , Alert = function (el) {
	        $(el).on('click', dismiss, this.close)
	      }
	
	  Alert.prototype.close = function (e) {
	    var $this = $(this)
	      , selector = $this.attr('data-target')
	      , $parent
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	    }
	
	    $parent = $(selector)
	
	    e && e.preventDefault()
	
	    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())
	
	    $parent.trigger(e = $.Event('close'))
	
	    if (e.isDefaultPrevented()) return
	
	    $parent.removeClass('in')
	
	    function removeElement() {
	      $parent
	        .trigger('closed')
	        .remove()
	    }
	
	    $.support.transition && $parent.hasClass('fade') ?
	      $parent.on($.support.transition.end, removeElement) :
	      removeElement()
	  }
	
	
	 /* ALERT PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.alert
	
	  $.fn.alert = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('alert')
	      if (!data) $this.data('alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  $.fn.alert.Constructor = Alert
	
	
	 /* ALERT NO CONFLICT
	  * ================= */
	
	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }
	
	
	 /* ALERT DATA-API
	  * ============== */
	
	  $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)
	
	}(__webpack_provided_window_dot_jQuery);/* ============================================================
	 * bootstrap-button.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#buttons
	 * ============================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* BUTTON PUBLIC CLASS DEFINITION
	  * ============================== */
	
	  var Button = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.button.defaults, options)
	  }
	
	  Button.prototype.setState = function (state) {
	    var d = 'disabled'
	      , $el = this.$element
	      , data = $el.data()
	      , val = $el.is('input') ? 'val' : 'html'
	
	    state = state + 'Text'
	    data.resetText || $el.data('resetText', $el[val]())
	
	    $el[val](data[state] || this.options[state])
	
	    // push to event loop to allow forms to submit
	    setTimeout(function () {
	      state == 'loadingText' ?
	        $el.addClass(d).attr(d, d) :
	        $el.removeClass(d).removeAttr(d)
	    }, 0)
	  }
	
	  Button.prototype.toggle = function () {
	    var $parent = this.$element.closest('[data-toggle="buttons-radio"]')
	
	    $parent && $parent
	      .find('.active')
	      .removeClass('active')
	
	    this.$element.toggleClass('active')
	  }
	
	
	 /* BUTTON PLUGIN DEFINITION
	  * ======================== */
	
	  var old = $.fn.button
	
	  $.fn.button = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('button')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('button', (data = new Button(this, options)))
	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }
	
	  $.fn.button.defaults = {
	    loadingText: 'loading...'
	  }
	
	  $.fn.button.Constructor = Button
	
	
	 /* BUTTON NO CONFLICT
	  * ================== */
	
	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }
	
	
	 /* BUTTON DATA-API
	  * =============== */
	
	  $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
	    var $btn = $(e.target)
	    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	    $btn.button('toggle')
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* ==========================================================
	 * bootstrap-carousel.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#carousel
	 * ==========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* CAROUSEL CLASS DEFINITION
	  * ========================= */
	
	  var Carousel = function (element, options) {
	    this.$element = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options = options
	    this.options.pause == 'hover' && this.$element
	      .on('mouseenter', $.proxy(this.pause, this))
	      .on('mouseleave', $.proxy(this.cycle, this))
	  }
	
	  Carousel.prototype = {
	
	    cycle: function (e) {
	      if (!e) this.paused = false
	      if (this.interval) clearInterval(this.interval);
	      this.options.interval
	        && !this.paused
	        && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
	      return this
	    }
	
	  , getActiveIndex: function () {
	      this.$active = this.$element.find('.item.active')
	      this.$items = this.$active.parent().children()
	      return this.$items.index(this.$active)
	    }
	
	  , to: function (pos) {
	      var activeIndex = this.getActiveIndex()
	        , that = this
	
	      if (pos > (this.$items.length - 1) || pos < 0) return
	
	      if (this.sliding) {
	        return this.$element.one('slid', function () {
	          that.to(pos)
	        })
	      }
	
	      if (activeIndex == pos) {
	        return this.pause().cycle()
	      }
	
	      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
	    }
	
	  , pause: function (e) {
	      if (!e) this.paused = true
	      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
	        this.$element.trigger($.support.transition.end)
	        this.cycle(true)
	      }
	      clearInterval(this.interval)
	      this.interval = null
	      return this
	    }
	
	  , next: function () {
	      if (this.sliding) return
	      return this.slide('next')
	    }
	
	  , prev: function () {
	      if (this.sliding) return
	      return this.slide('prev')
	    }
	
	  , slide: function (type, next) {
	      var $active = this.$element.find('.item.active')
	        , $next = next || $active[type]()
	        , isCycling = this.interval
	        , direction = type == 'next' ? 'left' : 'right'
	        , fallback  = type == 'next' ? 'first' : 'last'
	        , that = this
	        , e
	
	      this.sliding = true
	
	      isCycling && this.pause()
	
	      $next = $next.length ? $next : this.$element.find('.item')[fallback]()
	
	      e = $.Event('slide', {
	        relatedTarget: $next[0]
	      , direction: direction
	      })
	
	      if ($next.hasClass('active')) return
	
	      if (this.$indicators.length) {
	        this.$indicators.find('.active').removeClass('active')
	        this.$element.one('slid', function () {
	          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
	          $nextIndicator && $nextIndicator.addClass('active')
	        })
	      }
	
	      if ($.support.transition && this.$element.hasClass('slide')) {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $next.addClass(type)
	        $next[0].offsetWidth // force reflow
	        $active.addClass(direction)
	        $next.addClass(direction)
	        this.$element.one($.support.transition.end, function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () { that.$element.trigger('slid') }, 0)
	        })
	      } else {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $active.removeClass('active')
	        $next.addClass('active')
	        this.sliding = false
	        this.$element.trigger('slid')
	      }
	
	      isCycling && this.cycle()
	
	      return this
	    }
	
	  }
	
	
	 /* CAROUSEL PLUGIN DEFINITION
	  * ========================== */
	
	  var old = $.fn.carousel
	
	  $.fn.carousel = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('carousel')
	        , options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option)
	        , action = typeof option == 'string' ? option : options.slide
	      if (!data) $this.data('carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }
	
	  $.fn.carousel.defaults = {
	    interval: 5000
	  , pause: 'hover'
	  }
	
	  $.fn.carousel.Constructor = Carousel
	
	
	 /* CAROUSEL NO CONFLICT
	  * ==================== */
	
	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }
	
	 /* CAROUSEL DATA-API
	  * ================= */
	
	  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
	    var $this = $(this), href
	      , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	      , options = $.extend({}, $target.data(), $this.data())
	      , slideIndex
	
	    $target.carousel(options)
	
	    if (slideIndex = $this.attr('data-slide-to')) {
	      $target.data('carousel').pause().to(slideIndex).cycle()
	    }
	
	    e.preventDefault()
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* =============================================================
	 * bootstrap-collapse.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#collapse
	 * =============================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* COLLAPSE PUBLIC CLASS DEFINITION
	  * ================================ */
	
	  var Collapse = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.collapse.defaults, options)
	
	    if (this.options.parent) {
	      this.$parent = $(this.options.parent)
	    }
	
	    this.options.toggle && this.toggle()
	  }
	
	  Collapse.prototype = {
	
	    constructor: Collapse
	
	  , dimension: function () {
	      var hasWidth = this.$element.hasClass('width')
	      return hasWidth ? 'width' : 'height'
	    }
	
	  , show: function () {
	      var dimension
	        , scroll
	        , actives
	        , hasData
	
	      if (this.transitioning || this.$element.hasClass('in')) return
	
	      dimension = this.dimension()
	      scroll = $.camelCase(['scroll', dimension].join('-'))
	      actives = this.$parent && this.$parent.find('> .accordion-group > .in')
	
	      if (actives && actives.length) {
	        hasData = actives.data('collapse')
	        if (hasData && hasData.transitioning) return
	        actives.collapse('hide')
	        hasData || actives.data('collapse', null)
	      }
	
	      this.$element[dimension](0)
	      this.transition('addClass', $.Event('show'), 'shown')
	      $.support.transition && this.$element[dimension](this.$element[0][scroll])
	    }
	
	  , hide: function () {
	      var dimension
	      if (this.transitioning || !this.$element.hasClass('in')) return
	      dimension = this.dimension()
	      this.reset(this.$element[dimension]())
	      this.transition('removeClass', $.Event('hide'), 'hidden')
	      this.$element[dimension](0)
	    }
	
	  , reset: function (size) {
	      var dimension = this.dimension()
	
	      this.$element
	        .removeClass('collapse')
	        [dimension](size || 'auto')
	        [0].offsetWidth
	
	      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')
	
	      return this
	    }
	
	  , transition: function (method, startEvent, completeEvent) {
	      var that = this
	        , complete = function () {
	            if (startEvent.type == 'show') that.reset()
	            that.transitioning = 0
	            that.$element.trigger(completeEvent)
	          }
	
	      this.$element.trigger(startEvent)
	
	      if (startEvent.isDefaultPrevented()) return
	
	      this.transitioning = 1
	
	      this.$element[method]('in')
	
	      $.support.transition && this.$element.hasClass('collapse') ?
	        this.$element.one($.support.transition.end, complete) :
	        complete()
	    }
	
	  , toggle: function () {
	      this[this.$element.hasClass('in') ? 'hide' : 'show']()
	    }
	
	  }
	
	
	 /* COLLAPSE PLUGIN DEFINITION
	  * ========================== */
	
	  var old = $.fn.collapse
	
	  $.fn.collapse = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('collapse')
	        , options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option)
	      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.collapse.defaults = {
	    toggle: true
	  }
	
	  $.fn.collapse.Constructor = Collapse
	
	
	 /* COLLAPSE NO CONFLICT
	  * ==================== */
	
	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }
	
	
	 /* COLLAPSE DATA-API
	  * ================= */
	
	  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
	    var $this = $(this), href
	      , target = $this.attr('data-target')
	        || e.preventDefault()
	        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
	      , option = $(target).data('collapse') ? 'toggle' : $this.data()
	    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
	    $(target).collapse(option)
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* ============================================================
	 * bootstrap-dropdown.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#dropdowns
	 * ============================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* DROPDOWN CLASS DEFINITION
	  * ========================= */
	
	  var toggle = '[data-toggle=dropdown]'
	    , Dropdown = function (element) {
	        var $el = $(element).on('click.dropdown.data-api', this.toggle)
	        $('html').on('click.dropdown.data-api', function () {
	          $el.parent().removeClass('open')
	        })
	      }
	
	  Dropdown.prototype = {
	
	    constructor: Dropdown
	
	  , toggle: function (e) {
	      var $this = $(this)
	        , $parent
	        , isActive
	
	      if ($this.is('.disabled, :disabled')) return
	
	      $parent = getParent($this)
	
	      isActive = $parent.hasClass('open')
	
	      clearMenus()
	
	      if (!isActive) {
	        if ('ontouchstart' in document.documentElement) {
	          // if mobile we we use a backdrop because click events don't delegate
	          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus)
	        }
	        $parent.toggleClass('open')
	      }
	
	      $this.focus()
	
	      return false
	    }
	
	  , keydown: function (e) {
	      var $this
	        , $items
	        , $active
	        , $parent
	        , isActive
	        , index
	
	      if (!/(38|40|27)/.test(e.keyCode)) return
	
	      $this = $(this)
	
	      e.preventDefault()
	      e.stopPropagation()
	
	      if ($this.is('.disabled, :disabled')) return
	
	      $parent = getParent($this)
	
	      isActive = $parent.hasClass('open')
	
	      if (!isActive || (isActive && e.keyCode == 27)) {
	        if (e.which == 27) $parent.find(toggle).focus()
	        return $this.click()
	      }
	
	      $items = $('[role=menu] li:not(.divider):visible a', $parent)
	
	      if (!$items.length) return
	
	      index = $items.index($items.filter(':focus'))
	
	      if (e.keyCode == 38 && index > 0) index--                                        // up
	      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
	      if (!~index) index = 0
	
	      $items
	        .eq(index)
	        .focus()
	    }
	
	  }
	
	  function clearMenus() {
	    $('.dropdown-backdrop').remove()
	    $(toggle).each(function () {
	      getParent($(this)).removeClass('open')
	    })
	  }
	
	  function getParent($this) {
	    var selector = $this.attr('data-target')
	      , $parent
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	    }
	
	    $parent = selector && $(selector)
	
	    if (!$parent || !$parent.length) $parent = $this.parent()
	
	    return $parent
	  }
	
	
	  /* DROPDOWN PLUGIN DEFINITION
	   * ========================== */
	
	  var old = $.fn.dropdown
	
	  $.fn.dropdown = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('dropdown')
	      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  $.fn.dropdown.Constructor = Dropdown
	
	
	 /* DROPDOWN NO CONFLICT
	  * ==================== */
	
	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }
	
	
	  /* APPLY TO STANDARD DROPDOWN ELEMENTS
	   * =================================== */
	
	  $(document)
	    .on('click.dropdown.data-api', clearMenus)
	    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
	    .on('keydown.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)
	
	}(__webpack_provided_window_dot_jQuery);
	/* =========================================================
	 * bootstrap-modal.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#modals
	 * =========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* MODAL CLASS DEFINITION
	  * ====================== */
	
	  var Modal = function (element, options) {
	    this.options = options
	    this.$element = $(element)
	      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
	    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
	  }
	
	  Modal.prototype = {
	
	      constructor: Modal
	
	    , toggle: function () {
	        return this[!this.isShown ? 'show' : 'hide']()
	      }
	
	    , show: function () {
	        var that = this
	          , e = $.Event('show')
	
	        this.$element.trigger(e)
	
	        if (this.isShown || e.isDefaultPrevented()) return
	
	        this.isShown = true
	
	        this.escape()
	
	        this.backdrop(function () {
	          var transition = $.support.transition && that.$element.hasClass('fade')
	
	          if (!that.$element.parent().length) {
	            that.$element.appendTo(document.body) //don't move modals dom position
	          }
	
	          that.$element.show()
	
	          if (transition) {
	            that.$element[0].offsetWidth // force reflow
	          }
	
	          that.$element
	            .addClass('in')
	            .attr('aria-hidden', false)
	
	          that.enforceFocus()
	
	          transition ?
	            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
	            that.$element.focus().trigger('shown')
	
	        })
	      }
	
	    , hide: function (e) {
	        e && e.preventDefault()
	
	        var that = this
	
	        e = $.Event('hide')
	
	        this.$element.trigger(e)
	
	        if (!this.isShown || e.isDefaultPrevented()) return
	
	        this.isShown = false
	
	        this.escape()
	
	        $(document).off('focusin.modal')
	
	        this.$element
	          .removeClass('in')
	          .attr('aria-hidden', true)
	
	        $.support.transition && this.$element.hasClass('fade') ?
	          this.hideWithTransition() :
	          this.hideModal()
	      }
	
	    , enforceFocus: function () {
	        var that = this
	        $(document).on('focusin.modal', function (e) {
	          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
	            that.$element.focus()
	          }
	        })
	      }
	
	    , escape: function () {
	        var that = this
	        if (this.isShown && this.options.keyboard) {
	          this.$element.on('keyup.dismiss.modal', function ( e ) {
	            e.which == 27 && that.hide()
	          })
	        } else if (!this.isShown) {
	          this.$element.off('keyup.dismiss.modal')
	        }
	      }
	
	    , hideWithTransition: function () {
	        var that = this
	          , timeout = setTimeout(function () {
	              that.$element.off($.support.transition.end)
	              that.hideModal()
	            }, 500)
	
	        this.$element.one($.support.transition.end, function () {
	          clearTimeout(timeout)
	          that.hideModal()
	        })
	      }
	
	    , hideModal: function () {
	        var that = this
	        this.$element.hide()
	        this.backdrop(function () {
	          that.removeBackdrop()
	          that.$element.trigger('hidden')
	        })
	      }
	
	    , removeBackdrop: function () {
	        this.$backdrop && this.$backdrop.remove()
	        this.$backdrop = null
	      }
	
	    , backdrop: function (callback) {
	        var that = this
	          , animate = this.$element.hasClass('fade') ? 'fade' : ''
	
	        if (this.isShown && this.options.backdrop) {
	          var doAnimate = $.support.transition && animate
	
	          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
	            .appendTo(document.body)
	
	          this.$backdrop.click(
	            this.options.backdrop == 'static' ?
	              $.proxy(this.$element[0].focus, this.$element[0])
	            : $.proxy(this.hide, this)
	          )
	
	          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
	
	          this.$backdrop.addClass('in')
	
	          if (!callback) return
	
	          doAnimate ?
	            this.$backdrop.one($.support.transition.end, callback) :
	            callback()
	
	        } else if (!this.isShown && this.$backdrop) {
	          this.$backdrop.removeClass('in')
	
	          $.support.transition && this.$element.hasClass('fade')?
	            this.$backdrop.one($.support.transition.end, callback) :
	            callback()
	
	        } else if (callback) {
	          callback()
	        }
	      }
	  }
	
	
	 /* MODAL PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.modal
	
	  $.fn.modal = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('modal')
	        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
	      if (!data) $this.data('modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option]()
	      else if (options.show) data.show()
	    })
	  }
	
	  $.fn.modal.defaults = {
	      backdrop: true
	    , keyboard: true
	    , show: true
	  }
	
	  $.fn.modal.Constructor = Modal
	
	
	 /* MODAL NO CONFLICT
	  * ================= */
	
	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }
	
	
	 /* MODAL DATA-API
	  * ============== */
	
	  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this = $(this)
	      , href = $this.attr('href')
	      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
	      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())
	
	    e.preventDefault()
	
	    $target
	      .modal(option)
	      .one('hide', function () {
	        $this.focus()
	      })
	  })
	
	}(__webpack_provided_window_dot_jQuery);
	/* ===========================================================
	 * bootstrap-tooltip.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#tooltips
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ===========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* TOOLTIP PUBLIC CLASS DEFINITION
	  * =============================== */
	
	  var Tooltip = function (element, options) {
	    this.init('tooltip', element, options)
	  }
	
	  Tooltip.prototype = {
	
	    constructor: Tooltip
	
	  , init: function (type, element, options) {
	      var eventIn
	        , eventOut
	        , triggers
	        , trigger
	        , i
	
	      this.type = type
	      this.$element = $(element)
	      this.options = this.getOptions(options)
	      this.enabled = true
	
	      triggers = this.options.trigger.split(' ')
	
	      for (i = triggers.length; i--;) {
	        trigger = triggers[i]
	        if (trigger == 'click') {
	          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	        } else if (trigger != 'manual') {
	          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
	          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
	          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	        }
	      }
	
	      this.options.selector ?
	        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	        this.fixTitle()
	    }
	
	  , getOptions: function (options) {
	      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)
	
	      if (options.delay && typeof options.delay == 'number') {
	        options.delay = {
	          show: options.delay
	        , hide: options.delay
	        }
	      }
	
	      return options
	    }
	
	  , enter: function (e) {
	      var defaults = $.fn[this.type].defaults
	        , options = {}
	        , self
	
	      this._options && $.each(this._options, function (key, value) {
	        if (defaults[key] != value) options[key] = value
	      }, this)
	
	      self = $(e.currentTarget)[this.type](options).data(this.type)
	
	      if (!self.options.delay || !self.options.delay.show) return self.show()
	
	      clearTimeout(this.timeout)
	      self.hoverState = 'in'
	      this.timeout = setTimeout(function() {
	        if (self.hoverState == 'in') self.show()
	      }, self.options.delay.show)
	    }
	
	  , leave: function (e) {
	      var self = $(e.currentTarget)[this.type](this._options).data(this.type)
	
	      if (this.timeout) clearTimeout(this.timeout)
	      if (!self.options.delay || !self.options.delay.hide) return self.hide()
	
	      self.hoverState = 'out'
	      this.timeout = setTimeout(function() {
	        if (self.hoverState == 'out') self.hide()
	      }, self.options.delay.hide)
	    }
	
	  , show: function () {
	      var $tip
	        , pos
	        , actualWidth
	        , actualHeight
	        , placement
	        , tp
	        , e = $.Event('show')
	
	      if (this.hasContent() && this.enabled) {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $tip = this.tip()
	        this.setContent()
	
	        if (this.options.animation) {
	          $tip.addClass('fade')
	        }
	
	        placement = typeof this.options.placement == 'function' ?
	          this.options.placement.call(this, $tip[0], this.$element[0]) :
	          this.options.placement
	
	        $tip
	          .detach()
	          .css({ top: 0, left: 0, display: 'block' })
	
	        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	
	        pos = this.getPosition()
	
	        actualWidth = $tip[0].offsetWidth
	        actualHeight = $tip[0].offsetHeight
	
	        switch (placement) {
	          case 'bottom':
	            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
	            break
	          case 'top':
	            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
	            break
	          case 'left':
	            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
	            break
	          case 'right':
	            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
	            break
	        }
	
	        this.applyPlacement(tp, placement)
	        this.$element.trigger('shown')
	      }
	    }
	
	  , applyPlacement: function(offset, placement){
	      var $tip = this.tip()
	        , width = $tip[0].offsetWidth
	        , height = $tip[0].offsetHeight
	        , actualWidth
	        , actualHeight
	        , delta
	        , replace
	
	      $tip
	        .offset(offset)
	        .addClass(placement)
	        .addClass('in')
	
	      actualWidth = $tip[0].offsetWidth
	      actualHeight = $tip[0].offsetHeight
	
	      if (placement == 'top' && actualHeight != height) {
	        offset.top = offset.top + height - actualHeight
	        replace = true
	      }
	
	      if (placement == 'bottom' || placement == 'top') {
	        delta = 0
	
	        if (offset.left < 0){
	          delta = offset.left * -2
	          offset.left = 0
	          $tip.offset(offset)
	          actualWidth = $tip[0].offsetWidth
	          actualHeight = $tip[0].offsetHeight
	        }
	
	        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
	      } else {
	        this.replaceArrow(actualHeight - height, actualHeight, 'top')
	      }
	
	      if (replace) $tip.offset(offset)
	    }
	
	  , replaceArrow: function(delta, dimension, position){
	      this
	        .arrow()
	        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
	    }
	
	  , setContent: function () {
	      var $tip = this.tip()
	        , title = this.getTitle()
	
	      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	      $tip.removeClass('fade in top bottom left right')
	    }
	
	  , hide: function () {
	      var that = this
	        , $tip = this.tip()
	        , e = $.Event('hide')
	
	      this.$element.trigger(e)
	      if (e.isDefaultPrevented()) return
	
	      $tip.removeClass('in')
	
	      function removeWithAnimation() {
	        var timeout = setTimeout(function () {
	          $tip.off($.support.transition.end).detach()
	        }, 500)
	
	        $tip.one($.support.transition.end, function () {
	          clearTimeout(timeout)
	          $tip.detach()
	        })
	      }
	
	      $.support.transition && this.$tip.hasClass('fade') ?
	        removeWithAnimation() :
	        $tip.detach()
	
	      this.$element.trigger('hidden')
	
	      return this
	    }
	
	  , fixTitle: function () {
	      var $e = this.$element
	      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
	        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	      }
	    }
	
	  , hasContent: function () {
	      return this.getTitle()
	    }
	
	  , getPosition: function () {
	      var el = this.$element[0]
	      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
	        width: el.offsetWidth
	      , height: el.offsetHeight
	      }, this.$element.offset())
	    }
	
	  , getTitle: function () {
	      var title
	        , $e = this.$element
	        , o = this.options
	
	      title = $e.attr('data-original-title')
	        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
	
	      return title
	    }
	
	  , tip: function () {
	      return this.$tip = this.$tip || $(this.options.template)
	    }
	
	  , arrow: function(){
	      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
	    }
	
	  , validate: function () {
	      if (!this.$element[0].parentNode) {
	        this.hide()
	        this.$element = null
	        this.options = null
	      }
	    }
	
	  , enable: function () {
	      this.enabled = true
	    }
	
	  , disable: function () {
	      this.enabled = false
	    }
	
	  , toggleEnabled: function () {
	      this.enabled = !this.enabled
	    }
	
	  , toggle: function (e) {
	      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
	      self.tip().hasClass('in') ? self.hide() : self.show()
	    }
	
	  , destroy: function () {
	      this.hide().$element.off('.' + this.type).removeData(this.type)
	    }
	
	  }
	
	
	 /* TOOLTIP PLUGIN DEFINITION
	  * ========================= */
	
	  var old = $.fn.tooltip
	
	  $.fn.tooltip = function ( option ) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('tooltip')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.tooltip.Constructor = Tooltip
	
	  $.fn.tooltip.defaults = {
	    animation: true
	  , placement: 'top'
	  , selector: false
	  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
	  , trigger: 'hover focus'
	  , title: ''
	  , delay: 0
	  , html: false
	  , container: false
	  }
	
	
	 /* TOOLTIP NO CONFLICT
	  * =================== */
	
	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }
	
	}(__webpack_provided_window_dot_jQuery);
	/* ===========================================================
	 * bootstrap-popover.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#popovers
	 * ===========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * =========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* POPOVER PUBLIC CLASS DEFINITION
	  * =============================== */
	
	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }
	
	
	  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
	     ========================================== */
	
	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
	
	    constructor: Popover
	
	  , setContent: function () {
	      var $tip = this.tip()
	        , title = this.getTitle()
	        , content = this.getContent()
	
	      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	      $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)
	
	      $tip.removeClass('fade top bottom left right in')
	    }
	
	  , hasContent: function () {
	      return this.getTitle() || this.getContent()
	    }
	
	  , getContent: function () {
	      var content
	        , $e = this.$element
	        , o = this.options
	
	      content = (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)
	        || $e.attr('data-content')
	
	      return content
	    }
	
	  , tip: function () {
	      if (!this.$tip) {
	        this.$tip = $(this.options.template)
	      }
	      return this.$tip
	    }
	
	  , destroy: function () {
	      this.hide().$element.off('.' + this.type).removeData(this.type)
	    }
	
	  })
	
	
	 /* POPOVER PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.popover
	
	  $.fn.popover = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('popover')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.popover.Constructor = Popover
	
	  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
	    placement: 'right'
	  , trigger: 'click'
	  , content: ''
	  , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })
	
	
	 /* POPOVER NO CONFLICT
	  * =================== */
	
	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }
	
	}(__webpack_provided_window_dot_jQuery);
	/* =============================================================
	 * bootstrap-scrollspy.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#scrollspy
	 * =============================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* SCROLLSPY CLASS DEFINITION
	  * ========================== */
	
	  function ScrollSpy(element, options) {
	    var process = $.proxy(this.process, this)
	      , $element = $(element).is('body') ? $(window) : $(element)
	      , href
	    this.options = $.extend({}, $.fn.scrollspy.defaults, options)
	    this.$scrollElement = $element.on('scroll.scroll-spy.data-api', process)
	    this.selector = (this.options.target
	      || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	      || '') + ' .nav li > a'
	    this.$body = $('body')
	    this.refresh()
	    this.process()
	  }
	
	  ScrollSpy.prototype = {
	
	      constructor: ScrollSpy
	
	    , refresh: function () {
	        var self = this
	          , $targets
	
	        this.offsets = $([])
	        this.targets = $([])
	
	        $targets = this.$body
	          .find(this.selector)
	          .map(function () {
	            var $el = $(this)
	              , href = $el.data('target') || $el.attr('href')
	              , $href = /^#\w/.test(href) && $(href)
	            return ( $href
	              && $href.length
	              && [[ $href.position().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]] ) || null
	          })
	          .sort(function (a, b) { return a[0] - b[0] })
	          .each(function () {
	            self.offsets.push(this[0])
	            self.targets.push(this[1])
	          })
	      }
	
	    , process: function () {
	        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
	          , scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
	          , maxScroll = scrollHeight - this.$scrollElement.height()
	          , offsets = this.offsets
	          , targets = this.targets
	          , activeTarget = this.activeTarget
	          , i
	
	        if (scrollTop >= maxScroll) {
	          return activeTarget != (i = targets.last()[0])
	            && this.activate ( i )
	        }
	
	        for (i = offsets.length; i--;) {
	          activeTarget != targets[i]
	            && scrollTop >= offsets[i]
	            && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
	            && this.activate( targets[i] )
	        }
	      }
	
	    , activate: function (target) {
	        var active
	          , selector
	
	        this.activeTarget = target
	
	        $(this.selector)
	          .parent('.active')
	          .removeClass('active')
	
	        selector = this.selector
	          + '[data-target="' + target + '"],'
	          + this.selector + '[href="' + target + '"]'
	
	        active = $(selector)
	          .parent('li')
	          .addClass('active')
	
	        if (active.parent('.dropdown-menu').length)  {
	          active = active.closest('li.dropdown').addClass('active')
	        }
	
	        active.trigger('activate')
	      }
	
	  }
	
	
	 /* SCROLLSPY PLUGIN DEFINITION
	  * =========================== */
	
	  var old = $.fn.scrollspy
	
	  $.fn.scrollspy = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('scrollspy')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.scrollspy.Constructor = ScrollSpy
	
	  $.fn.scrollspy.defaults = {
	    offset: 10
	  }
	
	
	 /* SCROLLSPY NO CONFLICT
	  * ===================== */
	
	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }
	
	
	 /* SCROLLSPY DATA-API
	  * ================== */
	
	  $(window).on('load', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      $spy.scrollspy($spy.data())
	    })
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* ========================================================
	 * bootstrap-tab.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#tabs
	 * ========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ======================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* TAB CLASS DEFINITION
	  * ==================== */
	
	  var Tab = function (element) {
	    this.element = $(element)
	  }
	
	  Tab.prototype = {
	
	    constructor: Tab
	
	  , show: function () {
	      var $this = this.element
	        , $ul = $this.closest('ul:not(.dropdown-menu)')
	        , selector = $this.attr('data-target')
	        , previous
	        , $target
	        , e
	
	      if (!selector) {
	        selector = $this.attr('href')
	        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	      }
	
	      if ( $this.parent('li').hasClass('active') ) return
	
	      previous = $ul.find('.active:last a')[0]
	
	      e = $.Event('show', {
	        relatedTarget: previous
	      })
	
	      $this.trigger(e)
	
	      if (e.isDefaultPrevented()) return
	
	      $target = $(selector)
	
	      this.activate($this.parent('li'), $ul)
	      this.activate($target, $target.parent(), function () {
	        $this.trigger({
	          type: 'shown'
	        , relatedTarget: previous
	        })
	      })
	    }
	
	  , activate: function ( element, container, callback) {
	      var $active = container.find('> .active')
	        , transition = callback
	            && $.support.transition
	            && $active.hasClass('fade')
	
	      function next() {
	        $active
	          .removeClass('active')
	          .find('> .dropdown-menu > .active')
	          .removeClass('active')
	
	        element.addClass('active')
	
	        if (transition) {
	          element[0].offsetWidth // reflow for transition
	          element.addClass('in')
	        } else {
	          element.removeClass('fade')
	        }
	
	        if ( element.parent('.dropdown-menu') ) {
	          element.closest('li.dropdown').addClass('active')
	        }
	
	        callback && callback()
	      }
	
	      transition ?
	        $active.one($.support.transition.end, next) :
	        next()
	
	      $active.removeClass('in')
	    }
	  }
	
	
	 /* TAB PLUGIN DEFINITION
	  * ===================== */
	
	  var old = $.fn.tab
	
	  $.fn.tab = function ( option ) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('tab')
	      if (!data) $this.data('tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.tab.Constructor = Tab
	
	
	 /* TAB NO CONFLICT
	  * =============== */
	
	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }
	
	
	 /* TAB DATA-API
	  * ============ */
	
	  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
	    e.preventDefault()
	    $(this).tab('show')
	  })
	
	}(__webpack_provided_window_dot_jQuery);/* =============================================================
	 * bootstrap-typeahead.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#typeahead
	 * =============================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function($){
	
	  "use strict"; // jshint ;_;
	
	
	 /* TYPEAHEAD PUBLIC CLASS DEFINITION
	  * ================================= */
	
	  var Typeahead = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.typeahead.defaults, options)
	    this.matcher = this.options.matcher || this.matcher
	    this.sorter = this.options.sorter || this.sorter
	    this.highlighter = this.options.highlighter || this.highlighter
	    this.updater = this.options.updater || this.updater
	    this.source = this.options.source
	    this.$menu = $(this.options.menu)
	    this.shown = false
	    this.listen()
	  }
	
	  Typeahead.prototype = {
	
	    constructor: Typeahead
	
	  , select: function () {
	      var val = this.$menu.find('.active').attr('data-value')
	      this.$element
	        .val(this.updater(val))
	        .change()
	      return this.hide()
	    }
	
	  , updater: function (item) {
	      return item
	    }
	
	  , show: function () {
	      var pos = $.extend({}, this.$element.position(), {
	        height: this.$element[0].offsetHeight
	      })
	
	      this.$menu
	        .insertAfter(this.$element)
	        .css({
	          top: pos.top + pos.height
	        , left: pos.left
	        })
	        .show()
	
	      this.shown = true
	      return this
	    }
	
	  , hide: function () {
	      this.$menu.hide()
	      this.shown = false
	      return this
	    }
	
	  , lookup: function (event) {
	      var items
	
	      this.query = this.$element.val()
	
	      if (!this.query || this.query.length < this.options.minLength) {
	        return this.shown ? this.hide() : this
	      }
	
	      items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source
	
	      return items ? this.process(items) : this
	    }
	
	  , process: function (items) {
	      var that = this
	
	      items = $.grep(items, function (item) {
	        return that.matcher(item)
	      })
	
	      items = this.sorter(items)
	
	      if (!items.length) {
	        return this.shown ? this.hide() : this
	      }
	
	      return this.render(items.slice(0, this.options.items)).show()
	    }
	
	  , matcher: function (item) {
	      return ~item.toLowerCase().indexOf(this.query.toLowerCase())
	    }
	
	  , sorter: function (items) {
	      var beginswith = []
	        , caseSensitive = []
	        , caseInsensitive = []
	        , item
	
	      while (item = items.shift()) {
	        if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
	        else if (~item.indexOf(this.query)) caseSensitive.push(item)
	        else caseInsensitive.push(item)
	      }
	
	      return beginswith.concat(caseSensitive, caseInsensitive)
	    }
	
	  , highlighter: function (item) {
	      var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
	      return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
	        return '<strong>' + match + '</strong>'
	      })
	    }
	
	  , render: function (items) {
	      var that = this
	
	      items = $(items).map(function (i, item) {
	        i = $(that.options.item).attr('data-value', item)
	        i.find('a').html(that.highlighter(item))
	        return i[0]
	      })
	
	      items.first().addClass('active')
	      this.$menu.html(items)
	      return this
	    }
	
	  , next: function (event) {
	      var active = this.$menu.find('.active').removeClass('active')
	        , next = active.next()
	
	      if (!next.length) {
	        next = $(this.$menu.find('li')[0])
	      }
	
	      next.addClass('active')
	    }
	
	  , prev: function (event) {
	      var active = this.$menu.find('.active').removeClass('active')
	        , prev = active.prev()
	
	      if (!prev.length) {
	        prev = this.$menu.find('li').last()
	      }
	
	      prev.addClass('active')
	    }
	
	  , listen: function () {
	      this.$element
	        .on('focus',    $.proxy(this.focus, this))
	        .on('blur',     $.proxy(this.blur, this))
	        .on('keypress', $.proxy(this.keypress, this))
	        .on('keyup',    $.proxy(this.keyup, this))
	
	      if (this.eventSupported('keydown')) {
	        this.$element.on('keydown', $.proxy(this.keydown, this))
	      }
	
	      this.$menu
	        .on('click', $.proxy(this.click, this))
	        .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
	        .on('mouseleave', 'li', $.proxy(this.mouseleave, this))
	    }
	
	  , eventSupported: function(eventName) {
	      var isSupported = eventName in this.$element
	      if (!isSupported) {
	        this.$element.setAttribute(eventName, 'return;')
	        isSupported = typeof this.$element[eventName] === 'function'
	      }
	      return isSupported
	    }
	
	  , move: function (e) {
	      if (!this.shown) return
	
	      switch(e.keyCode) {
	        case 9: // tab
	        case 13: // enter
	        case 27: // escape
	          e.preventDefault()
	          break
	
	        case 38: // up arrow
	          e.preventDefault()
	          this.prev()
	          break
	
	        case 40: // down arrow
	          e.preventDefault()
	          this.next()
	          break
	      }
	
	      e.stopPropagation()
	    }
	
	  , keydown: function (e) {
	      this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40,38,9,13,27])
	      this.move(e)
	    }
	
	  , keypress: function (e) {
	      if (this.suppressKeyPressRepeat) return
	      this.move(e)
	    }
	
	  , keyup: function (e) {
	      switch(e.keyCode) {
	        case 40: // down arrow
	        case 38: // up arrow
	        case 16: // shift
	        case 17: // ctrl
	        case 18: // alt
	          break
	
	        case 9: // tab
	        case 13: // enter
	          if (!this.shown) return
	          this.select()
	          break
	
	        case 27: // escape
	          if (!this.shown) return
	          this.hide()
	          break
	
	        default:
	          this.lookup()
	      }
	
	      e.stopPropagation()
	      e.preventDefault()
	  }
	
	  , focus: function (e) {
	      this.focused = true
	    }
	
	  , blur: function (e) {
	      this.focused = false
	      if (!this.mousedover && this.shown) this.hide()
	    }
	
	  , click: function (e) {
	      e.stopPropagation()
	      e.preventDefault()
	      this.select()
	      this.$element.focus()
	    }
	
	  , mouseenter: function (e) {
	      this.mousedover = true
	      this.$menu.find('.active').removeClass('active')
	      $(e.currentTarget).addClass('active')
	    }
	
	  , mouseleave: function (e) {
	      this.mousedover = false
	      if (!this.focused && this.shown) this.hide()
	    }
	
	  }
	
	
	  /* TYPEAHEAD PLUGIN DEFINITION
	   * =========================== */
	
	  var old = $.fn.typeahead
	
	  $.fn.typeahead = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('typeahead')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.typeahead.defaults = {
	    source: []
	  , items: 8
	  , menu: '<ul class="typeahead dropdown-menu"></ul>'
	  , item: '<li><a href="#"></a></li>'
	  , minLength: 1
	  }
	
	  $.fn.typeahead.Constructor = Typeahead
	
	
	 /* TYPEAHEAD NO CONFLICT
	  * =================== */
	
	  $.fn.typeahead.noConflict = function () {
	    $.fn.typeahead = old
	    return this
	  }
	
	
	 /* TYPEAHEAD DATA-API
	  * ================== */
	
	  $(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
	    var $this = $(this)
	    if ($this.data('typeahead')) return
	    $this.typeahead($this.data())
	  })
	
	}(__webpack_provided_window_dot_jQuery);
	/* ==========================================================
	 * bootstrap-affix.js v2.3.2
	 * http://twbs.github.com/bootstrap/javascript.html#affix
	 * ==========================================================
	 * Copyright 2013 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* AFFIX CLASS DEFINITION
	  * ====================== */
	
	  var Affix = function (element, options) {
	    this.options = $.extend({}, $.fn.affix.defaults, options)
	    this.$window = $(window)
	      .on('scroll.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.affix.data-api',  $.proxy(function () { setTimeout($.proxy(this.checkPosition, this), 1) }, this))
	    this.$element = $(element)
	    this.checkPosition()
	  }
	
	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return
	
	    var scrollHeight = $(document).height()
	      , scrollTop = this.$window.scrollTop()
	      , position = this.$element.offset()
	      , offset = this.options.offset
	      , offsetBottom = offset.bottom
	      , offsetTop = offset.top
	      , reset = 'affix affix-top affix-bottom'
	      , affix
	
	    if (typeof offset != 'object') offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function') offsetTop = offset.top()
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()
	
	    affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ?
	      false    : offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ?
	      'bottom' : offsetTop != null && scrollTop <= offsetTop ?
	      'top'    : false
	
	    if (this.affixed === affix) return
	
	    this.affixed = affix
	    this.unpin = affix == 'bottom' ? position.top - scrollTop : null
	
	    this.$element.removeClass(reset).addClass('affix' + (affix ? '-' + affix : ''))
	  }
	
	
	 /* AFFIX PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.affix
	
	  $.fn.affix = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('affix')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.affix.Constructor = Affix
	
	  $.fn.affix.defaults = {
	    offset: 0
	  }
	
	
	 /* AFFIX NO CONFLICT
	  * ================= */
	
	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }
	
	
	 /* AFFIX DATA-API
	  * ============== */
	
	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	        , data = $spy.data()
	
	      data.offset = data.offset || {}
	
	      data.offsetBottom && (data.offset.bottom = data.offsetBottom)
	      data.offsetTop && (data.offset.top = data.offsetTop)
	
	      $spy.affix(data)
	    })
	  })
	
	
	}(__webpack_provided_window_dot_jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(112),
	  __webpack_require__(113)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, Field, DateTimeUtil, template) {
	
	  return Plumage.view.form.fields.Calendar = Field.extend(
	  /** @lends Plumage.view.calendar.Calendar.prototype */
	  {
	    template: template,
	
	    className: 'calendar-view',
	
	    /** Which month to show. 0 indexed number */
	    month: undefined,
	
	    /** Which year to show. eg 2014 */
	    year: undefined,
	
	    minDateAttr: 'minDate',
	
	    /** min selectable date, inclusive. Set minDate with setMinDate */
	    minDate: undefined,
	
	    maxDateAttr: 'maxDate',
	
	    /** max selectable date, inclusive. Set maxDate with setMaxDate */
	    maxDate: undefined,
	
	    /** for showing selected range */
	    fromAttr: undefined,
	
	    /** for showing selected range */
	    toAttr: undefined,
	
	    /** Show week index in a column on the left? */
	    showWeekNumbers: false,
	
	    utc: false,
	
	    locale: {
	      weekLabel: 'W',
	      customRangeLabel: 'Custom Range',
	      daysOfWeek: moment.weekdaysMin().slice(),
	      monthNames: moment.monthsShort().slice(),
	      firstDay: 0
	    },
	
	    events: {
	      'click .prev': 'onPrevClick',
	      'click .next': 'onNextClick',
	      'click .day': 'onDayClick'
	    },
	
	    /**
	     * View that renders a selectable calendar.
	     *
	     * Useful when incoporated in fields like [DateField]{@link Plumage.view.form.fields.DateField}
	     * and [DateRangeField]{@link Plumage.view.form.fields.DateRangeField}.
	     *
	     * Not a [ModelView]{@link Plumage.view.ModelView}, but keeps and updates its own view state
	     * ([selectedDate]{@link Plumage.view.calendar.Calendar#selectedDate}, [month]{@link Plumage.view.calendar.Calendar#month},
	     * [year]{@link Plumage.view.calendar.Calendar#year},
	     *
	     * Calendar can also limit selectable dates with [minDate]{@link Plumage.view.calendar.Calendar#minDate} and
	     * [maxDate]{@link Plumage.view.calendar.Calendar#maxDate}, and highlight a selected range (useful in a date range picker)
	     * with [fromDate]{@link Plumage.view.calendar.Calendar#fromDate} and
	     * [toDate]{@link Plumage.view.calendar.Calendar#toDate}.
	     *
	     * Emitted events: prevclick, nextclick, dayclick
	     *
	     * @constructs
	     * @extends Plumage.view.View
	     */
	    initialize: function() {
	      Field.prototype.initialize.apply(this, arguments);
	
	      var now = this.utc ? moment.utc() : moment();
	      this.month = this.month !== undefined ? this.month : now.month();
	      this.year = this.year ? this.year : now.year();
	    },
	
	    getTemplateData: function() {
	      var data = _.clone(this.locale);
	
	      var calendar = this.getCalendarDates(this.month, this.year);
	
	      for(var i=0;i<calendar.length;i++) {
	        var week = calendar[i];
	        for(var j=0;j<week.length;j++) {
	          var day = week[j];
	          _.extend(day, {
	            number: day.date[2],
	            cls: this.getClassesForDate(day.date, i, j).join(' ')
	          });
	        }
	      }
	      return {
	        locale: this.locale,
	        month: this.locale.monthNames[this.month],
	        year: this.year,
	        prevAvailable: this.isPrevMonthAvailable(),
	        nextAvailable: this.isNextMonthAvailable(),
	        showWeekNumbers: this.showWeekNumbers,
	        calendar: calendar
	      };
	    },
	
	    update: function(isLoad) {
	      if (this.isRendered && this.shouldRender(isLoad)) {
	        this.render();
	      }
	    },
	
	    getValueFromModel: function() {
	      var result = Field.prototype.getValueFromModel.apply(this, arguments);
	      if ($.isNumeric(result)) {
	        return result;
	      }
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.getValue();
	
	      var modelValue = model.get(this.valueAttr);
	      if (modelValue) {
	        //don't change hour
	        var m = this.utc ? moment.utc(modelValue) : moment(modelValue);
	        var date = this.getSelectedDate();
	        m.year(date[0]);
	        m.month(date[1]);
	        m.date(date[2]);
	        value = m.valueOf();
	      }
	      return model.set(this.valueAttr, value);
	    },
	
	    /**
	     * Set the month to display (view state), and update.
	     */
	    setMonth: function(month, year) {
	      this.month = month;
	      this.year = year;
	      this.update();
	    },
	
	    setValue: function(value, options) {
	      if (!this.isDateInMinMax(this.toDateTuple(value))) {
	        return;
	      }
	      Field.prototype.setValue.apply(this, arguments);
	      this.update();
	    },
	
	    valueChanged: function() {
	      var value = this.getValue();
	      if (value) {
	        var m = this.utc ? moment.utc(value) : moment(value);
	        this.month = m.month();
	        this.year = m.year();
	      }
	    },
	
	    /**
	     * Get the minimum selectable date (inclusive)
	     */
	    getMinDate: function() {
	      if (this.minDate) {
	        return this.minDate;
	      }
	      if (this.model && this.minDateAttr) {
	        return this.toDateTuple(this.model.get(this.minDateAttr));
	      }
	      return null;
	    },
	
	    setMinDate: function(minDate) {
	      this.minDate = this.toDateTuple(minDate);
	    },
	
	    /**
	     * Set the maximum selectable date (inclusive)
	     */
	    getMaxDate: function() {
	      if (this.maxDate) {
	        return this.maxDate;
	      }
	      if (this.model && this.maxDateAttr) {
	        return this.toDateTuple(this.model.get(this.maxDateAttr));
	      }
	      return null;
	    },
	
	    setMaxDate: function(maxDate) {
	      this.maxDate = this.toDateTuple(maxDate);
	    },
	
	    //
	    // Helpers
	    //
	
	    toDateTuple: function(date) {
	      if (!date) {
	        return null;
	      }
	      date = DateTimeUtil.parseRelativeDate(date);
	      if ($.isArray(date)) {
	        return date;
	      }
	      var m = date;
	      if ($.isNumeric(m)) {
	        m = this.utc ? moment.utc(m) : moment(m);
	      } else {
	        m = moment(m);
	      }
	      return [m.year(), m.month(), m.date()];
	    },
	
	    getSelectedDate: function() {
	      var value = this.getValue();
	      if (value) {
	        return this.toDateTuple(this.getValue());
	      }
	      return null;
	    },
	
	    getFromDate: function() {
	      if (this.model && this.fromAttr) {
	        return this.toDateTuple(this.model.get(this.fromAttr));
	      }
	      return null;
	    },
	
	    getToDate: function() {
	      if (this.model && this.toAttr) {
	        return this.toDateTuple(this.model.get(this.toAttr));
	      }
	      return null;
	    },
	
	    /**
	     * Helper: Get 2d array of days
	     */
	    getCalendarDates: function (month, year) {
	      var calendar = [];
	      var curDate = this.getFirstDate(month, year);
	      for(var i=0;i<6;i++) {
	        var week = [];
	        for(var j=0;j<7;j++) {
	          week.push({
	            date: curDate,
	          });
	          var m = moment(curDate).add('day', 1);
	          curDate = [m.year(), m.month(), m.date()];
	        }
	        calendar.push(week);
	      }
	      return calendar;
	    },
	
	    /**
	     * Helper: Get first day on calendar page for month, year
	     */
	    getFirstDate: function(month, year) {
	      var firstDay = moment([year, month, 1]),
	        monthAgo = moment(firstDay).subtract('month', 1);
	
	      var daysInLastMonth = monthAgo.daysInMonth(),
	        dayOfWeek = firstDay.day(),
	        firstDate = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
	
	      if (firstDate > daysInLastMonth) {
	        firstDate -= 7;
	      }
	      if (dayOfWeek === this.locale.firstDay) {
	        firstDate = daysInLastMonth - 6;
	      }
	      return [monthAgo.year(), monthAgo.month(), firstDate];
	    },
	
	    /**
	     * Helper: Get CSS classes for a day element.
	     */
	    getClassesForDate: function(date, row, col) {
	      var inMonth = this.isDateTupleInMonth(date);
	      var classes = [
	        this.isDateInMinMax(date) ? 'active' : 'disabled',
	        inMonth ? null : 'off',
	        _.isEqual(date, this.getSelectedDate()) ? 'selected' : null,
	        inMonth && _.isEqual(date, this.getFromDate()) ? 'start-date' : null,
	        inMonth && _.isEqual(date, this.getToDate()) ? 'end-date' : null,
	        this.isDateInSelectedRange(date) ? 'in-range' : null,
	        this.getShadowClass(date, row, col)
	      ];
	
	      return _.compact(classes);
	    },
	
	    /**
	     * Helper: Get box shadow class for dates off the current month.
	     */
	    getShadowClass: function(date, row, col) {
	      if (!this.isDateTupleInMonth(date)) {
	        if (row < 2) {
	          var nextWeek = this.toDateTuple(moment(date).add('day', 7)),
	            tomorrow = this.toDateTuple(moment(date).add('day', 1));
	          if (this.isDateTupleInMonth(nextWeek)) {
	            if (col < 6 && this.isDateTupleInMonth(tomorrow)) {
	              return 'shadow-bottom-right';
	            } else {
	              return 'shadow-bottom';
	            }
	          }
	        } else {
	          var lastWeek = this.toDateTuple(moment(date).subtract('day', 7)),
	            yesterday = this.toDateTuple(moment(date).subtract('day', 1));
	          if (this.isDateTupleInMonth(lastWeek)) {
	            if (col > 0 && this.isDateTupleInMonth(yesterday)) {
	              return 'shadow-top-left';
	            } else {
	              return 'shadow-top';
	            }
	          }
	        }
	      }
	      return null;
	    },
	
	    isDateTupleInRange: function(date, minDate, maxDate) {
	      return (!minDate || moment(date) >= moment(minDate)) && (!maxDate || moment(date) <= moment(maxDate));
	    },
	
	    isDateInSelectedRange: function(date) {
	      var fromDate = this.getFromDate(),
	        toDate = this.getToDate();
	      if (!fromDate || !toDate) {
	        return false;
	      }
	      return this.isDateTupleInRange(date, fromDate, toDate);
	    },
	
	    isDateInMinMax: function(date) {
	      date = this.toDateTuple(date);
	      return this.isDateTupleInRange(date, this.getMinDate(), this.getMaxDate());
	    },
	
	    isDateTupleInMonth: function(date) {
	      return date[1] === this.month;
	    },
	
	    isPrevMonthAvailable: function() {
	      var m = moment([this.year, this.month, 1]).subtract('day', 1);
	      return this.isDateInMinMax(this.toDateTuple(m));
	    },
	
	    isNextMonthAvailable: function() {
	      var firstDate = moment([this.year, this.month, 1]),
	        m = moment([this.year, this.month, firstDate.daysInMonth()]).add('day', 1);
	      return this.isDateInMinMax(this.toDateTuple(m));
	    },
	
	    getDateFromDayEl: function(el) {
	      el = $(el);
	      var td = el.parent();
	      var dateNumber = Number(el.text());
	
	      if (td.hasClass('off')) {
	        var offMonth = moment([this.year, this.month, 1]);
	        if (td.data('row') < 3) {
	          offMonth = offMonth.subtract('month', 1);
	        } else {
	          offMonth = offMonth.add('month', 1);
	        }
	        return this.toDateTuple(offMonth.date(dateNumber));
	      }
	      return [this.year, this.month, dateNumber];
	    },
	
	    //
	    // EventHandlers
	    //
	
	    onModelChange: function (e) {
	      if (e.changed[this.valueAttr] !== undefined || e.changed[this.minDateAttr] !== undefined || e.changed[this.maxDateAttr] !== undefined) {
	        this.updateValueFromModel();
	      }
	    },
	
	    onPrevClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var lastMonth = moment([this.year, this.month, 1]).subtract('month', 1);
	      this.setMonth(lastMonth.month(), lastMonth.year());
	
	      this.trigger('prevclick', this);
	    },
	
	    onNextClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var nextMonth = moment([this.year, this.month, 1]).add('month', 1);
	      this.setMonth(nextMonth.month(), nextMonth.year());
	
	      this.trigger('nextclick', this);
	    },
	
	    onDayClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var td = $(e.target).parent();
	      if (!td.hasClass('disabled')) {
	        var date = this.getDateFromDayEl(e.target),
	          m = this.utc ? moment.utc(date) : moment(date);
	        this.setValue(m.valueOf());
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(7),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, moment, Plumage) {
	
	  Plumage.util.defaultDateFormat = 'MMM Do YYYY, HH:mm:ss';
	
	  return Plumage.util.DateTimeUtil = {
	
	    parseRelativeDate: function(date, utc) {
	      var today = utc ? moment.utc({hour: 0}) : moment({hour: 0});
	      if (date === 'today') {
	        date = today;
	      } else if ($.isPlainObject(date)) {
	        date = today.clone().add(date);
	      }
	      return date;
	    },
	
	    isSameDay: function(date1, date2, isUtc) {
	      if (!date1 || !date2) {
	        return false;
	      }
	      if ($.isNumeric(date1)) {
	        date1 = isUtc ? moment.utc(date1) : moment(date1);
	      }
	      if ($.isNumeric(date2)) {
	        date2 = isUtc ? moment.utc(date2) : moment(date2);
	      }
	      return date1.format('YYYY-MM-DD') === date2.format('YYYY-MM-DD');
	    },
	
	    isDateInRange: function(date, minDate, maxDate, isUtc) {
	      if ($.isNumeric(date)) {
	        date = isUtc ? moment.utc(date) : moment(date);
	      }
	
	      return !((minDate && ! Plumage.util.DateTimeUtil.isSameDay(date, minDate) && date.isBefore(minDate)) || (
	          maxDate && ! Plumage.util.DateTimeUtil.isSameDay(date, maxDate, isUtc) && date.isAfter(maxDate)));
	    },
	
	    formatDate: function(timestamp, dateFormat) {
	      dateFormat = dateFormat || Plumage.util.defaultDateFormat;
	      return new moment(Number(timestamp)).format(dateFormat);
	    },
	
	    formatDateUTC: function(timestamp, dateFormat) {
	      dateFormat = dateFormat || Plumage.util.defaultDateFormat;
	      return new moment(Number(timestamp)).utc().format(dateFormat);
	    },
	
	    formatDateFromNow: function(timestamp) {
	      return moment(Number(timestamp)).fromNow();
	    },
	
	    formatDuration: function(millis) {
	      if (millis <= 0) {
	        return 'None';
	      }
	      var d = moment.duration(millis), result = '',
	        days = Math.floor(d.valueOf()/(3600000*24)),
	        hours = d.hours(),
	        minutes = d.minutes(),
	        started = false;
	
	      if (millis < 60000) {
	        return d.seconds() + ' seconds';
	      }
	      if(days > 0) {
	        started = true;
	        result += days + (days === 1 ? ' day ' : ' days ');
	      }
	
	      if(hours > 0 || started) {
	        started = true;
	        result += hours + (hours === 1 ? ' hour ' : ' hours ');
	      }
	
	      if(minutes > 0 || started) {
	        started = true;
	        result += minutes + (minutes === 1 ? ' minute' : ' minutes');
	      }
	
	      return result;
	    },
	
	    formatDurationShort: function(millis) {
	      if (millis <= 0) {
	        return 'None';
	      }
	      var d = moment.duration(millis), result = '',
	        days = Math.floor(d.valueOf()/(3600000*24)),
	        hours = d.hours(),
	        minutes = d.minutes(),
	        started = false;
	
	      if (millis < 60000) {
	        return d.seconds() + 's';
	      }
	
	      if(days > 0) {
	        started = true;
	        result += days + 'd ';
	      }
	
	      if(hours > 0 || started) {
	        started = true;
	        result += hours + 'h ';
	      }
	
	      if(minutes > 0 || started) {
	        started = true;
	        result += minutes + 'm';
	      }
	      return result;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "<table cellpadding=\"0\" cellspacing=\"0\">\n<thead>\n<tr>\n\t{{#if showWeekNumbers}}\n\t  <th></th>\n\t{{/if}}\n\t{{#if prevAvailable}}\n\t  <th class=\"prev available\"><i class=\"icon-arrow-left\"></i></th>\n\t{{else}}\n\t  <th></th>\n\t{{/if}}\n  <th colspan=\"5\" style=\"width: auto\">{{month}} {{year}}</th>\n  {{#if nextAvailable}}\n    <th class=\"next available\"><i class=\"icon-arrow-right\"></i></th>\n  {{else}}\n    <th></th>\n  {{/if}}\n</tr>\n<tr>\n\t{{#if showWeekNumbers}}\n\t  <th class=\"week\">{{weekLabel}}</th>\n\t{{/if}}\n\t{{#each locale.daysOfWeek}}\n\t  <th>{{.}}</th>\n\t{{/each}}\n</tr>\n</thead>\n<tbody>\n{{#each calendar}}\n{{setIndex @index}}\n<tr>\n  {{#if showWeekNumbers}}\n    <td class=\"week\">?</td>\n  {{/if}}\n  {{#each .}}\n    <td class=\"{{cls}}\" data-row=\"{{../index}}\" data-col=\"{{@index}}\">\n\t    <div class=\"day {{cname}}\">{{number}}</div>\n\t  </td>\n  {{/each}}\n</tr>\n{{/each}}\n\n</tbody>\n</table>"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "<div class=\"calendar-wrap\">\n  <div class=\"date-field\">\n    <label class=\"control-label\" for=\"daterangepicker_from\">From</label>\n    <span class=\"from-date\"></span>\n    {{#if showHourSelect}}<span class=\"from-hour\"></span>{{/if}}\n  </div>\n  <div class=\"from-calendar\"></div>\n</div>\n\n<div class=\"calendar-wrap\">\n  <div class=\"date-field\">\n    <label class=\"control-label\" for=\"daterangepicker_to\">To</label>\n    <span class=\"to-date\"></span>\n    {{#if showHourSelect}}<span class=\"to-hour\"></span>{{/if}}\n  </div>\n  <div class=\"to-calendar\"></div>\n</div>\n\n<div class=\"ranges-wrap\">\n  <ul class=\"ranges\">\n    {{#ranges}}\n      <li><a href=\"#\">{{name}}</a></li>\n    {{/ranges}}\n  </ul>\n  <button class=\"btn btn-small apply\">Apply</button>\n  <a href=\"#\" class=\"cancel\">cancel</a>\n</div>\n"

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(88),
	  __webpack_require__(116),
	  __webpack_require__(118)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Plumage, Collection, Activity) {
	
	  return Plumage.collection.ActivityCollection = Collection.extend({
	    model: Activity
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(100),
	  __webpack_require__(117),
	  __webpack_require__(101)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model, Filter, requestManager) {
	
	  Plumage.collection.Collection = Model.extend(
	  /** @lends Plumage.collection.Collection.prototype */
	  {
	
	    urlRoot: undefined,
	
	    viewAttrs: ['query', 'sortDir', 'sortField', 'page', 'pageSize'],
	
	    resultsPath: 'results',
	
	    /** Perform view changes like sorting and filtering in memory (as opposed to on the server)? */
	    processInMemory: false,
	
	    /** Unsorted and unfiltered models when processInMemory is true for reference */
	    originalModels: undefined,
	
	    /** Default attribute values */
	    defaultMeta: {
	      page: 0,
	      pageSize: 200
	    },
	
	    /** If true, will automatically create filters relationship */
	    hasFilters: true,
	
	    relationships: {},
	
	    selections: undefined,
	
	    /**
	     * Base Collection class for Plumage collections.
	     *
	     * Based on Backbone.Collection, but extends Plumage.Model for additional features like
	     * viewState, attributes and relationships.
	     *
	     * Collections have parameters that affect its display eg sortField.
	     * Rather than use JS attributes like Backbone.Collection, use Model attributes (by extending Plumage.model.Model)
	     * which allows model binding. Then the Field can be agnostic about whether its binding a model's attribute or a
	     * collection's pageSize or sortField. This also gets us view state and query params.
	     *
	     * A Collection can also have relationships like a Model. eg Collections have relations collection of Filters.
	     * This allows Filter Views to bind to a collection's Filters as if they were any other Model.
	     *
	     * #### Additional Features
	     *
	     * ##### Attributes and View State
	     *
	     * ##### Filters and Relationships
	     *
	     * ##### processInMemory
	     *
	     * By default, calling [load]{@link Plumage.collection.Collection#load} after changing view state (sort, filter etc)
	     * queries the server for new data. If [processInMemory]{@link Plumage.collection.Collection#processInMemory}
	     * has been set however, load is short circuited with filtering, sorting and searching performed in memory.
	     * Useful when you don't have that much data and you don't want to adding sorting/paging etc to your server.
	     *
	     * Unless the relationship has remote = true, related Collections automatically have processInMemory set.
	     *
	     * @constructs
	     * @extends Plumage.model.Model
	     */
	    constructor : function (models, options ) {
	      //define filters relationship here to avoid circular dependency
	      if (this.hasFilters && !this.relationships.filters) {
	        this.relationships.filters = {
	          modelCls: Plumage.collection.Collection.extend({
	            model: Filter,
	            urlRoot: '/',
	            relationships: {},
	            hasFilters: false,
	          }),
	          forceCreate: true,
	          propagateEvents: true
	        };
	      }
	      Model.apply( this, arguments );
	
	      options = (options || {});
	      if (options.model) {
	        this.model = options.model;
	      }
	
	      this._reset();
	      if (models) {
	        this.reset(models, _.extend({silent: true}, options));
	      }
	
	      if (this.urlRoot === undefined && this.model) {
	        this.urlRoot = this.model.prototype.urlRoot;
	      }
	    },
	
	    initialize: function(models, options) {
	      options = options || {};
	      var meta = _.extend(_.clone(this.defaultMeta), options.meta || {});
	      this.set(meta, {silent: true});
	      delete options.meta;
	      _.extend(this, options);
	    },
	
	    hasUrl: function() {
	      return true;
	    },
	
	    /**
	     * This Collection's url. Returns an attribute or option named 'href' if it exists.
	     * Otherwise uses urlRoot like backbone.
	     */
	    url: function () {
	      var href = this.href || this.get('href');
	      if (href) {
	        return href;
	      }
	      return this.urlRoot;
	    },
	
	
	    /**
	     * Overridden from Model. Takes a special attributes 'models' to use as collection data,
	     * so that attributes and models can be set from the same data.
	     */
	    set: function(key, val, options) {
	      var attr, attrs, unset, changes, silent, changing, prev, current;
	      if (key === null) {
	        return this;
	      }
	
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }
	
	      options = options || {};
	      attrs = _.clone(attrs);
	
	      if (attrs.models) {
	        if (this.processInMemory) {
	          this.resetInMemory(attrs.models);
	        } else {
	          this.reset(attrs.models);
	        }
	        delete attrs.models;
	      }
	      return Model.prototype.set.apply(this, [attrs, options]);
	    },
	
	    //
	    // Collection CRUD
	    //
	
	    /**
	     * Copied from Backbone.Collection
	     * When you have more items than you want to add or remove individually,
	     * you can reset the entire setCollection with a new list of models, without firing
	     * you can reset the entire set with a new list of models, without firing
	     * any granular `add` or `remove` events. Fires `reset` when finished.
	     * Useful for bulk operations and optimizations.
	     * @param {Array} models Array of model data
	     * @param {Object} options Add options
	     */
	    reset: function(models, options) {
	      options = (options || {});
	      this.resetting = true;
	
	      for (var i = 0, l = this.models.length; i < l; i++) {
	        this._removeReference(this.models[i]);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	
	      this.resetting = false;
	
	      if (!options.silent) {
	        this.trigger('reset', this, options);
	      }
	      return models;
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Add a model to the end of the collection.
	     */
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Remove a model from the end of the collection.
	     */
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      this.remove(model, options);
	      return model;
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Add a model to the beginning of the collection.
	     */
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Remove a model from the beginning of the collection.
	     */
	    shift: function(options) {
	      var model = this.at(0);
	      this.remove(model, options);
	      return model;
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Slice out a sub-array of models from the collection.
	     */
	    slice: function() {
	      return [].slice.apply(this.models, arguments);
	    },
	
	    /**
	     * Get the model with the given id
	     * @param {string} obj The id
	     */
	    getById: function(obj) {
	      if (obj === void 0) {
	        return void 0;
	      }
	      return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
	    },
	
	    /**
	     * get the model at the given index.
	     * @param {Number} index The index
	     */
	    at: function(index) {
	      return this.models[index];
	    },
	
	    /** Add a model, or list of models to the set. */
	    add: function(models, options) {
	      return this.setCollection(models, _.extend({merge: false}, options, {add: true, remove: false}));
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Remove a model, or a list of models from the set.
	     */
	    remove: function(models, options) {
	      var singular = !_.isArray(models);
	      models = singular ? [models] : _.clone(models);
	      options = (options || {});
	      var i, l, index, model;
	      for (i = 0, l = models.length; i < l; i++) {
	        model = models[i] = this.getById(models[i]);
	        if (!model) {
	          continue;
	        }
	        delete this._byId[model.id];
	        delete this._byId[model.cid];
	        index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;
	
	        if (this.originalModels) {
	          i = _.indexOf(this.originalModels, model);
	          if (i >=0 ) {
	            delete this.originalModels[i];
	          }
	        }
	
	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }
	        this._removeReference(model);
	      }
	      return singular ? models[0] : models;
	    },
	
	    //
	    // Advanced CRUD
	    //
	
	    /**
	     * Copied from Backbone.Collection
	     * Return models with matching attributes. Useful for simple cases of `filter`.
	     */
	    where: function(attrs, first) {
	      if (_.isEmpty(attrs)) {
	        return first ? void 0 : [];
	      }
	      return this[first ? 'find' : 'filter'](function(model) {
	        for (var key in attrs) {
	          if (attrs[key] !== model.get(key)) {
	            return false;
	          }
	        }
	        return true;
	      });
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     *
	     * Return the first model with matching attributes. Useful for simple cases
	     * of `find`.
	     */
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },
	
	    /**
	     * Copied from Backbone.Collection
	     * Pluck an attribute from each model in the collection.
	     */
	    pluck: function(attr) {
	      return _.invoke(this.models, 'get', attr);
	    },
	
	    /**
	     * Create a new collection with an identical list of models as this one.
	     */
	    clone: function() {
	      var result = new this.constructor(this.models, {meta: _.clone(this.attributes)});
	      if (this.hasFilters) {
	        result.setRelated('filters', this.getRelated('filters'));
	      }
	      return result;
	    },
	
	    toJSON: function(options) {
	      return this.map(function(model){ return model.toJSON(options); });
	    },
	
	    toViewJSON: function() {
	      var result = Model.prototype.toViewJSON.apply(this, arguments);
	      result.items = this.toJSON.apply(this, arguments);
	      result.size = this.size();
	      return result;
	    },
	
	    //
	    // Meta
	    //
	
	    /**
	     * Has the server indicated there is more data than what is loaded?
	     * @returns {Boolean}
	     */
	    hasMore: function() {
	      if (this.processInMemory) {
	        return false;
	      }
	
	      var total = this.get('total');
	      if (!total) {
	        total = this.get('totals') && this.get('totals').total;
	      }
	      return total && total > this.size();
	    },
	
	    /**
	     * Sets sortField and sortDir.
	     * @param {string} sortField
	     * @param {Number} sortDir
	     * @param {Boolean} refresh should load?
	     */
	    setSort: function(sortField, sortDir, refresh) {
	      this.set({sortField: sortField, sortDir: sortDir});
	      if (!this.processInMemory) {
	        this.fetched = false;
	      }
	      if (refresh) {
	        requestManager.loadModel(this);
	      }
	    },
	
	    /**
	     * Gets a named [Selection]{@link Plumage.collection.Selection} for storing selection state.
	     *
	     * A collection can have any number of named selections, which are created on demand. Selections
	     * are named so that different views can share the same selection state.
	     *
	     * @param {String} selectionName Name of selection to get.
	     */
	    getSelection: function(selectionName) {
	      if (!this.selections) {
	        this.selections = {};
	      }
	      if (!this.selections[selectionName]) {
	        this.selections[selectionName] = new Plumage.collection.Selection([], {collection: this});
	      }
	      return this.selections[selectionName];
	    },
	
	    //
	    // Filter convenience methods
	    //
	
	    getFilters: function(key) {
	      return this.getRelated('filters').where({key: key});
	    },
	
	    setFilter: function(key, value, comparison) {
	      if (comparison === undefined) {
	        comparison = 'equals';
	      }
	
	      var filter = this.getFilters(key);
	      if (filter) {
	        this.removeFilter(filter);
	      }
	      this.addFilter({key: key, value: value, comparison: comparison});
	    },
	
	    addFilter: function(filter) {
	      var filters = this.getRelated('filters');
	      filters.add(filter);
	    },
	
	    removeFilter: function(filter) {
	      this.getRelated('filters').remove(filter);
	    },
	
	    //
	    // Loading
	    //
	
	    /**
	     * Override to support processInMemory.
	     *
	     * If in memory, and already loaded, applies filters, sorting etc from view state.
	     * Note: This will never reload from the server after the first load. To force reloading from
	     * the server for a processInMemory collection, call [forceReload]{@link Plumage.collection.Collection#forceReload}
	     *
	     * If not in memory, load remote data for current model and view state.
	     */
	    load: function(options) {
	      options = (options || {});
	      if (this.processInMemory && this.fetched) {
	        if (this.buffered) {
	          throw 'Can not be both buffered and processInMemory';
	        }
	        this.onLoad(_.clone(options));
	        return;
	      }
	      return Model.prototype.load.apply(this, arguments);
	    },
	
	    /**
	     * For processInMemory collections. Force reloading from remote.
	     */
	    forceReload: function() {
	      if (!this.processInMemory) {
	        throw 'forceReload is for processInMemory collections only';
	      }
	      this.fetched = false;
	      this.originalModels = undefined;
	      this.load({reset: true});
	    },
	
	    /**
	     * Copied from Backbone.Collection. Changed to check
	     * {@link isLoadStillValid}, and not trigger load if it's not.
	     */
	    fetch: function(options) {
	      options = options ? _.clone(options) : {};
	      if (options.parse === void 0) {
	        options.parse = true;
	      }
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	
	        //
	        // CHANGE
	        //
	        if (!collection.isLoadStillValid(resp)) {
	          return;
	        }
	
	        //Update meta
	        if (options.parse) {
	          var meta = resp.meta;
	          if (meta) {
	            //No change events on load. Listen to 'load'.
	            collection.set(meta, {silent: true});
	          }
	        }
	
	        //call set/reset
	        if (options.reset) {
	          collection.reset(resp, options);
	        } else {
	          collection.setCollection(resp, options);
	        }
	
	        ///////////
	
	        if (success) {
	          success(collection, resp, options);
	        }
	        collection.trigger('sync', collection, resp, options);
	      };
	      this.wrapError(options);
	      return this.sync('read', this, options);
	    },
	
	    /**
	     * Create a new instance of a model in this collection. Add the model to the
	     * collection immediately, unless `wait: true` is passed, in which case we
	     * wait for the server to agree.
	     */
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      if (!(model = this._prepareModel(model, options))) {
	        return false;
	      }
	      if (!options.wait) {
	        this.add(model, options);
	      }
	      var collection = this;
	      var success = options.success;
	      options.success = function(model, resp, options) {
	        if (options.wait) {
	          collection.add(model, options);
	        }
	        if (success) {
	          success(model, resp, options);
	        }
	      };
	      model.save(null, options);
	      return model;
	    },
	
	    /**
	     * Do the response query params match the current values?
	     * @param {Object} resp XHR response
	     * @returns {Boolean}
	     */
	    isLoadStillValid: function(resp) {
	      var meta = resp.meta;
	      if (!meta) { return true; }
	
	      if (meta.query !== undefined && meta.query !== this.get('query')) {
	        return false;
	      }
	      if (meta.filter !== undefined && !_.isEqual(meta.filter, this.get('filter'))) {
	        return false;
	      }
	      return true;
	    },
	
	    onLoad: function(options, visited) {
	
	      options = options || {};
	      this.fetched = true;
	      this.latestLoadParams = undefined;
	
	      visited = visited || {};
	
	      this.forEach(function(model) {
	        if (!visited[model.cid]) {
	          model.onLoad(options, visited);
	        }
	      });
	
	      if (this.processInMemory) {
	        if (this.originalModels === undefined) {
	          this.originalModels = _.clone(this.models);
	        }
	        this.updateInMemory();
	      }
	
	      Model.prototype.onLoad.apply(this, arguments);
	    },
	
	    wrapError: function(options) {
	      var model = this;
	      var error = options.error;
	      options.error = function(resp) {
	        if (error) {
	          error(model, resp, options);
	        }
	        model.trigger('error', model, resp, options);
	      };
	    },
	
	
	    getQueryParams: function () {
	      var params = Model.prototype.getQueryParams.apply(this, arguments);
	
	      if (this.hasFilters) {
	        params.filters = JSON.stringify(this.getRelated('filters').toJSON());
	      }
	      return params;
	    },
	
	    /**
	     * Process In Memory
	     */
	
	    getUniqueValuesForAttribute: function(attr) {
	      if (this.processInMemory) {
	        var values = [];
	        if (this.originalModels !== undefined) {
	          _.each(this.originalModels, function(item){
	            values.push(item[attr]);
	          }, this);
	        } else {
	          this.forEach(function(item) {
	            values.push(item.get(attr));
	          }, this);
	        }
	        values.sort();
	        values = _.uniq(values, true);
	        return values;
	      } else {
	//        throw "TODO: Implement remote filter values";
	        return [];
	      }
	    },
	
	    /**
	     * Queries passed in models based on query attribute. This is for search boxes.
	     * What fields it looks in depends on the the models' matchesQuery method.
	     * Helper for [updateInMemory]{@link Plumage.collection.Collection#updateInMemory}
	     * @param {array} models Array of models to query. Not modified.
	     * @returns {array} Queried models.
	     * @private
	     */
	    _query: function(models) {
	      var query = this.get('query');
	      return _.filter(models, function(model){
	        if (model.matchesQuery) {
	          return model.matchesQuery(query);
	        } else {
	          return this.model.prototype.attrsMatchQuery(model, this.model.prototype.queryAttrs, query);
	        }
	      }, this);
	    },
	
	    /**
	     * Filters passed in models based on related Filters.
	     * Helper for [updateInMemory]{@link Plumage.collection.Collection#updateInMemory}
	     * @param {array} models Array of models to filter. Not modified.
	     * @returns {array} filtered models.
	     * @private
	     */
	    _filter: function(models) {
	      if (!this.hasRelationship('filters') || this.getRelated('filters').size() === 0) {
	        return models;
	      }
	      var filters = this.getRelated('filters');
	      return _.filter(models, function(model){
	        return filters.all(function(filter) {
	          return filter.compare(model);
	        });
	      }, this);
	    },
	
	    /**
	     * Sorts passed in models based on sortField and sortDir attributes.
	     * Helper for [updateInMemory]{@link Plumage.collection.Collection#updateInMemory}
	     * @param {array} models Array of models to sort. Not modified.
	     * @returns {array} sorted models.
	     * @private
	     */
	    _sort: function(models) {
	      var sortField = this.get('sortField'), sortDir = this.get('sortDir');
	      if (sortField && sortDir) {
	        var sorted = _.sortBy(models, function(model) {
	          return model.get(sortField);
	        });
	        if (sortDir === -1) {
	          sorted = sorted.reverse();
	        }
	        return sorted;
	      }
	      return models;
	    },
	
	
	    /**
	     * Forces reset of original models, and applies in memory filters, sorting etc.
	     * Used when data is updated from server.
	     */
	    resetInMemory: function(models) {
	      this.reset(models);
	      this.originalModels = _.clone(this.models);
	      this.updateInMemory();
	      return this;
	    },
	
	    /** apply query, filter and sort to in memory collection */
	    updateInMemory: function() {
	      var results = this._query(this.originalModels);
	      results = this._filter(results);
	      results = this._sort(results);
	      this.reset(results);
	    },
	
	    /**
	     * Special reset method that loads remote models if the relatonship is remote, or
	     * calls resetInMemory if its not.
	     * @param {Array} models Array of model data for this Collection from parent model.
	     */
	    resetFromRelationship: function(models) {
	      if (this.processInMemory) {
	        this.resetInMemory(models);
	      } else {
	        this.fetchIfAvailable();
	      }
	    },
	
	    //
	    // Helpers
	    //
	
	    /**
	     * Copied from Backbone.Collection.
	     *
	     * Private method to reset all internal state. Called when the collection
	     * is first initialized or reset.
	     * @private
	     */
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },
	
	    /**
	     * Copied from Backbone.Collection.
	     * @private
	     */
	    _prepareModel: function(attrs, options) {
	      if (attrs instanceof Model) {
	        if (!attrs.collection) {
	          attrs.collection = this;
	        }
	        return attrs;
	      }
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) {
	        return model;
	      }
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },
	
	    /**
	     * Copied from Backbone.Collection.
	     * Internal method to sever a model's ties to a collection.
	     * @private
	     */
	    _removeReference: function(model) {
	      if (this === model.collection) {
	        delete model.collection;
	      }
	      model.off('all', this._onModelEvent, this);
	    },
	
	    /**
	     * Copied from Backbone.Collection. Modified to not propagate load events.
	     *
	     * Internal method called every time a model in the set fires an event.
	     * Sets need to update their indexes when models change ids. All other
	     * events simply proxy through. "add" and "remove" events that originate
	     * in other collections are ignored.
	     * @private
	     */
	    _onModelEvent: function(event, model, collection, options) {
	      //don't propagate load/beginLoad event
	      if (event === 'load' || event === 'beginLoad') {
	        return;
	      }
	
	      if ((event === 'add' || event === 'remove') && collection !== this) {
	        return;
	      }
	      if (event === 'destroy') {
	        this.remove(model, options);
	      }
	      if (model && event === 'change:' + model.idAttribute) {
	        delete this._byId[model.previous(model.idAttribute)];
	        if (model.id !== null) {
	          this._byId[model.id] = model;
	        }
	      }
	      this.trigger(event, this, model, collection, options);
	    },
	
	    /**
	     * Copied from Backbone.Collection. Renamed to setCollection from set to not conflict with Model.set
	     * Update a collection by `set`-ing a new list of models, adding new ones,
	     * removing models that are no longer present, and merging models that
	     * already exist in the collection, as necessary. Similar to **Model#set**,
	     * the core operation for updating the data contained by the collection.
	     */
	    setCollection: function(models, options) {
	      options = _.defaults({}, options, {add: true, remove: true, merge: true});
	      if (options.parse) {
	        models = this.parse(models, options);
	      }
	      var singular = !_.isArray(models);
	      models = singular ? (models ? [models] : []) : _.clone(models);
	      var i, l, id, model, attrs, existing, sort;
	      var at = options.at;
	      var targetModel = this.model;
	      var sortable = this.comparator && (at === null) && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
	      var toAdd = [], toRemove = [], modelMap = {};
	      var add = options.add, merge = options.merge, remove = options.remove;
	      var order = !sortable && add && remove ? [] : false;
	
	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      for (i = 0, l = models.length; i < l; i++) {
	        attrs = models[i];
	        if (attrs instanceof Model) {
	          id = model = attrs;
	        } else {
	          id = attrs[targetModel.prototype.idAttribute];
	        }
	
	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        if (existing = this.getById(id)) {
	          if (remove) {
	            modelMap[existing.cid] = true;
	          }
	          if (merge) {
	            attrs = attrs === model ? model.attributes : attrs;
	            if (options.parse) {
	              attrs = existing.parse(attrs, options);
	            }
	            existing.set(attrs, options);
	            if (sortable && !sort && existing.hasChanged(sortAttr)) {
	              sort = true;
	            }
	          }
	          models[i] = existing;
	
	        // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(attrs, options);
	          if (!model) {
	            continue;
	          }
	          toAdd.push(model);
	
	          // Listen to added models' events, and index models for lookup by
	          // `id` and by `cid`.
	          model.on('all', this._onModelEvent, this);
	          this._byId[model.cid] = model;
	          if (model.id !== null) {
	            this._byId[model.id] = model;
	          }
	        }
	        if (order) {
	          order.push(existing || model);
	        }
	      }
	
	      // Remove nonexistent models if appropriate.
	      if (remove) {
	        for (i = 0, l = this.length; i < l; ++i) {
	          if (!modelMap[(model = this.models[i]).cid]) {
	            toRemove.push(model);
	          }
	        }
	        if (toRemove.length) {
	          this.remove(toRemove, options);
	        }
	      }
	
	      // See if sorting is needed, update `length` and splice in new models.
	      if (toAdd.length || (order && order.length)) {
	        /* Change */
	        //Adding to an unfetched collection implies it is not expecting server data.
	        this.fetched = true;
	        /**********/
	
	        if (sortable) {
	          sort = true;
	        }
	        this.length += toAdd.length;
	        if (at !== void 0) {
	          for (i = 0, l = toAdd.length; i < l; i++) {
	            this.models.splice(at + i, 0, toAdd[i]);
	            /* Change */
	            if (this.processInMemory && this.originalModels) {
	              this.originalModels.push(toAdd[i]);
	            }
	            /**********/
	          }
	        } else {
	          if (order) {
	            this.models.length = 0;
	          }
	          var orderedModels = order || toAdd;
	          for (i = 0, l = orderedModels.length; i < l; i++) {
	            this.models.push(orderedModels[i]);
	            /* Change */
	            if (this.processInMemory && this.originalModels && !this.resetting) {
	              this.originalModels.push(orderedModels[i]);
	            }
	            /**********/
	          }
	        }
	      }
	
	      // Silently sort the collection if appropriate.
	      if (sort) {
	        this.sort({silent: true});
	      }
	
	      // Unless silenced, it's time to fire all appropriate add/sort events.
	      if (!options.silent) {
	        for (i = 0, l = toAdd.length; i < l; i++) {
	          (model = toAdd[i]).trigger('add', model, this, options);
	        }
	        if (sort || (order && order.length)) {
	          this.trigger('sort', this, options);
	        }
	      }
	
	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },
	  });
	
	  //Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
	    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
	    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
	    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
	    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
	    'lastIndexOf', 'isEmpty', 'chain'];
	
	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  _.each(methods, function(method) {
	    Plumage.collection.Collection.prototype[method] = function() {
	      var args = [].slice.call(arguments);
	      args.unshift(this.models);
	      return _[method].apply(_, args);
	    };
	  });
	
	  // Underscore methods that take a property name as an argument.
	  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];
	
	  // Use attributes instead of properties.
	  _.each(attributeMethods, function(method) {
	    Plumage.collection.Collection.prototype[method] = function(value, context) {
	      var iterator = _.isFunction(value) ? value : function(model) {
	        return model.get(value);
	      };
	      return _[method](this.models, iterator, context);
	    };
	  });
	
	  return Plumage.collection.Collection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88), __webpack_require__(100)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model) {
	
	  return Plumage.model.Filter = Model.extend(
	  /** @lends Plumage.model.Filter.prototype */
	  {
	
	    idAttribute: 'id',
	
	    /**
	     * Model for a Filter on a [Collection]{@link Plumage.collection.Collection}.
	     *
	     * Attributes are:
	     *  - key: The key of the attribute being filtered on.
	     *  - value: The filter value
	     *  - comparison: A string or function that compares the model value with the filter value.
	     *
	     * eg model's 'name'[key] equals[comaprison] 'foo'[value]
	     *
	     * For client side filtering, also contains a [compare]{@link Plumage.model.Filter} predicate for testing if Models pass the specified filter.
	     *
	     * @constructs
	     * @extends Plumage.model.Model
	     */
	    initialize: function() {
	      //filters exist only on client, so give them all unique ids
	      this.set('id', _.uniqueId('filter'));
	    },
	
	    /** Map of built in comparison names to comparison functions */
	    comparisons: {
	      equals: function(filterValue, value, key) {
	        return String(filterValue).toLowerCase() === String(value).toLowerCase();
	      },
	      contains: function(filterValue, value, key) {
	        return String(value).toLowerCase().indexOf(String(filterValue).toLowerCase()) !== -1;
	      },
	      startswith: function(filterValue, value, key) {
	        return String(value).indexOf(String(filterValue)) === 0;
	      },
	      endswith: function(filterValue, value, key) {
	        return String(value).toLowerCase().indexOf(String(filterValue)).toLowerCase() === String(value).length;
	      }
	    },
	
	    /**
	     * Predicate testing whether the given model passes this filter
	     * @param {Plumage.model.Model} model Model to test
	     */
	    compare: function(model) {
	      var key = this.get('key'), value;
	      if (model.get) {
	        value = model.get(key);
	      } else {
	        value = model[key];
	      }
	      var filterValue = this.get('value');
	      if (filterValue === undefined) {
	        return true;
	      }
	      var comparison = this.get('comparison');
	      if (typeof(comparison) === 'string') {
	        comparison = this.comparisons[comparison];
	        if (comparison) {
	          return comparison(filterValue, value, key);
	        }
	        return true;
	      }
	      return comparison(filterValue, value, key);
	    },
	
	    toJSON: function(){
	      //don't include arbitrary id in json
	      var json = Model.prototype.toJSON.apply(this, arguments);
	      delete json.id;
	      return json;
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint -W103 */
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(6), __webpack_require__(88), __webpack_require__(7), __webpack_require__(100),
	        __webpack_require__(119)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, moment, Model, User) {
	
	  return Plumage.model.Activity = Model.extend({
	
	    urlRoot: '/activities',
	
	    actionTexts: {
	      'Description': {
	        'create': 'added a description to {{{recipientHTML}}}',
	        'update': 'updated the description of {{{recipientHTML}}}'
	      },
	      'Comment': {
	        'create': 'commented on {{{recipientHTML}}}'
	      }
	    },
	
	    relationships: {
	      'user': {
	        modelCls: User,
	        forceCreate: false
	      }
	    },
	
	    toViewJSON: function() {
	      var data = Model.prototype.toViewJSON.apply(this, arguments);
	      data.recipientHTML = this.getRelatedModelHTML(this.get('recipient_type'), this.get('recipient'));
	      data.trackableHTML = this.getRelatedModelHTML(this.get('trackable_type'), this.get('trackable'));
	      data.action_text = this.getActionText(data);
	      data.create_at_text = moment(Number(data.created_at)*1000).fromNow();
	      return data;
	    },
	
	    getRelatedModelHTML: function(modelType, data) {
	      if (modelType) {
	        var modelCls = __webpack_require__(120)("./" + modelType);
	        var model = new modelCls(data);
	        var displayName = model.getDisplayName();
	        return '<a href="'+model.url()+'" class="name" title="'+displayName+'">'+displayName+'</a>';
	      }
	      return '';
	    },
	
	    getActionText: function(data) {
	      var actionTexts;
	      var context = this;
	      while (!actionTexts && context && context.actionTexts) {
	        actionTexts = context.actionTexts[this.get('trackable_type')];
	        if (!actionTexts || !actionTexts[this.get('action_type')]) {
	          context = context.__proto__;
	        }
	      }
	      if (actionTexts) {
	        return Handlebars.compile(actionTexts[this.get('action_type')])(data);
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88),
	  __webpack_require__(100),
	  __webpack_require__(115)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model) {
	
	  return Plumage.model.User = Model.extend({
	
	    urlIdAttribute: 'account',
	
	    urlRoot: '/users',
	
	    relationships: {
	      'comments': {
	        modelCls: 'collection/CommentCollection',
	        reverse: 'user',
	        forceCreate: false
	      },
	      'activities': {
	        modelCls: 'collection/ActivityCollection',
	        reverse: 'owner',
	        forceCreate: false
	      }
	    },
	
	    getImageThumb: function() {
	      return 'https://birdhouse.twitter.biz/people/photos/thumb/'+this.get('account')+'-thumb.jpg';
	    },
	
	    toViewJSON: function() {
	      var result = Model.prototype.toViewJSON.apply(this, arguments);
	      result.image_thumb = this.getImageThumb();
	      return result;
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Activity": 118,
		"./Activity.js": 118,
		"./Comment": 121,
		"./Comment.js": 121,
		"./Data": 122,
		"./Data.js": 122,
		"./Filter": 117,
		"./Filter.js": 117,
		"./Model": 100,
		"./Model.js": 100,
		"./SearchResults": 123,
		"./SearchResults.js": 123,
		"./User": 119,
		"./User.js": 119
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 120;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88), __webpack_require__(100),
	        __webpack_require__(119)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model, User) {
	
	  return Plumage.model.Comment = Model.extend({
	
	    urlRoot: '/comments',
	
	    relationships: {
	      'user': {
	        modelCls: User,
	        forceCreate: false
	      }
	    },
	
	    validate: function(attrs, options) {
	      if (!attrs.body || attrs.body.length <= 3) {
	        return 'Comment is too short';
	      }
	    }
	
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88), __webpack_require__(100)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model) {
	
	  return Plumage.model.Data = Model.extend({
	    idAttribute: 'name'
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88),
	        __webpack_require__(100),
	        __webpack_require__(124)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Model, DataCollection) {
	
	  return Plumage.model.SearchResults = Model.extend({
	
	    urlRoot: '/search',
	
	    relationships: {
	      'results': {
	        modelCls: DataCollection,
	        forceCreate: true,
	        reverse: 'searchResult'
	      }
	    },
	
	    getSearchResultCount: function() {
	      return this.getRelated('results').size();
	    },
	
	    /**
	     * Override to trim whitespace from the query
	     */
	    set: function(attrs, options) {
	      if (attrs.attributes) { attrs = attrs.attributes; }
	      if (attrs && attrs.query) {
	        attrs.query = $.trim(attrs.query);
	      }
	      return Model.prototype.set.apply(this, arguments);
	    },
	
	    url: function() {
	      return this.urlRoot + '/' + this.get('model') + '/' + encodeURIComponent(this.get('query'));
	    },
	
	    onLoad: function(options, visited) {
	      Model.prototype.onLoad.apply(this, arguments);
	      if (window.piwikTracker) {
	        window.piwikTracker.trackSiteSearch(this.get('query'), false, this.getSearchResultCount());
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(88),
	  __webpack_require__(116),
	  __webpack_require__(122)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Plumage, Collection, Data) {
	
	  return Plumage.collection.DataCollection = Collection.extend({
	    model: Data,
	    urlRoot: '/'
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(88),
	  __webpack_require__(116),
	  __webpack_require__(121)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Plumage, Collection, Comment) {
	
	  return Plumage.collection.CommentCollection = Collection.extend({
	    model: Comment
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2),
	        __webpack_require__(88), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Collection) {
	
	  return Plumage.collection.Selection = Collection.extend(
	  /** @lends Plumage.collection.Selection.prototype */
	  {
	    /** multiselect? */
	    multi: true,
	
	    model: Plumage.model.Model.extend({idAttribute: 'id'}),
	
	    /** parent collection being selected from */
	    collection: undefined,
	
	    /**
	     * A selection of models from a Collection.
	     *
	     * Contains a set of selected ids (stored as models with a single 'id' field).
	     *
	     * Includes a number of methods for selecting and deselecting items.
	     *
	     * @constructs
	     * @extends Plumage.collection.Collection
	     */
	    initialize: function(data, options) {
	      Plumage.collection.Collection.prototype.initialize.apply(this, arguments);
	      if (options && options.collection) {
	        this.collection = options.collection;
	        this.collection.on('load', this.onCollectionLoad, this);
	      }
	    },
	
	    /** total number of items in the parent collection */
	    getTotalSize: function() {
	      return this.collection.size();
	    },
	
	    /** Is id selected? */
	    isSelectedId: function(id) {
	      return this.getById(id) !== undefined;
	    },
	
	    /** Is index selected? */
	    isSelectedIndex: function(index) {
	      return this.getById(this.collection.at(index).id) !== undefined;
	    },
	
	    /**
	     * @returns {Array} array of selected indices
	     */
	    getSelectedIndices: function() {
	      return this.map(function(selectionItem) {
	        var item = this.collection.getById(selectionItem.id);
	        return this.collection.indexOf(item);
	      }.bind(this));
	    },
	
	    /**
	     * Select a array of indices
	     * @param {Array} indices Array of indices to select
	     */
	    setSelectedIndices: function(indices) {
	      var ids = _.map(indices, function(index) {
	        return this.collection.at(index).id;
	      }.bind(this));
	      this.setSelectedIds(ids);
	    },
	
	    /**
	     * @returns {Array} array of selected ids
	     */
	    getSelectedIds: function(ids) {
	      return this.map(function(item) {return item.id;});
	    },
	
	    /**
	     * Select a array of ids
	     * @param {Array} ids Array of ids to select
	     */
	    setSelectedIds: function(ids) {
	      var data = _.map(ids, function(id) {return {id: id};});
	      this.reset(data);
	    },
	
	    /**
	     * Select a single index
	     * @param {Number} index index to select
	     */
	    selectIndex: function(index) {
	      var item = this.collection.at(index);
	      if (this.getById(item.id) === undefined) {
	        if (this.multi) {
	          this.add(new this.model({id: item.id}));
	        } else {
	          this.setSelectedIds([item.id]);
	        }
	      }
	    },
	
	    /**
	     * Deselect a single index
	     * @param {Number} index index to dsselect
	     */
	    deselectIndex: function(index) {
	      var item = this.collection.at(index),
	        selectionItem = this.getById(item.id);
	
	      if (selectionItem) {
	        this.remove(selectionItem);
	      }
	    },
	
	    toggleIndex: function(index) {
	      if (this.isSelectedIndex(index)) {
	        this.deselectIndex(index);
	      } else {
	        this.selectIndex(index);
	      }
	    },
	
	    /**
	     * Select all items in the parent collection
	     */
	    selectAll: function() {
	      var data = this.collection.map(function(item) {
	        return {id: item.id};
	      });
	      this.reset(data);
	    },
	
	    /**
	     * Clears this selection
	     */
	    deselectAll: function() {
	      this.reset([]);
	    },
	
	    // Event handlers
	
	    onCollectionLoad: function() {
	      // reset with only ids still in the collection after load
	      var data = [];
	      this.each(function(item){
	        if (this.collection.getById(item.id) !== undefined) {
	          data.push(item);
	        }
	      }.bind(this));
	      this.reset(data);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(126),
	  __webpack_require__(128)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Selection, Slick) {
	
	
	  /**
	   * Adapts a Plumage Selection to the slickgrid RowSelection interface.
	   *
	   * Doesn't support cmd, shift selection.
	   *
	   * @constructs Plumage.collection.GridSelection
	   */
	  var GridSelection = function(selection) {
	    this.selection = selection;
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(GridSelection.prototype, Backbone.Events,
	  /** @lends Plumage.collection.GridSelection.prototype */
	  {
	    /** wrapped Selection */
	    selection: undefined,
	
	    /** SlickGrid grid instance*/
	    grid: undefined,
	
	    // Optionss
	    selectActiveRow: false,
	
	    initialize: function(options) {
	      options = options || {};
	      _.extend(this, options);
	
	      this.selection.on('change', this.onSelectionChange, this);
	      this.selection.on('add', this.onSelectionChange, this);
	      this.selection.on('remove', this.onSelectionChange, this);
	      this.selection.on('reset', this.onSelectionChange, this);
	    },
	
	    /** SlickGrid init */
	    init: function(grid) {
	      this.grid = grid;
	      this.handler = new Slick.EventHandler();
	      this.handler.subscribe(this.grid.onActiveCellChanged, this.onActiveCellChanged.bind(this));
	      this.onSelectedRangesChanged = new Slick.Event();
	    },
	
	    /** SlickGrid destroy */
	    destroy: function() {
	      this.handler.unsubscribeAll();
	      this.selection.off('change', this.onSelectionChange, this);
	      this.selection.off('reset', this.onSelectionChange, this);
	    },
	
	    // SlickGrid getters and setters
	
	    getSelectedRows: function () {
	      return this.selection.getSelectedIndices();
	    },
	
	    setSelectedRows: function (rows) {
	      this.selection.setSelectedIndices(rows);
	    },
	
	    setSelectedRanges: function (ranges) {
	      this.setSelectedRows(this.rangesToRows(ranges));
	    },
	
	    getSelectedRanges: function () {
	      return this.rowsToRanges(this.getSelectedRows());
	    },
	
	    // Event handlers
	
	    onActiveCellChanged: function(e, data) {
	      if (this.selectActiveRow && data.row !== null) {
	        this.setSelectedRows([data.row]);
	      }
	    },
	
	    onSelectionChange: function() {
	      this.onSelectedRangesChanged.notify(this.getSelectedRanges());
	    },
	
	    // SlickGrid helpers
	
	    rowsToRanges: function(rows) {
	      var ranges = [];
	      var lastCell = this.grid.getColumns().length - 1;
	      for (var i = 0; i < rows.length; i++) {
	        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));
	      }
	      return ranges;
	    },
	
	    rangesToRows: function(ranges) {
	      var rows = [];
	      for (var i = 0; i < ranges.length; i++) {
	        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {
	          rows.push(j);
	        }
	      }
	      return rows;
	    }
	  });
	
	  return Plumage.collection.GridSelection = GridSelection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(129),
	  __webpack_require__(133),
	  __webpack_require__(134),
	  __webpack_require__(135)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	  return window.Slick;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	/***
	 * Contains core SlickGrid classes.
	 * @module Core
	 * @namespace Slick
	 */
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	
	
	
	  // register namespace
	  $.extend(true, window, {
	    "Slick": {
	      "Event": Event,
	      "EventData": EventData,
	      "EventHandler": EventHandler,
	      "Range": Range,
	      "NonDataRow": NonDataItem,
	      "Group": Group,
	      "GroupTotals": GroupTotals,
	      "EditorLock": EditorLock,
	
	      /***
	       * A global singleton editor lock.
	       * @class GlobalEditorLock
	       * @static
	       * @constructor
	       */
	      "GlobalEditorLock": new EditorLock()
	    }
	  });
	
	  /***
	   * An event object for passing data to event handlers and letting them control propagation.
	   * <p>This is pretty much identical to how W3C and jQuery implement events.</p>
	   * @class EventData
	   * @constructor
	   */
	  function EventData() {
	    var isPropagationStopped = false;
	    var isImmediatePropagationStopped = false;
	
	    /***
	     * Stops event from propagating up the DOM tree.
	     * @method stopPropagation
	     */
	    this.stopPropagation = function () {
	      isPropagationStopped = true;
	    };
	
	    /***
	     * Returns whether stopPropagation was called on this event object.
	     * @method isPropagationStopped
	     * @return {Boolean}
	     */
	    this.isPropagationStopped = function () {
	      return isPropagationStopped;
	    };
	
	    /***
	     * Prevents the rest of the handlers from being executed.
	     * @method stopImmediatePropagation
	     */
	    this.stopImmediatePropagation = function () {
	      isImmediatePropagationStopped = true;
	    };
	
	    /***
	     * Returns whether stopImmediatePropagation was called on this event object.\
	     * @method isImmediatePropagationStopped
	     * @return {Boolean}
	     */
	    this.isImmediatePropagationStopped = function () {
	      return isImmediatePropagationStopped;
	    }
	  }
	
	  /***
	   * A simple publisher-subscriber implementation.
	   * @class Event
	   * @constructor
	   */
	  function Event() {
	    var handlers = [];
	
	    /***
	     * Adds an event handler to be called when the event is fired.
	     * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>
	     * object the event was fired with.<p>
	     * @method subscribe
	     * @param fn {Function} Event handler.
	     */
	    this.subscribe = function (fn) {
	      handlers.push(fn);
	    };
	
	    /***
	     * Removes an event handler added with <code>subscribe(fn)</code>.
	     * @method unsubscribe
	     * @param fn {Function} Event handler to be removed.
	     */
	    this.unsubscribe = function (fn) {
	      for (var i = handlers.length - 1; i >= 0; i--) {
	        if (handlers[i] === fn) {
	          handlers.splice(i, 1);
	        }
	      }
	    };
	
	    /***
	     * Fires an event notifying all subscribers.
	     * @method notify
	     * @param args {Object} Additional data object to be passed to all handlers.
	     * @param e {EventData}
	     *      Optional.
	     *      An <code>EventData</code> object to be passed to all handlers.
	     *      For DOM events, an existing W3C/jQuery event object can be passed in.
	     * @param scope {Object}
	     *      Optional.
	     *      The scope ("this") within which the handler will be executed.
	     *      If not specified, the scope will be set to the <code>Event</code> instance.
	     */
	    this.notify = function (args, e, scope) {
	      e = e || new EventData();
	      scope = scope || this;
	
	      var returnValue;
	      for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {
	        returnValue = handlers[i].call(scope, e, args);
	      }
	
	      return returnValue;
	    };
	  }
	
	  function EventHandler() {
	    var handlers = [];
	
	    this.subscribe = function (event, handler) {
	      handlers.push({
	        event: event,
	        handler: handler
	      });
	      event.subscribe(handler);
	
	      return this;  // allow chaining
	    };
	
	    this.unsubscribe = function (event, handler) {
	      var i = handlers.length;
	      while (i--) {
	        if (handlers[i].event === event &&
	            handlers[i].handler === handler) {
	          handlers.splice(i, 1);
	          event.unsubscribe(handler);
	          return;
	        }
	      }
	
	      return this;  // allow chaining
	    };
	
	    this.unsubscribeAll = function () {
	      var i = handlers.length;
	      while (i--) {
	        handlers[i].event.unsubscribe(handlers[i].handler);
	      }
	      handlers = [];
	
	      return this;  // allow chaining
	    }
	  }
	
	  /***
	   * A structure containing a range of cells.
	   * @class Range
	   * @constructor
	   * @param fromRow {Integer} Starting row.
	   * @param fromCell {Integer} Starting cell.
	   * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.
	   * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.
	   */
	  function Range(fromRow, fromCell, toRow, toCell) {
	    if (toRow === undefined && toCell === undefined) {
	      toRow = fromRow;
	      toCell = fromCell;
	    }
	
	    /***
	     * @property fromRow
	     * @type {Integer}
	     */
	    this.fromRow = Math.min(fromRow, toRow);
	
	    /***
	     * @property fromCell
	     * @type {Integer}
	     */
	    this.fromCell = Math.min(fromCell, toCell);
	
	    /***
	     * @property toRow
	     * @type {Integer}
	     */
	    this.toRow = Math.max(fromRow, toRow);
	
	    /***
	     * @property toCell
	     * @type {Integer}
	     */
	    this.toCell = Math.max(fromCell, toCell);
	
	    /***
	     * Returns whether a range represents a single row.
	     * @method isSingleRow
	     * @return {Boolean}
	     */
	    this.isSingleRow = function () {
	      return this.fromRow == this.toRow;
	    };
	
	    /***
	     * Returns whether a range represents a single cell.
	     * @method isSingleCell
	     * @return {Boolean}
	     */
	    this.isSingleCell = function () {
	      return this.fromRow == this.toRow && this.fromCell == this.toCell;
	    };
	
	    /***
	     * Returns whether a range contains a given cell.
	     * @method contains
	     * @param row {Integer}
	     * @param cell {Integer}
	     * @return {Boolean}
	     */
	    this.contains = function (row, cell) {
	      return row >= this.fromRow && row <= this.toRow &&
	          cell >= this.fromCell && cell <= this.toCell;
	    };
	
	    /***
	     * Returns a readable representation of a range.
	     * @method toString
	     * @return {String}
	     */
	    this.toString = function () {
	      if (this.isSingleCell()) {
	        return "(" + this.fromRow + ":" + this.fromCell + ")";
	      }
	      else {
	        return "(" + this.fromRow + ":" + this.fromCell + " - " + this.toRow + ":" + this.toCell + ")";
	      }
	    }
	  }
	
	
	  /***
	   * A base class that all special / non-data rows (like Group and GroupTotals) derive from.
	   * @class NonDataItem
	   * @constructor
	   */
	  function NonDataItem() {
	    this.__nonDataRow = true;
	  }
	
	
	  /***
	   * Information about a group of rows.
	   * @class Group
	   * @extends Slick.NonDataItem
	   * @constructor
	   */
	  function Group() {
	    this.__group = true;
	
	    /**
	     * Grouping level, starting with 0.
	     * @property level
	     * @type {Number}
	     */
	    this.level = 0;
	
	    /***
	     * Number of rows in the group.
	     * @property count
	     * @type {Integer}
	     */
	    this.count = 0;
	
	    /***
	     * Grouping value.
	     * @property value
	     * @type {Object}
	     */
	    this.value = null;
	
	    /***
	     * Formatted display value of the group.
	     * @property title
	     * @type {String}
	     */
	    this.title = null;
	
	    /***
	     * Whether a group is collapsed.
	     * @property collapsed
	     * @type {Boolean}
	     */
	    this.collapsed = false;
	
	    /***
	     * GroupTotals, if any.
	     * @property totals
	     * @type {GroupTotals}
	     */
	    this.totals = null;
	
	    /**
	     * Rows that are part of the group.
	     * @property rows
	     * @type {Array}
	     */
	    this.rows = [];
	
	    /**
	     * Sub-groups that are part of the group.
	     * @property groups
	     * @type {Array}
	     */
	    this.groups = null;
	
	    /**
	     * A unique key used to identify the group.  This key can be used in calls to DataView
	     * collapseGroup() or expandGroup().
	     * @property groupingKey
	     * @type {Object}
	     */
	    this.groupingKey = null;
	  }
	
	  Group.prototype = new NonDataItem();
	
	  /***
	   * Compares two Group instances.
	   * @method equals
	   * @return {Boolean}
	   * @param group {Group} Group instance to compare to.
	   */
	  Group.prototype.equals = function (group) {
	    return this.value === group.value &&
	        this.count === group.count &&
	        this.collapsed === group.collapsed &&
	        this.title === group.title;
	  };
	
	  /***
	   * Information about group totals.
	   * An instance of GroupTotals will be created for each totals row and passed to the aggregators
	   * so that they can store arbitrary data in it.  That data can later be accessed by group totals
	   * formatters during the display.
	   * @class GroupTotals
	   * @extends Slick.NonDataItem
	   * @constructor
	   */
	  function GroupTotals() {
	    this.__groupTotals = true;
	
	    /***
	     * Parent Group.
	     * @param group
	     * @type {Group}
	     */
	    this.group = null;
	
	    /***
	     * Whether the totals have been fully initialized / calculated.
	     * Will be set to false for lazy-calculated group totals.
	     * @param initialized
	     * @type {Boolean}
	     */
	    this.initialized = false;
	  }
	
	  GroupTotals.prototype = new NonDataItem();
	
	  /***
	   * A locking helper to track the active edit controller and ensure that only a single controller
	   * can be active at a time.  This prevents a whole class of state and validation synchronization
	   * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress
	   * and attempt a commit or cancel before proceeding.
	   * @class EditorLock
	   * @constructor
	   */
	  function EditorLock() {
	    var activeEditController = null;
	
	    /***
	     * Returns true if a specified edit controller is active (has the edit lock).
	     * If the parameter is not specified, returns true if any edit controller is active.
	     * @method isActive
	     * @param editController {EditController}
	     * @return {Boolean}
	     */
	    this.isActive = function (editController) {
	      return (editController ? activeEditController === editController : activeEditController !== null);
	    };
	
	    /***
	     * Sets the specified edit controller as the active edit controller (acquire edit lock).
	     * If another edit controller is already active, and exception will be thrown.
	     * @method activate
	     * @param editController {EditController} edit controller acquiring the lock
	     */
	    this.activate = function (editController) {
	      if (editController === activeEditController) { // already activated?
	        return;
	      }
	      if (activeEditController !== null) {
	        throw "SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController";
	      }
	      if (!editController.commitCurrentEdit) {
	        throw "SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()";
	      }
	      if (!editController.cancelCurrentEdit) {
	        throw "SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()";
	      }
	      activeEditController = editController;
	    };
	
	    /***
	     * Unsets the specified edit controller as the active edit controller (release edit lock).
	     * If the specified edit controller is not the active one, an exception will be thrown.
	     * @method deactivate
	     * @param editController {EditController} edit controller releasing the lock
	     */
	    this.deactivate = function (editController) {
	      if (activeEditController !== editController) {
	        throw "SlickGrid.EditorLock.deactivate: specified editController is not the currently active one";
	      }
	      activeEditController = null;
	    };
	
	    /***
	     * Attempts to commit the current edit by calling "commitCurrentEdit" method on the active edit
	     * controller and returns whether the commit attempt was successful (commit may fail due to validation
	     * errors, etc.).  Edit controller's "commitCurrentEdit" must return true if the commit has succeeded
	     * and false otherwise.  If no edit controller is active, returns true.
	     * @method commitCurrentEdit
	     * @return {Boolean}
	     */
	    this.commitCurrentEdit = function () {
	      return (activeEditController ? activeEditController.commitCurrentEdit() : true);
	    };
	
	    /***
	     * Attempts to cancel the current edit by calling "cancelCurrentEdit" method on the active edit
	     * controller and returns whether the edit was successfully cancelled.  If no edit controller is
	     * active, returns true.
	     * @method cancelCurrentEdit
	     * @return {Boolean}
	     */
	    this.cancelCurrentEdit = function cancelCurrentEdit() {
	      return (activeEditController ? activeEditController.cancelCurrentEdit() : true);
	    };
	  }
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.11.4 - 2015-06-16
	* http://jqueryui.com
	* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js
	* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
	
	(function( factory ) {
		if ( true ) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory( jQuery );
		}
	}(function( $ ) {
	/*!
	 * jQuery UI Core 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/ui-core/
	 */
	
	
	// $.ui might exist from components with no dependencies, e.g., $.ui.position
	$.ui = $.ui || {};
	
	$.extend( $.ui, {
		version: "1.11.4",
	
		keyCode: {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			LEFT: 37,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		}
	});
	
	// plugins
	$.fn.extend({
		scrollParent: function( includeHidden ) {
			var position = this.css( "position" ),
				excludeStaticParent = position === "absolute",
				overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
				scrollParent = this.parents().filter( function() {
					var parent = $( this );
					if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
						return false;
					}
					return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
				}).eq( 0 );
	
			return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
		},
	
		uniqueId: (function() {
			var uuid = 0;
	
			return function() {
				return this.each(function() {
					if ( !this.id ) {
						this.id = "ui-id-" + ( ++uuid );
					}
				});
			};
		})(),
	
		removeUniqueId: function() {
			return this.each(function() {
				if ( /^ui-id-\d+$/.test( this.id ) ) {
					$( this ).removeAttr( "id" );
				}
			});
		}
	});
	
	// selectors
	function focusable( element, isTabIndexNotNaN ) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			map = element.parentNode;
			mapName = map.name;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
			return !!img && visible( img );
		}
		return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
			!element.disabled :
			"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible( element );
	}
	
	function visible( element ) {
		return $.expr.filters.visible( element ) &&
			!$( element ).parents().addBack().filter(function() {
				return $.css( this, "visibility" ) === "hidden";
			}).length;
	}
	
	$.extend( $.expr[ ":" ], {
		data: $.expr.createPseudo ?
			$.expr.createPseudo(function( dataName ) {
				return function( elem ) {
					return !!$.data( elem, dataName );
				};
			}) :
			// support: jQuery <1.8
			function( elem, i, match ) {
				return !!$.data( elem, match[ 3 ] );
			},
	
		focusable: function( element ) {
			return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
		},
	
		tabbable: function( element ) {
			var tabIndex = $.attr( element, "tabindex" ),
				isTabIndexNaN = isNaN( tabIndex );
			return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
		}
	});
	
	// support: jQuery <1.8
	if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
		$.each( [ "Width", "Height" ], function( i, name ) {
			var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
				type = name.toLowerCase(),
				orig = {
					innerWidth: $.fn.innerWidth,
					innerHeight: $.fn.innerHeight,
					outerWidth: $.fn.outerWidth,
					outerHeight: $.fn.outerHeight
				};
	
			function reduce( elem, size, border, margin ) {
				$.each( side, function() {
					size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
					if ( border ) {
						size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
					}
					if ( margin ) {
						size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
					}
				});
				return size;
			}
	
			$.fn[ "inner" + name ] = function( size ) {
				if ( size === undefined ) {
					return orig[ "inner" + name ].call( this );
				}
	
				return this.each(function() {
					$( this ).css( type, reduce( this, size ) + "px" );
				});
			};
	
			$.fn[ "outer" + name] = function( size, margin ) {
				if ( typeof size !== "number" ) {
					return orig[ "outer" + name ].call( this, size );
				}
	
				return this.each(function() {
					$( this).css( type, reduce( this, size, true, margin ) + "px" );
				});
			};
		});
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
	if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
		$.fn.removeData = (function( removeData ) {
			return function( key ) {
				if ( arguments.length ) {
					return removeData.call( this, $.camelCase( key ) );
				} else {
					return removeData.call( this );
				}
			};
		})( $.fn.removeData );
	}
	
	// deprecated
	$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
	
	$.fn.extend({
		focus: (function( orig ) {
			return function( delay, fn ) {
				return typeof delay === "number" ?
					this.each(function() {
						var elem = this;
						setTimeout(function() {
							$( elem ).focus();
							if ( fn ) {
								fn.call( elem );
							}
						}, delay );
					}) :
					orig.apply( this, arguments );
			};
		})( $.fn.focus ),
	
		disableSelection: (function() {
			var eventType = "onselectstart" in document.createElement( "div" ) ?
				"selectstart" :
				"mousedown";
	
			return function() {
				return this.bind( eventType + ".ui-disableSelection", function( event ) {
					event.preventDefault();
				});
			};
		})(),
	
		enableSelection: function() {
			return this.unbind( ".ui-disableSelection" );
		},
	
		zIndex: function( zIndex ) {
			if ( zIndex !== undefined ) {
				return this.css( "zIndex", zIndex );
			}
	
			if ( this.length ) {
				var elem = $( this[ 0 ] ), position, value;
				while ( elem.length && elem[ 0 ] !== document ) {
					// Ignore z-index if position is set to a value where z-index is ignored by the browser
					// This makes behavior of this function consistent across browsers
					// WebKit always returns auto if the element is positioned
					position = elem.css( "position" );
					if ( position === "absolute" || position === "relative" || position === "fixed" ) {
						// IE returns 0 when zIndex is not specified
						// other browsers return a string
						// we ignore the case of nested elements with an explicit value of 0
						// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
						value = parseInt( elem.css( "zIndex" ), 10 );
						if ( !isNaN( value ) && value !== 0 ) {
							return value;
						}
					}
					elem = elem.parent();
				}
			}
	
			return 0;
		}
	});
	
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	$.ui.plugin = {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args, allowDisconnected ) {
			var i,
				set = instance.plugins[ name ];
	
			if ( !set ) {
				return;
			}
	
			if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
				return;
			}
	
			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	};
	
	
	/*!
	 * jQuery UI Widget 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/jQuery.widget/
	 */
	
	
	var widget_uuid = 0,
		widget_slice = Array.prototype.slice;
	
	$.cleanData = (function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; (elem = elems[i]) != null; i++ ) {
				try {
	
					// Only trigger remove when necessary to save time
					events = $._data( elem, "events" );
					if ( events && events.remove ) {
						$( elem ).triggerHandler( "remove" );
					}
	
				// http://bugs.jquery.com/ticket/8235
				} catch ( e ) {}
			}
			orig( elems );
		};
	})( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var fullName, existingConstructor, constructor, basePrototype,
			// proxiedPrototype allows the provided prototype to remain unmodified
			// so that it can be used as a mixin for multiple widgets (#8876)
			proxiedPrototype = {},
			namespace = name.split( "." )[ 0 ];
	
		name = name.split( "." )[ 1 ];
		fullName = namespace + "-" + name;
	
		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}
	
		// create selector for plugin
		$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};
	
		$[ namespace ] = $[ namespace ] || {};
		existingConstructor = $[ namespace ][ name ];
		constructor = $[ namespace ][ name ] = function( options, element ) {
			// allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}
	
			// allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		// extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,
			// copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend( {}, prototype ),
			// track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		});
	
		basePrototype = new base();
		// we need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;
	
					this._super = _super;
					this._superApply = _superApply;
	
					returnValue = value.apply( this, arguments );
	
					this._super = __super;
					this._superApply = __superApply;
	
					return returnValue;
				};
			})();
		});
		constructor.prototype = $.widget.extend( basePrototype, {
			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		});
	
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;
	
				// redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
			});
			// remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push( constructor );
		}
	
		$.widget.bridge( name, constructor );
	
		return constructor;
	};
	
	$.widget.extend = function( target ) {
		var input = widget_slice.call( arguments, 1 ),
			inputIndex = 0,
			inputLength = input.length,
			key,
			value;
		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :
							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );
					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};
	
	$.widget.bridge = function( name, object ) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[ name ] = function( options ) {
			var isMethodCall = typeof options === "string",
				args = widget_slice.call( arguments, 1 ),
				returnValue = this;
	
			if ( isMethodCall ) {
				this.each(function() {
					var methodValue,
						instance = $.data( this, fullName );
					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}
					if ( !instance ) {
						return $.error( "cannot call methods on " + name + " prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}
					if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name + " widget instance" );
					}
					methodValue = instance[ options ].apply( instance, args );
					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				});
			} else {
	
				// Allow multiple hashes to be passed on init
				if ( args.length ) {
					options = $.widget.extend.apply( null, [ options ].concat(args) );
				}
	
				this.each(function() {
					var instance = $.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} );
						if ( instance._init ) {
							instance._init();
						}
					} else {
						$.data( this, fullName, new object( options, this ) );
					}
				});
			}
	
			return returnValue;
		};
	};
	
	$.Widget = function( /* options, element */ ) {};
	$.Widget._childConstructors = [];
	
	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			disabled: false,
	
			// callbacks
			create: null
		},
		_createWidget: function( options, element ) {
			element = $( element || this.defaultElement || this )[ 0 ];
			this.element = $( element );
			this.uuid = widget_uuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;
	
			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();
	
			if ( element !== this ) {
				$.data( element, this.widgetFullName, this );
				this._on( true, this.element, {
					remove: function( event ) {
						if ( event.target === element ) {
							this.destroy();
						}
					}
				});
				this.document = $( element.style ?
					// element within the document
					element.ownerDocument :
					// element is window or document
					element.document || element );
				this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
			}
	
			this.options = $.widget.extend( {},
				this.options,
				this._getCreateOptions(),
				options );
	
			this._create();
			this._trigger( "create", null, this._getCreateEventData() );
			this._init();
		},
		_getCreateOptions: $.noop,
		_getCreateEventData: $.noop,
		_create: $.noop,
		_init: $.noop,
	
		destroy: function() {
			this._destroy();
			// we can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element
				.unbind( this.eventNamespace )
				.removeData( this.widgetFullName )
				// support: jquery <1.6.3
				// http://bugs.jquery.com/ticket/9413
				.removeData( $.camelCase( this.widgetFullName ) );
			this.widget()
				.unbind( this.eventNamespace )
				.removeAttr( "aria-disabled" )
				.removeClass(
					this.widgetFullName + "-disabled " +
					"ui-state-disabled" );
	
			// clean up events and states
			this.bindings.unbind( this.eventNamespace );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		},
		_destroy: $.noop,
	
		widget: function() {
			return this.element;
		},
	
		option: function( key, value ) {
			var options = key,
				parts,
				curOption,
				i;
	
			if ( arguments.length === 0 ) {
				// don't return a reference to the internal hash
				return $.widget.extend( {}, this.options );
			}
	
			if ( typeof key === "string" ) {
				// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split( "." );
				key = parts.shift();
				if ( parts.length ) {
					curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
					for ( i = 0; i < parts.length - 1; i++ ) {
						curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
						curOption = curOption[ parts[ i ] ];
					}
					key = parts.pop();
					if ( arguments.length === 1 ) {
						return curOption[ key ] === undefined ? null : curOption[ key ];
					}
					curOption[ key ] = value;
				} else {
					if ( arguments.length === 1 ) {
						return this.options[ key ] === undefined ? null : this.options[ key ];
					}
					options[ key ] = value;
				}
			}
	
			this._setOptions( options );
	
			return this;
		},
		_setOptions: function( options ) {
			var key;
	
			for ( key in options ) {
				this._setOption( key, options[ key ] );
			}
	
			return this;
		},
		_setOption: function( key, value ) {
			this.options[ key ] = value;
	
			if ( key === "disabled" ) {
				this.widget()
					.toggleClass( this.widgetFullName + "-disabled", !!value );
	
				// If the widget is becoming disabled, then nothing is interactive
				if ( value ) {
					this.hoverable.removeClass( "ui-state-hover" );
					this.focusable.removeClass( "ui-state-focus" );
				}
			}
	
			return this;
		},
	
		enable: function() {
			return this._setOptions({ disabled: false });
		},
		disable: function() {
			return this._setOptions({ disabled: true });
		},
	
		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement,
				instance = this;
	
			// no suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}
	
			// no element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}
	
			$.each( handlers, function( event, handler ) {
				function handlerProxy() {
					// allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
								$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}
	
				// copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}
	
				var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
					eventName = match[1] + instance.eventNamespace,
					selector = match[2];
				if ( selector ) {
					delegateElement.delegate( selector, eventName, handlerProxy );
				} else {
					element.bind( eventName, handlerProxy );
				}
			});
		},
	
		_off: function( element, eventName ) {
			eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.unbind( eventName ).undelegate( eventName );
	
			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},
	
		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},
	
		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-hover" );
				},
				mouseleave: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-hover" );
				}
			});
		},
	
		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-focus" );
				},
				focusout: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-focus" );
				}
			});
		},
	
		_trigger: function( type, event, data ) {
			var prop, orig,
				callback = this.options[ type ];
	
			data = data || {};
			event = $.Event( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();
			// the original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];
	
			// copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}
	
			this.element.trigger( event, data );
			return !( $.isFunction( callback ) &&
				callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}
	};
	
	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}
			var hasOptions,
				effectName = !options ?
					method :
					options === true || typeof options === "number" ?
						defaultEffect :
						options.effect || defaultEffect;
			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}
			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;
			if ( options.delay ) {
				element.delay( options.delay );
			}
			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue(function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				});
			}
		};
	});
	
	var widget = $.widget;
	
	
	/*!
	 * jQuery UI Mouse 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/mouse/
	 */
	
	
	var mouseHandled = false;
	$( document ).mouseup( function() {
		mouseHandled = false;
	});
	
	var mouse = $.widget("ui.mouse", {
		version: "1.11.4",
		options: {
			cancel: "input,textarea,button,select,option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function() {
			var that = this;
	
			this.element
				.bind("mousedown." + this.widgetName, function(event) {
					return that._mouseDown(event);
				})
				.bind("click." + this.widgetName, function(event) {
					if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
						$.removeData(event.target, that.widgetName + ".preventClickEvent");
						event.stopImmediatePropagation();
						return false;
					}
				});
	
			this.started = false;
		},
	
		// TODO: make sure destroying one instance of mouse doesn't mess with
		// other instances of mouse
		_mouseDestroy: function() {
			this.element.unbind("." + this.widgetName);
			if ( this._mouseMoveDelegate ) {
				this.document
					.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
					.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
			}
		},
	
		_mouseDown: function(event) {
			// don't let more than one widget handle mouseStart
			if ( mouseHandled ) {
				return;
			}
	
			this._mouseMoved = false;
	
			// we may have missed mouseup (out of window)
			(this._mouseStarted && this._mouseUp(event));
	
			this._mouseDownEvent = event;
	
			var that = this,
				btnIsLeft = (event.which === 1),
				// event.target.nodeName works around a bug in IE 8 with
				// disabled inputs (#7620)
				elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
			if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
				return true;
			}
	
			this.mouseDelayMet = !this.options.delay;
			if (!this.mouseDelayMet) {
				this._mouseDelayTimer = setTimeout(function() {
					that.mouseDelayMet = true;
				}, this.options.delay);
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted = (this._mouseStart(event) !== false);
				if (!this._mouseStarted) {
					event.preventDefault();
					return true;
				}
			}
	
			// Click event may never have fired (Gecko & Opera)
			if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
				$.removeData(event.target, this.widgetName + ".preventClickEvent");
			}
	
			// these delegates are required to keep context
			this._mouseMoveDelegate = function(event) {
				return that._mouseMove(event);
			};
			this._mouseUpDelegate = function(event) {
				return that._mouseUp(event);
			};
	
			this.document
				.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );
	
			event.preventDefault();
	
			mouseHandled = true;
			return true;
		},
	
		_mouseMove: function(event) {
			// Only check for mouseups outside the document if you've moved inside the document
			// at least once. This prevents the firing of mouseup in the case of IE<9, which will
			// fire a mousemove event if content is placed under the cursor. See #7778
			// Support: IE <9
			if ( this._mouseMoved ) {
				// IE mouseup check - mouseup happened when mouse was out of window
				if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
					return this._mouseUp(event);
	
				// Iframe mouseup check - mouseup occurred in another document
				} else if ( !event.which ) {
					return this._mouseUp( event );
				}
			}
	
			if ( event.which || event.button ) {
				this._mouseMoved = true;
			}
	
			if (this._mouseStarted) {
				this._mouseDrag(event);
				return event.preventDefault();
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted =
					(this._mouseStart(this._mouseDownEvent, event) !== false);
				(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
			}
	
			return !this._mouseStarted;
		},
	
		_mouseUp: function(event) {
			this.document
				.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );
	
			if (this._mouseStarted) {
				this._mouseStarted = false;
	
				if (event.target === this._mouseDownEvent.target) {
					$.data(event.target, this.widgetName + ".preventClickEvent", true);
				}
	
				this._mouseStop(event);
			}
	
			mouseHandled = false;
			return false;
		},
	
		_mouseDistanceMet: function(event) {
			return (Math.max(
					Math.abs(this._mouseDownEvent.pageX - event.pageX),
					Math.abs(this._mouseDownEvent.pageY - event.pageY)
				) >= this.options.distance
			);
		},
	
		_mouseDelayMet: function(/* event */) {
			return this.mouseDelayMet;
		},
	
		// These are placeholder methods, to be overriden by extending plugin
		_mouseStart: function(/* event */) {},
		_mouseDrag: function(/* event */) {},
		_mouseStop: function(/* event */) {},
		_mouseCapture: function(/* event */) { return true; }
	});
	
	
	/*!
	 * jQuery UI Position 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/position/
	 */
	
	(function() {
	
	$.ui = $.ui || {};
	
	var cachedScrollbarWidth, supportsOffsetFractions,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;
	
	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}
	
	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}
	
	function getDimensions( elem ) {
		var raw = elem[0];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}
	
	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[0];
	
			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );
	
			w2 = innerDiv.offsetWidth;
	
			if ( w1 === w2 ) {
				w2 = div[0].clientWidth;
			}
	
			div.remove();
	
			return (cachedScrollbarWidth = w1 - w2);
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-x" ),
				overflowY = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[0].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[0] ),
				isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
			return {
				element: withinElement,
				isWindow: isWindow,
				isDocument: isDocument,
				offset: withinElement.offset() || { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
	
				// support: jQuery 1.6.x
				// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
				width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
				height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
			};
		}
	};
	
	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}
	
		// make a copy, we don't want to modify arguments
		options = $.extend( {}, options );
	
		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};
	
		dimensions = getDimensions( target );
		if ( target[0].preventDefault ) {
			// force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;
		// clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );
	
		// force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;
	
			if ( pos.length === 1) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
	
			// calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];
	
			// reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		});
	
		// normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}
	
		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}
	
		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}
	
		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];
	
		return this.each(function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
	
			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}
	
			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}
	
			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];
	
			// if the browser doesn't support fractions, then round for consistent results
			if ( !supportsOffsetFractions ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}
	
			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};
	
			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem: elem
					});
				}
			});
	
			if ( options.using ) {
				// adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}
	
			elem.offset( $.extend( position, { using: using } ) );
		});
	};
	
	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;
	
				// element is wider than within
				if ( data.collisionWidth > outerWidth ) {
					// element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
						position.left += overLeft - newOverRight;
					// element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;
					// element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}
				// too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;
				// too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;
				// adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;
	
				// element is taller than within
				if ( data.collisionHeight > outerHeight ) {
					// element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
						position.top += overTop - newOverBottom;
					// element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;
					// element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}
				// too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;
				// too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;
				// adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;
	
				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				} else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
					if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
						position.top += myOffset + atOffset + offset;
					}
				} else if ( overBottom > 0 ) {
					newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
					if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};
	
	// fraction support test
	(function() {
		var testElement, testElementParent, testElementStyle, offsetLeft, i,
			body = document.getElementsByTagName( "body" )[ 0 ],
			div = document.createElement( "div" );
	
		//Create a "fake body" for testing based on method used in jQuery.support
		testElement = document.createElement( body ? "div" : "body" );
		testElementStyle = {
			visibility: "hidden",
			width: 0,
			height: 0,
			border: 0,
			margin: 0,
			background: "none"
		};
		if ( body ) {
			$.extend( testElementStyle, {
				position: "absolute",
				left: "-1000px",
				top: "-1000px"
			});
		}
		for ( i in testElementStyle ) {
			testElement.style[ i ] = testElementStyle[ i ];
		}
		testElement.appendChild( div );
		testElementParent = body || document.documentElement;
		testElementParent.insertBefore( testElement, testElementParent.firstChild );
	
		div.style.cssText = "position: absolute; left: 10.7432222px;";
	
		offsetLeft = $( div ).offset().left;
		supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
	
		testElement.innerHTML = "";
		testElementParent.removeChild( testElement );
	})();
	
	})();
	
	var position = $.ui.position;
	
	
	/*!
	 * jQuery UI Draggable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/draggable/
	 */
	
	
	$.widget("ui.draggable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "drag",
		options: {
			addClasses: true,
			appendTo: "parent",
			axis: false,
			connectToSortable: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			grid: false,
			handle: false,
			helper: "original",
			iframeFix: false,
			opacity: false,
			refreshPositions: false,
			revert: false,
			revertDuration: 500,
			scope: "default",
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			snap: false,
			snapMode: "both",
			snapTolerance: 20,
			stack: false,
			zIndex: false,
	
			// callbacks
			drag: null,
			start: null,
			stop: null
		},
		_create: function() {
	
			if ( this.options.helper === "original" ) {
				this._setPositionRelative();
			}
			if (this.options.addClasses){
				this.element.addClass("ui-draggable");
			}
			if (this.options.disabled){
				this.element.addClass("ui-draggable-disabled");
			}
			this._setHandleClassName();
	
			this._mouseInit();
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "handle" ) {
				this._removeHandleClassName();
				this._setHandleClassName();
			}
		},
	
		_destroy: function() {
			if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
				this.destroyOnClear = true;
				return;
			}
			this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
			this._removeHandleClassName();
			this._mouseDestroy();
		},
	
		_mouseCapture: function(event) {
			var o = this.options;
	
			this._blurActiveElement( event );
	
			// among others, prevent a drag on a resizable-handle
			if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
				return false;
			}
	
			//Quit if we're not on a valid handle
			this.handle = this._getHandle(event);
			if (!this.handle) {
				return false;
			}
	
			this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );
	
			return true;
	
		},
	
		_blockFrames: function( selector ) {
			this.iframeBlocks = this.document.find( selector ).map(function() {
				var iframe = $( this );
	
				return $( "<div>" )
					.css( "position", "absolute" )
					.appendTo( iframe.parent() )
					.outerWidth( iframe.outerWidth() )
					.outerHeight( iframe.outerHeight() )
					.offset( iframe.offset() )[ 0 ];
			});
		},
	
		_unblockFrames: function() {
			if ( this.iframeBlocks ) {
				this.iframeBlocks.remove();
				delete this.iframeBlocks;
			}
		},
	
		_blurActiveElement: function( event ) {
			var document = this.document[ 0 ];
	
			// Only need to blur if the event occurred on the draggable itself, see #10527
			if ( !this.handleElement.is( event.target ) ) {
				return;
			}
	
			// support: IE9
			// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
			try {
	
				// Support: IE9, IE10
				// If the <body> is blurred, IE will switch windows, see #9520
				if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {
	
					// Blur any element that currently has focus, see #4261
					$( document.activeElement ).blur();
				}
			} catch ( error ) {}
		},
	
		_mouseStart: function(event) {
	
			var o = this.options;
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			this.helper.addClass("ui-draggable-dragging");
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			//If ddmanager is used for droppables, set the global draggable
			if ($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Store the helper's css position
			this.cssPosition = this.helper.css( "position" );
			this.scrollParent = this.helper.scrollParent( true );
			this.offsetParent = this.helper.offsetParent();
			this.hasFixedAncestor = this.helper.parents().filter(function() {
					return $( this ).css( "position" ) === "fixed";
				}).length > 0;
	
			//The element's absolute position on the page minus margins
			this.positionAbs = this.element.offset();
			this._refreshOffsets( event );
	
			//Generate the original position
			this.originalPosition = this.position = this._generatePosition( event, false );
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Set a containment if given in the options
			this._setContainment();
	
			//Trigger event + callbacks
			if (this._trigger("start", event) === false) {
				this._clear();
				return false;
			}
	
			//Recache the helper size
			this._cacheHelperProportions();
	
			//Prepare the droppable offsets
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
			// Reset helper's right/bottom css if they're set and set explicit width/height instead
			// as this prevents resizing of elements with right/bottom set (see #7772)
			this._normalizeRightBottom();
	
			this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
	
			//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStart(this, event);
			}
	
			return true;
		},
	
		_refreshOffsets: function( event ) {
			this.offset = {
				top: this.positionAbs.top - this.margins.top,
				left: this.positionAbs.left - this.margins.left,
				scroll: false,
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset()
			};
	
			this.offset.click = {
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			};
		},
	
		_mouseDrag: function(event, noPropagation) {
			// reset any necessary cached properties (see #5009)
			if ( this.hasFixedAncestor ) {
				this.offset.parent = this._getParentOffset();
			}
	
			//Compute the helpers position
			this.position = this._generatePosition( event, true );
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Call plugins and callbacks and use the resulting position if something is returned
			if (!noPropagation) {
				var ui = this._uiHash();
				if (this._trigger("drag", event, ui) === false) {
					this._mouseUp({});
					return false;
				}
				this.position = ui.position;
			}
	
			this.helper[ 0 ].style.left = this.position.left + "px";
			this.helper[ 0 ].style.top = this.position.top + "px";
	
			if ($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			//If we are using droppables, inform the manager about the drop
			var that = this,
				dropped = false;
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				dropped = $.ui.ddmanager.drop(this, event);
			}
	
			//if a drop comes from outside (a sortable)
			if (this.dropped) {
				dropped = this.dropped;
				this.dropped = false;
			}
	
			if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
				$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
					if (that._trigger("stop", event) !== false) {
						that._clear();
					}
				});
			} else {
				if (this._trigger("stop", event) !== false) {
					this._clear();
				}
			}
	
			return false;
		},
	
		_mouseUp: function( event ) {
			this._unblockFrames();
	
			//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStop(this, event);
			}
	
			// Only need to focus if the event occurred on the draggable itself, see #10527
			if ( this.handleElement.is( event.target ) ) {
				// The interaction is over; whether or not the click resulted in a drag, focus the element
				this.element.focus();
			}
	
			return $.ui.mouse.prototype._mouseUp.call(this, event);
		},
	
		cancel: function() {
	
			if (this.helper.is(".ui-draggable-dragging")) {
				this._mouseUp({});
			} else {
				this._clear();
			}
	
			return this;
	
		},
	
		_getHandle: function(event) {
			return this.options.handle ?
				!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
				true;
		},
	
		_setHandleClassName: function() {
			this.handleElement = this.options.handle ?
				this.element.find( this.options.handle ) : this.element;
			this.handleElement.addClass( "ui-draggable-handle" );
		},
	
		_removeHandleClassName: function() {
			this.handleElement.removeClass( "ui-draggable-handle" );
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helperIsFunction = $.isFunction( o.helper ),
				helper = helperIsFunction ?
					$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
					( o.helper === "clone" ?
						this.element.clone().removeAttr( "id" ) :
						this.element );
	
			if (!helper.parents("body").length) {
				helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
			}
	
			// http://bugs.jqueryui.com/ticket/9446
			// a helper function can return the original element
			// which wouldn't have been set to relative in _create
			if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
				this._setPositionRelative();
			}
	
			if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
				helper.css("position", "absolute");
			}
	
			return helper;
	
		},
	
		_setPositionRelative: function() {
			if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
				this.element[ 0 ].style.position = "relative";
			}
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = { left: +obj[0], top: +obj[1] || 0 };
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_isRootNode: function( element ) {
			return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
		},
	
		_getParentOffset: function() {
	
			//Get the offsetParent and cache its position
			var po = this.offsetParent.offset(),
				document = this.document[ 0 ];
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
			if ( this.cssPosition !== "relative" ) {
				return { top: 0, left: 0 };
			}
	
			var p = this.element.position(),
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
	
			return {
				top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
				left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
			};
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.element.css("marginLeft"), 10) || 0),
				top: (parseInt(this.element.css("marginTop"), 10) || 0),
				right: (parseInt(this.element.css("marginRight"), 10) || 0),
				bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var isUserScrollable, c, ce,
				o = this.options,
				document = this.document[ 0 ];
	
			this.relativeContainer = null;
	
			if ( !o.containment ) {
				this.containment = null;
				return;
			}
	
			if ( o.containment === "window" ) {
				this.containment = [
					$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
					$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
					$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
					$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment === "document") {
				this.containment = [
					0,
					0,
					$( document ).width() - this.helperProportions.width - this.margins.left,
					( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment.constructor === Array ) {
				this.containment = o.containment;
				return;
			}
	
			if ( o.containment === "parent" ) {
				o.containment = this.helper[ 0 ].parentNode;
			}
	
			c = $( o.containment );
			ce = c[ 0 ];
	
			if ( !ce ) {
				return;
			}
	
			isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );
	
			this.containment = [
				( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
				( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
				( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
					( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
					this.helperProportions.width -
					this.margins.left -
					this.margins.right,
				( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
					( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
					this.helperProportions.height -
					this.margins.top -
					this.margins.bottom
			];
			this.relativeContainer = c;
		},
	
		_convertPositionTo: function(d, pos) {
	
			if (!pos) {
				pos = this.position;
			}
	
			var mod = d === "absolute" ? 1 : -1,
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
				)
			};
	
		},
	
		_generatePosition: function( event, constrainPosition ) {
	
			var containment, co, top, left,
				o = this.options,
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
				pageX = event.pageX,
				pageY = event.pageY;
	
			// Cache the scroll
			if ( !scrollIsRootNode || !this.offset.scroll ) {
				this.offset.scroll = {
					top: this.scrollParent.scrollTop(),
					left: this.scrollParent.scrollLeft()
				};
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			// If we are not dragging yet, we won't check for options
			if ( constrainPosition ) {
				if ( this.containment ) {
					if ( this.relativeContainer ){
						co = this.relativeContainer.offset();
						containment = [
							this.containment[ 0 ] + co.left,
							this.containment[ 1 ] + co.top,
							this.containment[ 2 ] + co.left,
							this.containment[ 3 ] + co.top
						];
					} else {
						containment = this.containment;
					}
	
					if (event.pageX - this.offset.click.left < containment[0]) {
						pageX = containment[0] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top < containment[1]) {
						pageY = containment[1] + this.offset.click.top;
					}
					if (event.pageX - this.offset.click.left > containment[2]) {
						pageX = containment[2] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top > containment[3]) {
						pageY = containment[3] + this.offset.click.top;
					}
				}
	
				if (o.grid) {
					//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
					top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
					pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
					pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
				if ( o.axis === "y" ) {
					pageX = this.originalPageX;
				}
	
				if ( o.axis === "x" ) {
					pageY = this.originalPageY;
				}
			}
	
			return {
				top: (
					pageY -																	// The absolute mouse position
					this.offset.click.top	-												// Click offset (relative to the element)
					this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
				),
				left: (
					pageX -																	// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
				)
			};
	
		},
	
		_clear: function() {
			this.helper.removeClass("ui-draggable-dragging");
			if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
				this.helper.remove();
			}
			this.helper = null;
			this.cancelHelperRemoval = false;
			if ( this.destroyOnClear ) {
				this.destroy();
			}
		},
	
		_normalizeRightBottom: function() {
			if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
				this.helper.width( this.helper.width() );
				this.helper.css( "right", "auto" );
			}
			if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
				this.helper.height( this.helper.height() );
				this.helper.css( "bottom", "auto" );
			}
		},
	
		// From now on bulk stuff - mainly helpers
	
		_trigger: function( type, event, ui ) {
			ui = ui || this._uiHash();
			$.ui.plugin.call( this, type, [ event, ui, this ], true );
	
			// Absolute position and offset (see #6884 ) have to be recalculated after plugins
			if ( /^(drag|start|stop)/.test( type ) ) {
				this.positionAbs = this._convertPositionTo( "absolute" );
				ui.offset = this.positionAbs;
			}
			return $.Widget.prototype._trigger.call( this, type, event, ui );
		},
	
		plugins: {},
	
		_uiHash: function() {
			return {
				helper: this.helper,
				position: this.position,
				originalPosition: this.originalPosition,
				offset: this.positionAbs
			};
		}
	
	});
	
	$.ui.plugin.add( "draggable", "connectToSortable", {
		start: function( event, ui, draggable ) {
			var uiSortable = $.extend( {}, ui, {
				item: draggable.element
			});
	
			draggable.sortables = [];
			$( draggable.options.connectToSortable ).each(function() {
				var sortable = $( this ).sortable( "instance" );
	
				if ( sortable && !sortable.options.disabled ) {
					draggable.sortables.push( sortable );
	
					// refreshPositions is called at drag start to refresh the containerCache
					// which is used in drag. This ensures it's initialized and synchronized
					// with any changes that might have happened on the page since initialization.
					sortable.refreshPositions();
					sortable._trigger("activate", event, uiSortable);
				}
			});
		},
		stop: function( event, ui, draggable ) {
			var uiSortable = $.extend( {}, ui, {
				item: draggable.element
			});
	
			draggable.cancelHelperRemoval = false;
	
			$.each( draggable.sortables, function() {
				var sortable = this;
	
				if ( sortable.isOver ) {
					sortable.isOver = 0;
	
					// Allow this sortable to handle removing the helper
					draggable.cancelHelperRemoval = true;
					sortable.cancelHelperRemoval = false;
	
					// Use _storedCSS To restore properties in the sortable,
					// as this also handles revert (#9675) since the draggable
					// may have modified them in unexpected ways (#8809)
					sortable._storedCSS = {
						position: sortable.placeholder.css( "position" ),
						top: sortable.placeholder.css( "top" ),
						left: sortable.placeholder.css( "left" )
					};
	
					sortable._mouseStop(event);
	
					// Once drag has ended, the sortable should return to using
					// its original helper, not the shared helper from draggable
					sortable.options.helper = sortable.options._helper;
				} else {
					// Prevent this Sortable from removing the helper.
					// However, don't set the draggable to remove the helper
					// either as another connected Sortable may yet handle the removal.
					sortable.cancelHelperRemoval = true;
	
					sortable._trigger( "deactivate", event, uiSortable );
				}
			});
		},
		drag: function( event, ui, draggable ) {
			$.each( draggable.sortables, function() {
				var innermostIntersecting = false,
					sortable = this;
	
				// Copy over variables that sortable's _intersectsWith uses
				sortable.positionAbs = draggable.positionAbs;
				sortable.helperProportions = draggable.helperProportions;
				sortable.offset.click = draggable.offset.click;
	
				if ( sortable._intersectsWith( sortable.containerCache ) ) {
					innermostIntersecting = true;
	
					$.each( draggable.sortables, function() {
						// Copy over variables that sortable's _intersectsWith uses
						this.positionAbs = draggable.positionAbs;
						this.helperProportions = draggable.helperProportions;
						this.offset.click = draggable.offset.click;
	
						if ( this !== sortable &&
								this._intersectsWith( this.containerCache ) &&
								$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
							innermostIntersecting = false;
						}
	
						return innermostIntersecting;
					});
				}
	
				if ( innermostIntersecting ) {
					// If it intersects, we use a little isOver variable and set it once,
					// so that the move-in stuff gets fired only once.
					if ( !sortable.isOver ) {
						sortable.isOver = 1;
	
						// Store draggable's parent in case we need to reappend to it later.
						draggable._parent = ui.helper.parent();
	
						sortable.currentItem = ui.helper
							.appendTo( sortable.element )
							.data( "ui-sortable-item", true );
	
						// Store helper option to later restore it
						sortable.options._helper = sortable.options.helper;
	
						sortable.options.helper = function() {
							return ui.helper[ 0 ];
						};
	
						// Fire the start events of the sortable with our passed browser event,
						// and our own helper (so it doesn't create a new one)
						event.target = sortable.currentItem[ 0 ];
						sortable._mouseCapture( event, true );
						sortable._mouseStart( event, true, true );
	
						// Because the browser event is way off the new appended portlet,
						// modify necessary variables to reflect the changes
						sortable.offset.click.top = draggable.offset.click.top;
						sortable.offset.click.left = draggable.offset.click.left;
						sortable.offset.parent.left -= draggable.offset.parent.left -
							sortable.offset.parent.left;
						sortable.offset.parent.top -= draggable.offset.parent.top -
							sortable.offset.parent.top;
	
						draggable._trigger( "toSortable", event );
	
						// Inform draggable that the helper is in a valid drop zone,
						// used solely in the revert option to handle "valid/invalid".
						draggable.dropped = sortable.element;
	
						// Need to refreshPositions of all sortables in the case that
						// adding to one sortable changes the location of the other sortables (#9675)
						$.each( draggable.sortables, function() {
							this.refreshPositions();
						});
	
						// hack so receive/update callbacks work (mostly)
						draggable.currentItem = draggable.element;
						sortable.fromOutside = draggable;
					}
	
					if ( sortable.currentItem ) {
						sortable._mouseDrag( event );
						// Copy the sortable's position because the draggable's can potentially reflect
						// a relative position, while sortable is always absolute, which the dragged
						// element has now become. (#8809)
						ui.position = sortable.position;
					}
				} else {
					// If it doesn't intersect with the sortable, and it intersected before,
					// we fake the drag stop of the sortable, but make sure it doesn't remove
					// the helper by using cancelHelperRemoval.
					if ( sortable.isOver ) {
	
						sortable.isOver = 0;
						sortable.cancelHelperRemoval = true;
	
						// Calling sortable's mouseStop would trigger a revert,
						// so revert must be temporarily false until after mouseStop is called.
						sortable.options._revert = sortable.options.revert;
						sortable.options.revert = false;
	
						sortable._trigger( "out", event, sortable._uiHash( sortable ) );
						sortable._mouseStop( event, true );
	
						// restore sortable behaviors that were modfied
						// when the draggable entered the sortable area (#9481)
						sortable.options.revert = sortable.options._revert;
						sortable.options.helper = sortable.options._helper;
	
						if ( sortable.placeholder ) {
							sortable.placeholder.remove();
						}
	
						// Restore and recalculate the draggable's offset considering the sortable
						// may have modified them in unexpected ways. (#8809, #10669)
						ui.helper.appendTo( draggable._parent );
						draggable._refreshOffsets( event );
						ui.position = draggable._generatePosition( event, true );
	
						draggable._trigger( "fromSortable", event );
	
						// Inform draggable that the helper is no longer in a valid drop zone
						draggable.dropped = false;
	
						// Need to refreshPositions of all sortables just in case removing
						// from one sortable changes the location of other sortables (#9675)
						$.each( draggable.sortables, function() {
							this.refreshPositions();
						});
					}
				}
			});
		}
	});
	
	$.ui.plugin.add("draggable", "cursor", {
		start: function( event, ui, instance ) {
			var t = $( "body" ),
				o = instance.options;
	
			if (t.css("cursor")) {
				o._cursor = t.css("cursor");
			}
			t.css("cursor", o.cursor);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
			if (o._cursor) {
				$("body").css("cursor", o._cursor);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "opacity", {
		start: function( event, ui, instance ) {
			var t = $( ui.helper ),
				o = instance.options;
			if (t.css("opacity")) {
				o._opacity = t.css("opacity");
			}
			t.css("opacity", o.opacity);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
			if (o._opacity) {
				$(ui.helper).css("opacity", o._opacity);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "scroll", {
		start: function( event, ui, i ) {
			if ( !i.scrollParentNotHidden ) {
				i.scrollParentNotHidden = i.helper.scrollParent( false );
			}
	
			if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
				i.overflowOffset = i.scrollParentNotHidden.offset();
			}
		},
		drag: function( event, ui, i  ) {
	
			var o = i.options,
				scrolled = false,
				scrollParent = i.scrollParentNotHidden[ 0 ],
				document = i.document[ 0 ];
	
			if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
				if ( !o.axis || o.axis !== "x" ) {
					if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
						scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
					} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
						scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
					}
				}
	
				if ( !o.axis || o.axis !== "y" ) {
					if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
						scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
					} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
						scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
					}
				}
	
			} else {
	
				if (!o.axis || o.axis !== "x") {
					if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}
				}
	
				if (!o.axis || o.axis !== "y") {
					if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}
				}
	
			}
	
			if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(i, event);
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "snap", {
		start: function( event, ui, i ) {
	
			var o = i.options;
	
			i.snapElements = [];
	
			$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
				var $t = $(this),
					$o = $t.offset();
				if (this !== i.element[0]) {
					i.snapElements.push({
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					});
				}
			});
	
		},
		drag: function( event, ui, inst ) {
	
			var ts, bs, ls, rs, l, r, t, b, i, first,
				o = inst.options,
				d = o.snapTolerance,
				x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
				y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
	
			for (i = inst.snapElements.length - 1; i >= 0; i--){
	
				l = inst.snapElements[i].left - inst.margins.left;
				r = l + inst.snapElements[i].width;
				t = inst.snapElements[i].top - inst.margins.top;
				b = t + inst.snapElements[i].height;
	
				if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
					if (inst.snapElements[i].snapping) {
						(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
					}
					inst.snapElements[i].snapping = false;
					continue;
				}
	
				if (o.snapMode !== "inner") {
					ts = Math.abs(t - y2) <= d;
					bs = Math.abs(b - y1) <= d;
					ls = Math.abs(l - x2) <= d;
					rs = Math.abs(r - x1) <= d;
					if (ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
					}
					if (bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
					}
					if (ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
					}
					if (rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
					}
				}
	
				first = (ts || bs || ls || rs);
	
				if (o.snapMode !== "outer") {
					ts = Math.abs(t - y1) <= d;
					bs = Math.abs(b - y2) <= d;
					ls = Math.abs(l - x1) <= d;
					rs = Math.abs(r - x2) <= d;
					if (ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
					}
					if (bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
					}
					if (ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
					}
					if (rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
					}
				}
	
				if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
					(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
	
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "stack", {
		start: function( event, ui, instance ) {
			var min,
				o = instance.options,
				group = $.makeArray($(o.stack)).sort(function(a, b) {
					return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
				});
	
			if (!group.length) { return; }
	
			min = parseInt($(group[0]).css("zIndex"), 10) || 0;
			$(group).each(function(i) {
				$(this).css("zIndex", min + i);
			});
			this.css("zIndex", (min + group.length));
		}
	});
	
	$.ui.plugin.add("draggable", "zIndex", {
		start: function( event, ui, instance ) {
			var t = $( ui.helper ),
				o = instance.options;
	
			if (t.css("zIndex")) {
				o._zIndex = t.css("zIndex");
			}
			t.css("zIndex", o.zIndex);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
	
			if (o._zIndex) {
				$(ui.helper).css("zIndex", o._zIndex);
			}
		}
	});
	
	var draggable = $.ui.draggable;
	
	
	/*!
	 * jQuery UI Droppable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/droppable/
	 */
	
	
	$.widget( "ui.droppable", {
		version: "1.11.4",
		widgetEventPrefix: "drop",
		options: {
			accept: "*",
			activeClass: false,
			addClasses: true,
			greedy: false,
			hoverClass: false,
			scope: "default",
			tolerance: "intersect",
	
			// callbacks
			activate: null,
			deactivate: null,
			drop: null,
			out: null,
			over: null
		},
		_create: function() {
	
			var proportions,
				o = this.options,
				accept = o.accept;
	
			this.isover = false;
			this.isout = true;
	
			this.accept = $.isFunction( accept ) ? accept : function( d ) {
				return d.is( accept );
			};
	
			this.proportions = function( /* valueToWrite */ ) {
				if ( arguments.length ) {
					// Store the droppable's proportions
					proportions = arguments[ 0 ];
				} else {
					// Retrieve or derive the droppable's proportions
					return proportions ?
						proportions :
						proportions = {
							width: this.element[ 0 ].offsetWidth,
							height: this.element[ 0 ].offsetHeight
						};
				}
			};
	
			this._addToManager( o.scope );
	
			o.addClasses && this.element.addClass( "ui-droppable" );
	
		},
	
		_addToManager: function( scope ) {
			// Add the reference and positions to the manager
			$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
			$.ui.ddmanager.droppables[ scope ].push( this );
		},
	
		_splice: function( drop ) {
			var i = 0;
			for ( ; i < drop.length; i++ ) {
				if ( drop[ i ] === this ) {
					drop.splice( i, 1 );
				}
			}
		},
	
		_destroy: function() {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];
	
			this._splice( drop );
	
			this.element.removeClass( "ui-droppable ui-droppable-disabled" );
		},
	
		_setOption: function( key, value ) {
	
			if ( key === "accept" ) {
				this.accept = $.isFunction( value ) ? value : function( d ) {
					return d.is( value );
				};
			} else if ( key === "scope" ) {
				var drop = $.ui.ddmanager.droppables[ this.options.scope ];
	
				this._splice( drop );
				this._addToManager( value );
			}
	
			this._super( key, value );
		},
	
		_activate: function( event ) {
			var draggable = $.ui.ddmanager.current;
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
			if ( draggable ){
				this._trigger( "activate", event, this.ui( draggable ) );
			}
		},
	
		_deactivate: function( event ) {
			var draggable = $.ui.ddmanager.current;
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( draggable ){
				this._trigger( "deactivate", event, this.ui( draggable ) );
			}
		},
	
		_over: function( event ) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.hoverClass ) {
					this.element.addClass( this.options.hoverClass );
				}
				this._trigger( "over", event, this.ui( draggable ) );
			}
	
		},
	
		_out: function( event ) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.hoverClass ) {
					this.element.removeClass( this.options.hoverClass );
				}
				this._trigger( "out", event, this.ui( draggable ) );
			}
	
		},
	
		_drop: function( event, custom ) {
	
			var draggable = custom || $.ui.ddmanager.current,
				childrenIntersection = false;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return false;
			}
	
			this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
					$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
				) { childrenIntersection = true; return false; }
			});
			if ( childrenIntersection ) {
				return false;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.activeClass ) {
					this.element.removeClass( this.options.activeClass );
				}
				if ( this.options.hoverClass ) {
					this.element.removeClass( this.options.hoverClass );
				}
				this._trigger( "drop", event, this.ui( draggable ) );
				return this.element;
			}
	
			return false;
	
		},
	
		ui: function( c ) {
			return {
				draggable: ( c.currentItem || c.element ),
				helper: c.helper,
				position: c.position,
				offset: c.positionAbs
			};
		}
	
	});
	
	$.ui.intersect = (function() {
		function isOverAxis( x, reference, size ) {
			return ( x >= reference ) && ( x < ( reference + size ) );
		}
	
		return function( draggable, droppable, toleranceMode, event ) {
	
			if ( !droppable.offset ) {
				return false;
			}
	
			var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
				y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
				x2 = x1 + draggable.helperProportions.width,
				y2 = y1 + draggable.helperProportions.height,
				l = droppable.offset.left,
				t = droppable.offset.top,
				r = l + droppable.proportions().width,
				b = t + droppable.proportions().height;
	
			switch ( toleranceMode ) {
			case "fit":
				return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
			case "intersect":
				return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
					x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
					t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
					y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
			case "pointer":
				return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
			case "touch":
				return (
					( y1 >= t && y1 <= b ) || // Top edge touching
					( y2 >= t && y2 <= b ) || // Bottom edge touching
					( y1 < t && y2 > b ) // Surrounded vertically
				) && (
					( x1 >= l && x1 <= r ) || // Left edge touching
					( x2 >= l && x2 <= r ) || // Right edge touching
					( x1 < l && x2 > r ) // Surrounded horizontally
				);
			default:
				return false;
			}
		};
	})();
	
	/*
		This manager tracks offsets of draggables and droppables
	*/
	$.ui.ddmanager = {
		current: null,
		droppables: { "default": [] },
		prepareOffsets: function( t, event ) {
	
			var i, j,
				m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
				type = event ? event.type : null, // workaround for #2317
				list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();
	
			droppablesLoop: for ( i = 0; i < m.length; i++ ) {
	
				// No disabled and non-accepted
				if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
					continue;
				}
	
				// Filter out elements in the current dragged item
				for ( j = 0; j < list.length; j++ ) {
					if ( list[ j ] === m[ i ].element[ 0 ] ) {
						m[ i ].proportions().height = 0;
						continue droppablesLoop;
					}
				}
	
				m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
				if ( !m[ i ].visible ) {
					continue;
				}
	
				// Activate the droppable if used directly from draggables
				if ( type === "mousedown" ) {
					m[ i ]._activate.call( m[ i ], event );
				}
	
				m[ i ].offset = m[ i ].element.offset();
				m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });
	
			}
	
		},
		drop: function( draggable, event ) {
	
			var dropped = false;
			// Create a copy of the droppables in case the list changes during the drop (#9116)
			$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {
	
				if ( !this.options ) {
					return;
				}
				if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
					dropped = this._drop.call( this, event ) || dropped;
				}
	
				if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
					this.isout = true;
					this.isover = false;
					this._deactivate.call( this, event );
				}
	
			});
			return dropped;
	
		},
		dragStart: function( draggable, event ) {
			// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
			draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
				if ( !draggable.options.refreshPositions ) {
					$.ui.ddmanager.prepareOffsets( draggable, event );
				}
			});
		},
		drag: function( draggable, event ) {
	
			// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
			if ( draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
	
			// Run through all droppables and check their positions based on specific tolerance options
			$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {
	
				if ( this.options.disabled || this.greedyChild || !this.visible ) {
					return;
				}
	
				var parentInstance, scope, parent,
					intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
					c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
				if ( !c ) {
					return;
				}
	
				if ( this.options.greedy ) {
					// find droppable parents with same scope
					scope = this.options.scope;
					parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
						return $( this ).droppable( "instance" ).options.scope === scope;
					});
	
					if ( parent.length ) {
						parentInstance = $( parent[ 0 ] ).droppable( "instance" );
						parentInstance.greedyChild = ( c === "isover" );
					}
				}
	
				// we just moved into a greedy child
				if ( parentInstance && c === "isover" ) {
					parentInstance.isover = false;
					parentInstance.isout = true;
					parentInstance._out.call( parentInstance, event );
				}
	
				this[ c ] = true;
				this[c === "isout" ? "isover" : "isout"] = false;
				this[c === "isover" ? "_over" : "_out"].call( this, event );
	
				// we just moved out of a greedy child
				if ( parentInstance && c === "isout" ) {
					parentInstance.isout = false;
					parentInstance.isover = true;
					parentInstance._over.call( parentInstance, event );
				}
			});
	
		},
		dragStop: function( draggable, event ) {
			draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
			// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		}
	};
	
	var droppable = $.ui.droppable;
	
	
	/*!
	 * jQuery UI Resizable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/resizable/
	 */
	
	
	$.widget("ui.resizable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "resize",
		options: {
			alsoResize: false,
			animate: false,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: false,
			autoHide: false,
			containment: false,
			ghost: false,
			grid: false,
			handles: "e,s,se",
			helper: false,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			// See #7960
			zIndex: 90,
	
			// callbacks
			resize: null,
			start: null,
			stop: null
		},
	
		_num: function( value ) {
			return parseInt( value, 10 ) || 0;
		},
	
		_isNumber: function( value ) {
			return !isNaN( parseInt( value, 10 ) );
		},
	
		_hasScroll: function( el, a ) {
	
			if ( $( el ).css( "overflow" ) === "hidden") {
				return false;
			}
	
			var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
				has = false;
	
			if ( el[ scroll ] > 0 ) {
				return true;
			}
	
			// TODO: determine which cases actually cause this to happen
			// if the element doesn't have the scroll set, see if it's possible to
			// set the scroll
			el[ scroll ] = 1;
			has = ( el[ scroll ] > 0 );
			el[ scroll ] = 0;
			return has;
		},
	
		_create: function() {
	
			var n, i, handle, axis, hname,
				that = this,
				o = this.options;
			this.element.addClass("ui-resizable");
	
			$.extend(this, {
				_aspectRatio: !!(o.aspectRatio),
				aspectRatio: o.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
			});
	
			// Wrap the element if it cannot hold child nodes
			if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
	
				this.element.wrap(
					$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
						position: this.element.css("position"),
						width: this.element.outerWidth(),
						height: this.element.outerHeight(),
						top: this.element.css("top"),
						left: this.element.css("left")
					})
				);
	
				this.element = this.element.parent().data(
					"ui-resizable", this.element.resizable( "instance" )
				);
	
				this.elementIsWrapper = true;
	
				this.element.css({
					marginLeft: this.originalElement.css("marginLeft"),
					marginTop: this.originalElement.css("marginTop"),
					marginRight: this.originalElement.css("marginRight"),
					marginBottom: this.originalElement.css("marginBottom")
				});
				this.originalElement.css({
					marginLeft: 0,
					marginTop: 0,
					marginRight: 0,
					marginBottom: 0
				});
				// support: Safari
				// Prevent Safari textarea resize
				this.originalResizeStyle = this.originalElement.css("resize");
				this.originalElement.css("resize", "none");
	
				this._proportionallyResizeElements.push( this.originalElement.css({
					position: "static",
					zoom: 1,
					display: "block"
				}) );
	
				// support: IE9
				// avoid IE jump (hard set the margin)
				this.originalElement.css({ margin: this.originalElement.css("margin") });
	
				this._proportionallyResize();
			}
	
			this.handles = o.handles ||
				( !$(".ui-resizable-handle", this.element).length ?
					"e,s,se" : {
						n: ".ui-resizable-n",
						e: ".ui-resizable-e",
						s: ".ui-resizable-s",
						w: ".ui-resizable-w",
						se: ".ui-resizable-se",
						sw: ".ui-resizable-sw",
						ne: ".ui-resizable-ne",
						nw: ".ui-resizable-nw"
					} );
	
			this._handles = $();
			if ( this.handles.constructor === String ) {
	
				if ( this.handles === "all") {
					this.handles = "n,e,s,w,se,sw,ne,nw";
				}
	
				n = this.handles.split(",");
				this.handles = {};
	
				for (i = 0; i < n.length; i++) {
	
					handle = $.trim(n[i]);
					hname = "ui-resizable-" + handle;
					axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
	
					axis.css({ zIndex: o.zIndex });
	
					// TODO : What's going on here?
					if ("se" === handle) {
						axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
					}
	
					this.handles[handle] = ".ui-resizable-" + handle;
					this.element.append(axis);
				}
	
			}
	
			this._renderAxis = function(target) {
	
				var i, axis, padPos, padWrapper;
	
				target = target || this.element;
	
				for (i in this.handles) {
	
					if (this.handles[i].constructor === String) {
						this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
					} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
						this.handles[ i ] = $( this.handles[ i ] );
						this._on( this.handles[ i ], { "mousedown": that._mouseDown });
					}
	
					if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
	
						axis = $(this.handles[i], this.element);
	
						padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
	
						padPos = [ "padding",
							/ne|nw|n/.test(i) ? "Top" :
							/se|sw|s/.test(i) ? "Bottom" :
							/^e$/.test(i) ? "Right" : "Left" ].join("");
	
						target.css(padPos, padWrapper);
	
						this._proportionallyResize();
					}
	
					this._handles = this._handles.add( this.handles[ i ] );
				}
			};
	
			// TODO: make renderAxis a prototype function
			this._renderAxis(this.element);
	
			this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
			this._handles.disableSelection();
	
			this._handles.mouseover(function() {
				if (!that.resizing) {
					if (this.className) {
						axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
					}
					that.axis = axis && axis[1] ? axis[1] : "se";
				}
			});
	
			if (o.autoHide) {
				this._handles.hide();
				$(this.element)
					.addClass("ui-resizable-autohide")
					.mouseenter(function() {
						if (o.disabled) {
							return;
						}
						$(this).removeClass("ui-resizable-autohide");
						that._handles.show();
					})
					.mouseleave(function() {
						if (o.disabled) {
							return;
						}
						if (!that.resizing) {
							$(this).addClass("ui-resizable-autohide");
							that._handles.hide();
						}
					});
			}
	
			this._mouseInit();
		},
	
		_destroy: function() {
	
			this._mouseDestroy();
	
			var wrapper,
				_destroy = function(exp) {
					$(exp)
						.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
						.removeData("resizable")
						.removeData("ui-resizable")
						.unbind(".resizable")
						.find(".ui-resizable-handle")
							.remove();
				};
	
			// TODO: Unwrap at same DOM position
			if (this.elementIsWrapper) {
				_destroy(this.element);
				wrapper = this.element;
				this.originalElement.css({
					position: wrapper.css("position"),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css("top"),
					left: wrapper.css("left")
				}).insertAfter( wrapper );
				wrapper.remove();
			}
	
			this.originalElement.css("resize", this.originalResizeStyle);
			_destroy(this.originalElement);
	
			return this;
		},
	
		_mouseCapture: function(event) {
			var i, handle,
				capture = false;
	
			for (i in this.handles) {
				handle = $(this.handles[i])[0];
				if (handle === event.target || $.contains(handle, event.target)) {
					capture = true;
				}
			}
	
			return !this.options.disabled && capture;
		},
	
		_mouseStart: function(event) {
	
			var curleft, curtop, cursor,
				o = this.options,
				el = this.element;
	
			this.resizing = true;
	
			this._renderProxy();
	
			curleft = this._num(this.helper.css("left"));
			curtop = this._num(this.helper.css("top"));
	
			if (o.containment) {
				curleft += $(o.containment).scrollLeft() || 0;
				curtop += $(o.containment).scrollTop() || 0;
			}
	
			this.offset = this.helper.offset();
			this.position = { left: curleft, top: curtop };
	
			this.size = this._helper ? {
					width: this.helper.width(),
					height: this.helper.height()
				} : {
					width: el.width(),
					height: el.height()
				};
	
			this.originalSize = this._helper ? {
					width: el.outerWidth(),
					height: el.outerHeight()
				} : {
					width: el.width(),
					height: el.height()
				};
	
			this.sizeDiff = {
				width: el.outerWidth() - el.width(),
				height: el.outerHeight() - el.height()
			};
	
			this.originalPosition = { left: curleft, top: curtop };
			this.originalMousePosition = { left: event.pageX, top: event.pageY };
	
			this.aspectRatio = (typeof o.aspectRatio === "number") ?
				o.aspectRatio :
				((this.originalSize.width / this.originalSize.height) || 1);
	
			cursor = $(".ui-resizable-" + this.axis).css("cursor");
			$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
	
			el.addClass("ui-resizable-resizing");
			this._propagate("start", event);
			return true;
		},
	
		_mouseDrag: function(event) {
	
			var data, props,
				smp = this.originalMousePosition,
				a = this.axis,
				dx = (event.pageX - smp.left) || 0,
				dy = (event.pageY - smp.top) || 0,
				trigger = this._change[a];
	
			this._updatePrevProperties();
	
			if (!trigger) {
				return false;
			}
	
			data = trigger.apply(this, [ event, dx, dy ]);
	
			this._updateVirtualBoundaries(event.shiftKey);
			if (this._aspectRatio || event.shiftKey) {
				data = this._updateRatio(data, event);
			}
	
			data = this._respectSize(data, event);
	
			this._updateCache(data);
	
			this._propagate("resize", event);
	
			props = this._applyChanges();
	
			if ( !this._helper && this._proportionallyResizeElements.length ) {
				this._proportionallyResize();
			}
	
			if ( !$.isEmptyObject( props ) ) {
				this._updatePrevProperties();
				this._trigger( "resize", event, this.ui() );
				this._applyChanges();
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			this.resizing = false;
			var pr, ista, soffseth, soffsetw, s, left, top,
				o = this.options, that = this;
	
			if (this._helper) {
	
				pr = this._proportionallyResizeElements;
				ista = pr.length && (/textarea/i).test(pr[0].nodeName);
				soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
				soffsetw = ista ? 0 : that.sizeDiff.width;
	
				s = {
					width: (that.helper.width()  - soffsetw),
					height: (that.helper.height() - soffseth)
				};
				left = (parseInt(that.element.css("left"), 10) +
					(that.position.left - that.originalPosition.left)) || null;
				top = (parseInt(that.element.css("top"), 10) +
					(that.position.top - that.originalPosition.top)) || null;
	
				if (!o.animate) {
					this.element.css($.extend(s, { top: top, left: left }));
				}
	
				that.helper.height(that.size.height);
				that.helper.width(that.size.width);
	
				if (this._helper && !o.animate) {
					this._proportionallyResize();
				}
			}
	
			$("body").css("cursor", "auto");
	
			this.element.removeClass("ui-resizable-resizing");
	
			this._propagate("stop", event);
	
			if (this._helper) {
				this.helper.remove();
			}
	
			return false;
	
		},
	
		_updatePrevProperties: function() {
			this.prevPosition = {
				top: this.position.top,
				left: this.position.left
			};
			this.prevSize = {
				width: this.size.width,
				height: this.size.height
			};
		},
	
		_applyChanges: function() {
			var props = {};
	
			if ( this.position.top !== this.prevPosition.top ) {
				props.top = this.position.top + "px";
			}
			if ( this.position.left !== this.prevPosition.left ) {
				props.left = this.position.left + "px";
			}
			if ( this.size.width !== this.prevSize.width ) {
				props.width = this.size.width + "px";
			}
			if ( this.size.height !== this.prevSize.height ) {
				props.height = this.size.height + "px";
			}
	
			this.helper.css( props );
	
			return props;
		},
	
		_updateVirtualBoundaries: function(forceAspectRatio) {
			var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
				o = this.options;
	
			b = {
				minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
				maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
				minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
				maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
			};
	
			if (this._aspectRatio || forceAspectRatio) {
				pMinWidth = b.minHeight * this.aspectRatio;
				pMinHeight = b.minWidth / this.aspectRatio;
				pMaxWidth = b.maxHeight * this.aspectRatio;
				pMaxHeight = b.maxWidth / this.aspectRatio;
	
				if (pMinWidth > b.minWidth) {
					b.minWidth = pMinWidth;
				}
				if (pMinHeight > b.minHeight) {
					b.minHeight = pMinHeight;
				}
				if (pMaxWidth < b.maxWidth) {
					b.maxWidth = pMaxWidth;
				}
				if (pMaxHeight < b.maxHeight) {
					b.maxHeight = pMaxHeight;
				}
			}
			this._vBoundaries = b;
		},
	
		_updateCache: function(data) {
			this.offset = this.helper.offset();
			if (this._isNumber(data.left)) {
				this.position.left = data.left;
			}
			if (this._isNumber(data.top)) {
				this.position.top = data.top;
			}
			if (this._isNumber(data.height)) {
				this.size.height = data.height;
			}
			if (this._isNumber(data.width)) {
				this.size.width = data.width;
			}
		},
	
		_updateRatio: function( data ) {
	
			var cpos = this.position,
				csize = this.size,
				a = this.axis;
	
			if (this._isNumber(data.height)) {
				data.width = (data.height * this.aspectRatio);
			} else if (this._isNumber(data.width)) {
				data.height = (data.width / this.aspectRatio);
			}
	
			if (a === "sw") {
				data.left = cpos.left + (csize.width - data.width);
				data.top = null;
			}
			if (a === "nw") {
				data.top = cpos.top + (csize.height - data.height);
				data.left = cpos.left + (csize.width - data.width);
			}
	
			return data;
		},
	
		_respectSize: function( data ) {
	
			var o = this._vBoundaries,
				a = this.axis,
				ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
				ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
				isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
				isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
				dw = this.originalPosition.left + this.originalSize.width,
				dh = this.position.top + this.size.height,
				cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
			if (isminw) {
				data.width = o.minWidth;
			}
			if (isminh) {
				data.height = o.minHeight;
			}
			if (ismaxw) {
				data.width = o.maxWidth;
			}
			if (ismaxh) {
				data.height = o.maxHeight;
			}
	
			if (isminw && cw) {
				data.left = dw - o.minWidth;
			}
			if (ismaxw && cw) {
				data.left = dw - o.maxWidth;
			}
			if (isminh && ch) {
				data.top = dh - o.minHeight;
			}
			if (ismaxh && ch) {
				data.top = dh - o.maxHeight;
			}
	
			// Fixing jump error on top/left - bug #2330
			if (!data.width && !data.height && !data.left && data.top) {
				data.top = null;
			} else if (!data.width && !data.height && !data.top && data.left) {
				data.left = null;
			}
	
			return data;
		},
	
		_getPaddingPlusBorderDimensions: function( element ) {
			var i = 0,
				widths = [],
				borders = [
					element.css( "borderTopWidth" ),
					element.css( "borderRightWidth" ),
					element.css( "borderBottomWidth" ),
					element.css( "borderLeftWidth" )
				],
				paddings = [
					element.css( "paddingTop" ),
					element.css( "paddingRight" ),
					element.css( "paddingBottom" ),
					element.css( "paddingLeft" )
				];
	
			for ( ; i < 4; i++ ) {
				widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
				widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
			}
	
			return {
				height: widths[ 0 ] + widths[ 2 ],
				width: widths[ 1 ] + widths[ 3 ]
			};
		},
	
		_proportionallyResize: function() {
	
			if (!this._proportionallyResizeElements.length) {
				return;
			}
	
			var prel,
				i = 0,
				element = this.helper || this.element;
	
			for ( ; i < this._proportionallyResizeElements.length; i++) {
	
				prel = this._proportionallyResizeElements[i];
	
				// TODO: Seems like a bug to cache this.outerDimensions
				// considering that we are in a loop.
				if (!this.outerDimensions) {
					this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
				}
	
				prel.css({
					height: (element.height() - this.outerDimensions.height) || 0,
					width: (element.width() - this.outerDimensions.width) || 0
				});
	
			}
	
		},
	
		_renderProxy: function() {
	
			var el = this.element, o = this.options;
			this.elementOffset = el.offset();
	
			if (this._helper) {
	
				this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
	
				this.helper.addClass(this._helper).css({
					width: this.element.outerWidth() - 1,
					height: this.element.outerHeight() - 1,
					position: "absolute",
					left: this.elementOffset.left + "px",
					top: this.elementOffset.top + "px",
					zIndex: ++o.zIndex //TODO: Don't modify option
				});
	
				this.helper
					.appendTo("body")
					.disableSelection();
	
			} else {
				this.helper = this.element;
			}
	
		},
	
		_change: {
			e: function(event, dx) {
				return { width: this.originalSize.width + dx };
			},
			w: function(event, dx) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { left: sp.left + dx, width: cs.width - dx };
			},
			n: function(event, dx, dy) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { top: sp.top + dy, height: cs.height - dy };
			},
			s: function(event, dx, dy) {
				return { height: this.originalSize.height + dy };
			},
			se: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments),
					this._change.e.apply(this, [ event, dx, dy ]));
			},
			sw: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments),
					this._change.w.apply(this, [ event, dx, dy ]));
			},
			ne: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments),
					this._change.e.apply(this, [ event, dx, dy ]));
			},
			nw: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments),
					this._change.w.apply(this, [ event, dx, dy ]));
			}
		},
	
		_propagate: function(n, event) {
			$.ui.plugin.call(this, n, [ event, this.ui() ]);
			(n !== "resize" && this._trigger(n, event, this.ui()));
		},
	
		plugins: {},
	
		ui: function() {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			};
		}
	
	});
	
	/*
	 * Resizable Extensions
	 */
	
	$.ui.plugin.add("resizable", "animate", {
	
		stop: function( event ) {
			var that = $(this).resizable( "instance" ),
				o = that.options,
				pr = that._proportionallyResizeElements,
				ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width,
				style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
				left = (parseInt(that.element.css("left"), 10) +
					(that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css("top"), 10) +
					(that.position.top - that.originalPosition.top)) || null;
	
			that.element.animate(
				$.extend(style, top && left ? { top: top, left: left } : {}), {
					duration: o.animateDuration,
					easing: o.animateEasing,
					step: function() {
	
						var data = {
							width: parseInt(that.element.css("width"), 10),
							height: parseInt(that.element.css("height"), 10),
							top: parseInt(that.element.css("top"), 10),
							left: parseInt(that.element.css("left"), 10)
						};
	
						if (pr && pr.length) {
							$(pr[0]).css({ width: data.width, height: data.height });
						}
	
						// propagating resize, and updating values for each animation step
						that._updateCache(data);
						that._propagate("resize", event);
	
					}
				}
			);
		}
	
	});
	
	$.ui.plugin.add( "resizable", "containment", {
	
		start: function() {
			var element, p, co, ch, cw, width, height,
				that = $( this ).resizable( "instance" ),
				o = that.options,
				el = that.element,
				oc = o.containment,
				ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;
	
			if ( !ce ) {
				return;
			}
	
			that.containerElement = $( ce );
	
			if ( /document/.test( oc ) || oc === document ) {
				that.containerOffset = {
					left: 0,
					top: 0
				};
				that.containerPosition = {
					left: 0,
					top: 0
				};
	
				that.parentData = {
					element: $( document ),
					left: 0,
					top: 0,
					width: $( document ).width(),
					height: $( document ).height() || document.body.parentNode.scrollHeight
				};
			} else {
				element = $( ce );
				p = [];
				$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
					p[ i ] = that._num( element.css( "padding" + name ) );
				});
	
				that.containerOffset = element.offset();
				that.containerPosition = element.position();
				that.containerSize = {
					height: ( element.innerHeight() - p[ 3 ] ),
					width: ( element.innerWidth() - p[ 1 ] )
				};
	
				co = that.containerOffset;
				ch = that.containerSize.height;
				cw = that.containerSize.width;
				width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
				height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;
	
				that.parentData = {
					element: ce,
					left: co.left,
					top: co.top,
					width: width,
					height: height
				};
			}
		},
	
		resize: function( event ) {
			var woset, hoset, isParent, isOffsetRelative,
				that = $( this ).resizable( "instance" ),
				o = that.options,
				co = that.containerOffset,
				cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey,
				cop = {
					top: 0,
					left: 0
				},
				ce = that.containerElement,
				continueResize = true;
	
			if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
				cop = co;
			}
	
			if ( cp.left < ( that._helper ? co.left : 0 ) ) {
				that.size.width = that.size.width +
					( that._helper ?
						( that.position.left - co.left ) :
						( that.position.left - cop.left ) );
	
				if ( pRatio ) {
					that.size.height = that.size.width / that.aspectRatio;
					continueResize = false;
				}
				that.position.left = o.helper ? co.left : 0;
			}
	
			if ( cp.top < ( that._helper ? co.top : 0 ) ) {
				that.size.height = that.size.height +
					( that._helper ?
						( that.position.top - co.top ) :
						that.position.top );
	
				if ( pRatio ) {
					that.size.width = that.size.height * that.aspectRatio;
					continueResize = false;
				}
				that.position.top = that._helper ? co.top : 0;
			}
	
			isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
			isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );
	
			if ( isParent && isOffsetRelative ) {
				that.offset.left = that.parentData.left + that.position.left;
				that.offset.top = that.parentData.top + that.position.top;
			} else {
				that.offset.left = that.element.offset().left;
				that.offset.top = that.element.offset().top;
			}
	
			woset = Math.abs( that.sizeDiff.width +
				(that._helper ?
					that.offset.left - cop.left :
					(that.offset.left - co.left)) );
	
			hoset = Math.abs( that.sizeDiff.height +
				(that._helper ?
					that.offset.top - cop.top :
					(that.offset.top - co.top)) );
	
			if ( woset + that.size.width >= that.parentData.width ) {
				that.size.width = that.parentData.width - woset;
				if ( pRatio ) {
					that.size.height = that.size.width / that.aspectRatio;
					continueResize = false;
				}
			}
	
			if ( hoset + that.size.height >= that.parentData.height ) {
				that.size.height = that.parentData.height - hoset;
				if ( pRatio ) {
					that.size.width = that.size.height * that.aspectRatio;
					continueResize = false;
				}
			}
	
			if ( !continueResize ) {
				that.position.left = that.prevPosition.left;
				that.position.top = that.prevPosition.top;
				that.size.width = that.prevSize.width;
				that.size.height = that.prevSize.height;
			}
		},
	
		stop: function() {
			var that = $( this ).resizable( "instance" ),
				o = that.options,
				co = that.containerOffset,
				cop = that.containerPosition,
				ce = that.containerElement,
				helper = $( that.helper ),
				ho = helper.offset(),
				w = helper.outerWidth() - that.sizeDiff.width,
				h = helper.outerHeight() - that.sizeDiff.height;
	
			if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
				$( this ).css({
					left: ho.left - cop.left - co.left,
					width: w,
					height: h
				});
			}
	
			if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
				$( this ).css({
					left: ho.left - cop.left - co.left,
					width: w,
					height: h
				});
			}
		}
	});
	
	$.ui.plugin.add("resizable", "alsoResize", {
	
		start: function() {
			var that = $(this).resizable( "instance" ),
				o = that.options;
	
			$(o.alsoResize).each(function() {
				var el = $(this);
				el.data("ui-resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
				});
			});
		},
	
		resize: function(event, ui) {
			var that = $(this).resizable( "instance" ),
				o = that.options,
				os = that.originalSize,
				op = that.originalPosition,
				delta = {
					height: (that.size.height - os.height) || 0,
					width: (that.size.width - os.width) || 0,
					top: (that.position.top - op.top) || 0,
					left: (that.position.left - op.left) || 0
				};
	
				$(o.alsoResize).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = el.parents(ui.originalElement[0]).length ?
								[ "width", "height" ] :
								[ "width", "height", "top", "left" ];
	
					$.each(css, function(i, prop) {
						var sum = (start[prop] || 0) + (delta[prop] || 0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});
	
					el.css(style);
				});
		},
	
		stop: function() {
			$(this).removeData("resizable-alsoresize");
		}
	});
	
	$.ui.plugin.add("resizable", "ghost", {
	
		start: function() {
	
			var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;
	
			that.ghost = that.originalElement.clone();
			that.ghost
				.css({
					opacity: 0.25,
					display: "block",
					position: "relative",
					height: cs.height,
					width: cs.width,
					margin: 0,
					left: 0,
					top: 0
				})
				.addClass("ui-resizable-ghost")
				.addClass(typeof o.ghost === "string" ? o.ghost : "");
	
			that.ghost.appendTo(that.helper);
	
		},
	
		resize: function() {
			var that = $(this).resizable( "instance" );
			if (that.ghost) {
				that.ghost.css({
					position: "relative",
					height: that.size.height,
					width: that.size.width
				});
			}
		},
	
		stop: function() {
			var that = $(this).resizable( "instance" );
			if (that.ghost && that.helper) {
				that.helper.get(0).removeChild(that.ghost.get(0));
			}
		}
	
	});
	
	$.ui.plugin.add("resizable", "grid", {
	
		resize: function() {
			var outerDimensions,
				that = $(this).resizable( "instance" ),
				o = that.options,
				cs = that.size,
				os = that.originalSize,
				op = that.originalPosition,
				a = that.axis,
				grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
				gridX = (grid[0] || 1),
				gridY = (grid[1] || 1),
				ox = Math.round((cs.width - os.width) / gridX) * gridX,
				oy = Math.round((cs.height - os.height) / gridY) * gridY,
				newWidth = os.width + ox,
				newHeight = os.height + oy,
				isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
				isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
				isMinWidth = o.minWidth && (o.minWidth > newWidth),
				isMinHeight = o.minHeight && (o.minHeight > newHeight);
	
			o.grid = grid;
	
			if (isMinWidth) {
				newWidth += gridX;
			}
			if (isMinHeight) {
				newHeight += gridY;
			}
			if (isMaxWidth) {
				newWidth -= gridX;
			}
			if (isMaxHeight) {
				newHeight -= gridY;
			}
	
			if (/^(se|s|e)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
			} else if (/^(ne)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else if (/^(sw)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.left = op.left - ox;
			} else {
				if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
					outerDimensions = that._getPaddingPlusBorderDimensions( this );
				}
	
				if ( newHeight - gridY > 0 ) {
					that.size.height = newHeight;
					that.position.top = op.top - oy;
				} else {
					newHeight = gridY - outerDimensions.height;
					that.size.height = newHeight;
					that.position.top = op.top + os.height - newHeight;
				}
				if ( newWidth - gridX > 0 ) {
					that.size.width = newWidth;
					that.position.left = op.left - ox;
				} else {
					newWidth = gridX - outerDimensions.width;
					that.size.width = newWidth;
					that.position.left = op.left + os.width - newWidth;
				}
			}
		}
	
	});
	
	var resizable = $.ui.resizable;
	
	
	/*!
	 * jQuery UI Selectable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/selectable/
	 */
	
	
	var selectable = $.widget("ui.selectable", $.ui.mouse, {
		version: "1.11.4",
		options: {
			appendTo: "body",
			autoRefresh: true,
			distance: 0,
			filter: "*",
			tolerance: "touch",
	
			// callbacks
			selected: null,
			selecting: null,
			start: null,
			stop: null,
			unselected: null,
			unselecting: null
		},
		_create: function() {
			var selectees,
				that = this;
	
			this.element.addClass("ui-selectable");
	
			this.dragged = false;
	
			// cache selectee children based on filter
			this.refresh = function() {
				selectees = $(that.options.filter, that.element[0]);
				selectees.addClass("ui-selectee");
				selectees.each(function() {
					var $this = $(this),
						pos = $this.offset();
					$.data(this, "selectable-item", {
						element: this,
						$element: $this,
						left: pos.left,
						top: pos.top,
						right: pos.left + $this.outerWidth(),
						bottom: pos.top + $this.outerHeight(),
						startselected: false,
						selected: $this.hasClass("ui-selected"),
						selecting: $this.hasClass("ui-selecting"),
						unselecting: $this.hasClass("ui-unselecting")
					});
				});
			};
			this.refresh();
	
			this.selectees = selectees.addClass("ui-selectee");
	
			this._mouseInit();
	
			this.helper = $("<div class='ui-selectable-helper'></div>");
		},
	
		_destroy: function() {
			this.selectees
				.removeClass("ui-selectee")
				.removeData("selectable-item");
			this.element
				.removeClass("ui-selectable ui-selectable-disabled");
			this._mouseDestroy();
		},
	
		_mouseStart: function(event) {
			var that = this,
				options = this.options;
	
			this.opos = [ event.pageX, event.pageY ];
	
			if (this.options.disabled) {
				return;
			}
	
			this.selectees = $(options.filter, this.element[0]);
	
			this._trigger("start", event);
	
			$(options.appendTo).append(this.helper);
			// position helper (lasso)
			this.helper.css({
				"left": event.pageX,
				"top": event.pageY,
				"width": 0,
				"height": 0
			});
	
			if (options.autoRefresh) {
				this.refresh();
			}
	
			this.selectees.filter(".ui-selected").each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.startselected = true;
				if (!event.metaKey && !event.ctrlKey) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
					selectee.$element.addClass("ui-unselecting");
					selectee.unselecting = true;
					// selectable UNSELECTING callback
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
			});
	
			$(event.target).parents().addBack().each(function() {
				var doSelect,
					selectee = $.data(this, "selectable-item");
				if (selectee) {
					doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
					selectee.$element
						.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
						.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
					selectee.unselecting = !doSelect;
					selectee.selecting = doSelect;
					selectee.selected = doSelect;
					// selectable (UN)SELECTING callback
					if (doSelect) {
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					} else {
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
					return false;
				}
			});
	
		},
	
		_mouseDrag: function(event) {
	
			this.dragged = true;
	
			if (this.options.disabled) {
				return;
			}
	
			var tmp,
				that = this,
				options = this.options,
				x1 = this.opos[0],
				y1 = this.opos[1],
				x2 = event.pageX,
				y2 = event.pageY;
	
			if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
			if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
			this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });
	
			this.selectees.each(function() {
				var selectee = $.data(this, "selectable-item"),
					hit = false;
	
				//prevent helper from being selected if appendTo: selectable
				if (!selectee || selectee.element === that.element[0]) {
					return;
				}
	
				if (options.tolerance === "touch") {
					hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
				} else if (options.tolerance === "fit") {
					hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
				}
	
				if (hit) {
					// SELECT
					if (selectee.selected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;
					}
					if (selectee.unselecting) {
						selectee.$element.removeClass("ui-unselecting");
						selectee.unselecting = false;
					}
					if (!selectee.selecting) {
						selectee.$element.addClass("ui-selecting");
						selectee.selecting = true;
						// selectable SELECTING callback
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					}
				} else {
					// UNSELECT
					if (selectee.selecting) {
						if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							selectee.$element.addClass("ui-selected");
							selectee.selected = true;
						} else {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							if (selectee.startselected) {
								selectee.$element.addClass("ui-unselecting");
								selectee.unselecting = true;
							}
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
					if (selectee.selected) {
						if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
							selectee.$element.removeClass("ui-selected");
							selectee.selected = false;
	
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
				}
			});
	
			return false;
		},
	
		_mouseStop: function(event) {
			var that = this;
	
			this.dragged = false;
	
			$(".ui-unselecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-unselecting");
				selectee.unselecting = false;
				selectee.startselected = false;
				that._trigger("unselected", event, {
					unselected: selectee.element
				});
			});
			$(".ui-selecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
				selectee.selecting = false;
				selectee.selected = true;
				selectee.startselected = true;
				that._trigger("selected", event, {
					selected: selectee.element
				});
			});
			this._trigger("stop", event);
	
			this.helper.remove();
	
			return false;
		}
	
	});
	
	
	/*!
	 * jQuery UI Sortable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/sortable/
	 */
	
	
	var sortable = $.widget("ui.sortable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "sort",
		ready: false,
		options: {
			appendTo: "parent",
			axis: false,
			connectWith: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			dropOnEmpty: true,
			forcePlaceholderSize: false,
			forceHelperSize: false,
			grid: false,
			handle: false,
			helper: "original",
			items: "> *",
			opacity: false,
			placeholder: false,
			revert: false,
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1000,
	
			// callbacks
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},
	
		_isOverAxis: function( x, reference, size ) {
			return ( x >= reference ) && ( x < ( reference + size ) );
		},
	
		_isFloating: function( item ) {
			return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
		},
	
		_create: function() {
			this.containerCache = {};
			this.element.addClass("ui-sortable");
	
			//Get the items
			this.refresh();
	
			//Let's determine the parent's offset
			this.offset = this.element.offset();
	
			//Initialize mouse events for interaction
			this._mouseInit();
	
			this._setHandleClassName();
	
			//We're ready to go
			this.ready = true;
	
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
	
			if ( key === "handle" ) {
				this._setHandleClassName();
			}
		},
	
		_setHandleClassName: function() {
			this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
			$.each( this.items, function() {
				( this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) : this.item )
					.addClass( "ui-sortable-handle" );
			});
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-sortable ui-sortable-disabled" )
				.find( ".ui-sortable-handle" )
					.removeClass( "ui-sortable-handle" );
			this._mouseDestroy();
	
			for ( var i = this.items.length - 1; i >= 0; i-- ) {
				this.items[i].item.removeData(this.widgetName + "-item");
			}
	
			return this;
		},
	
		_mouseCapture: function(event, overrideHandle) {
			var currentItem = null,
				validHandle = false,
				that = this;
	
			if (this.reverting) {
				return false;
			}
	
			if(this.options.disabled || this.options.type === "static") {
				return false;
			}
	
			//We have to refresh the items data once first
			this._refreshItems(event);
	
			//Find out if the clicked node (or one of its parents) is a actual item in this.items
			$(event.target).parents().each(function() {
				if($.data(this, that.widgetName + "-item") === that) {
					currentItem = $(this);
					return false;
				}
			});
			if($.data(event.target, that.widgetName + "-item") === that) {
				currentItem = $(event.target);
			}
	
			if(!currentItem) {
				return false;
			}
			if(this.options.handle && !overrideHandle) {
				$(this.options.handle, currentItem).find("*").addBack().each(function() {
					if(this === event.target) {
						validHandle = true;
					}
				});
				if(!validHandle) {
					return false;
				}
			}
	
			this.currentItem = currentItem;
			this._removeCurrentsFromItems();
			return true;
	
		},
	
		_mouseStart: function(event, overrideHandle, noActivation) {
	
			var i, body,
				o = this.options;
	
			this.currentContainer = this;
	
			//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
			this.refreshPositions();
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Get the next scrolling parent
			this.scrollParent = this.helper.scrollParent();
	
			//The element's absolute position on the page minus margins
			this.offset = this.currentItem.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};
	
			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});
	
			// Only after we got the offset, we can change the helper's position to absolute
			// TODO: Still need to figure out a way to make relative sorting possible
			this.helper.css("position", "absolute");
			this.cssPosition = this.helper.css("position");
	
			//Generate the original position
			this.originalPosition = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Cache the former DOM position
			this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
	
			//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
			if(this.helper[0] !== this.currentItem[0]) {
				this.currentItem.hide();
			}
	
			//Create the placeholder
			this._createPlaceholder();
	
			//Set a containment if given in the options
			if(o.containment) {
				this._setContainment();
			}
	
			if( o.cursor && o.cursor !== "auto" ) { // cursor option
				body = this.document.find( "body" );
	
				// support: IE
				this.storedCursor = body.css( "cursor" );
				body.css( "cursor", o.cursor );
	
				this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
			}
	
			if(o.opacity) { // opacity option
				if (this.helper.css("opacity")) {
					this._storedOpacity = this.helper.css("opacity");
				}
				this.helper.css("opacity", o.opacity);
			}
	
			if(o.zIndex) { // zIndex option
				if (this.helper.css("zIndex")) {
					this._storedZIndex = this.helper.css("zIndex");
				}
				this.helper.css("zIndex", o.zIndex);
			}
	
			//Prepare scrolling
			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
				this.overflowOffset = this.scrollParent.offset();
			}
	
			//Call callbacks
			this._trigger("start", event, this._uiHash());
	
			//Recache the helper size
			if(!this._preserveHelperProportions) {
				this._cacheHelperProportions();
			}
	
	
			//Post "activate" events to possible containers
			if( !noActivation ) {
				for ( i = this.containers.length - 1; i >= 0; i-- ) {
					this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
				}
			}
	
			//Prepare possible droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
			this.dragging = true;
	
			this.helper.addClass("ui-sortable-helper");
			this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
			return true;
	
		},
	
		_mouseDrag: function(event) {
			var i, item, itemElement, intersection,
				o = this.options,
				scrolled = false;
	
			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");
	
			if (!this.lastPositionAbs) {
				this.lastPositionAbs = this.positionAbs;
			}
	
			//Do scrolling
			if(this.options.scroll) {
				if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
	
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					}
	
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
	
				} else {
	
					if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
					} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
					}
	
					if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
					} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
					}
	
				}
	
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
			}
	
			//Regenerate the absolute position used for position checks
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Set the helper position
			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}
	
			//Rearrange
			for (i = this.items.length - 1; i >= 0; i--) {
	
				//Cache variables and intersection, continue if no intersection
				item = this.items[i];
				itemElement = item.item[0];
				intersection = this._intersectsWithPointer(item);
				if (!intersection) {
					continue;
				}
	
				// Only put the placeholder inside the current Container, skip all
				// items from other containers. This works because when moving
				// an item from one container to another the
				// currentContainer is switched before the placeholder is moved.
				//
				// Without this, moving items in "sub-sortables" can cause
				// the placeholder to jitter between the outer and inner container.
				if (item.instance !== this.currentContainer) {
					continue;
				}
	
				// cannot intersect with itself
				// no useless actions that have been done before
				// no action if the item moved is the parent of the item checked
				if (itemElement !== this.currentItem[0] &&
					this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
					!$.contains(this.placeholder[0], itemElement) &&
					(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
				) {
	
					this.direction = intersection === 1 ? "down" : "up";
	
					if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
						this._rearrange(event, item);
					} else {
						break;
					}
	
					this._trigger("change", event, this._uiHash());
					break;
				}
			}
	
			//Post events to containers
			this._contactContainers(event);
	
			//Interconnect with droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			//Call callbacks
			this._trigger("sort", event, this._uiHash());
	
			this.lastPositionAbs = this.positionAbs;
			return false;
	
		},
	
		_mouseStop: function(event, noPropagation) {
	
			if(!event) {
				return;
			}
	
			//If we are using droppables, inform the manager about the drop
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				$.ui.ddmanager.drop(this, event);
			}
	
			if(this.options.revert) {
				var that = this,
					cur = this.placeholder.offset(),
					axis = this.options.axis,
					animation = {};
	
				if ( !axis || axis === "x" ) {
					animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
				}
				if ( !axis || axis === "y" ) {
					animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
				}
				this.reverting = true;
				$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
					that._clear(event);
				});
			} else {
				this._clear(event, noPropagation);
			}
	
			return false;
	
		},
	
		cancel: function() {
	
			if(this.dragging) {
	
				this._mouseUp({ target: null });
	
				if(this.options.helper === "original") {
					this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
				} else {
					this.currentItem.show();
				}
	
				//Post deactivating events to containers
				for (var i = this.containers.length - 1; i >= 0; i--){
					this.containers[i]._trigger("deactivate", null, this._uiHash(this));
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", null, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			if (this.placeholder) {
				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
				if(this.placeholder[0].parentNode) {
					this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
				}
				if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
					this.helper.remove();
				}
	
				$.extend(this, {
					helper: null,
					dragging: false,
					reverting: false,
					_noFinalSort: null
				});
	
				if(this.domPosition.prev) {
					$(this.domPosition.prev).after(this.currentItem);
				} else {
					$(this.domPosition.parent).prepend(this.currentItem);
				}
			}
	
			return this;
	
		},
	
		serialize: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				str = [];
			o = o || {};
	
			$(items).each(function() {
				var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
				if (res) {
					str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
				}
			});
	
			if(!str.length && o.key) {
				str.push(o.key + "=");
			}
	
			return str.join("&");
	
		},
	
		toArray: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				ret = [];
	
			o = o || {};
	
			items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
			return ret;
	
		},
	
		/* Be careful with the following core functions */
		_intersectsWith: function(item) {
	
			var x1 = this.positionAbs.left,
				x2 = x1 + this.helperProportions.width,
				y1 = this.positionAbs.top,
				y2 = y1 + this.helperProportions.height,
				l = item.left,
				r = l + item.width,
				t = item.top,
				b = t + item.height,
				dyClick = this.offset.click.top,
				dxClick = this.offset.click.left,
				isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
				isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
				isOverElement = isOverElementHeight && isOverElementWidth;
	
			if ( this.options.tolerance === "pointer" ||
				this.options.forcePointerForContainers ||
				(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
			) {
				return isOverElement;
			} else {
	
				return (l < x1 + (this.helperProportions.width / 2) && // Right Half
					x2 - (this.helperProportions.width / 2) < r && // Left Half
					t < y1 + (this.helperProportions.height / 2) && // Bottom Half
					y2 - (this.helperProportions.height / 2) < b ); // Top Half
	
			}
		},
	
		_intersectsWithPointer: function(item) {
	
			var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
				isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
				isOverElement = isOverElementHeight && isOverElementWidth,
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (!isOverElement) {
				return false;
			}
	
			return this.floating ?
				( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
				: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
	
		},
	
		_intersectsWithSides: function(item) {
	
			var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
				isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (this.floating && horizontalDirection) {
				return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
			} else {
				return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
			}
	
		},
	
		_getDragVerticalDirection: function() {
			var delta = this.positionAbs.top - this.lastPositionAbs.top;
			return delta !== 0 && (delta > 0 ? "down" : "up");
		},
	
		_getDragHorizontalDirection: function() {
			var delta = this.positionAbs.left - this.lastPositionAbs.left;
			return delta !== 0 && (delta > 0 ? "right" : "left");
		},
	
		refresh: function(event) {
			this._refreshItems(event);
			this._setHandleClassName();
			this.refreshPositions();
			return this;
		},
	
		_connectWith: function() {
			var options = this.options;
			return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
		},
	
		_getItemsAsjQuery: function(connected) {
	
			var i, j, cur, inst,
				items = [],
				queries = [],
				connectWith = this._connectWith();
	
			if(connectWith && connected) {
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i], this.document[0]);
					for ( j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
						}
					}
				}
			}
	
			queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
	
			function addItems() {
				items.push( this );
			}
			for (i = queries.length - 1; i >= 0; i--){
				queries[i][0].each( addItems );
			}
	
			return $(items);
	
		},
	
		_removeCurrentsFromItems: function() {
	
			var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
	
			this.items = $.grep(this.items, function (item) {
				for (var j=0; j < list.length; j++) {
					if(list[j] === item.item[0]) {
						return false;
					}
				}
				return true;
			});
	
		},
	
		_refreshItems: function(event) {
	
			this.items = [];
			this.containers = [this];
	
			var i, j, cur, inst, targetData, _queries, item, queriesLength,
				items = this.items,
				queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
				connectWith = this._connectWith();
	
			if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i], this.document[0]);
					for (j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
							this.containers.push(inst);
						}
					}
				}
			}
	
			for (i = queries.length - 1; i >= 0; i--) {
				targetData = queries[i][1];
				_queries = queries[i][0];
	
				for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
					item = $(_queries[j]);
	
					item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
	
					items.push({
						item: item,
						instance: targetData,
						width: 0, height: 0,
						left: 0, top: 0
					});
				}
			}
	
		},
	
		refreshPositions: function(fast) {
	
			// Determine whether items are being displayed horizontally
			this.floating = this.items.length ?
				this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
				false;
	
			//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
			if(this.offsetParent && this.helper) {
				this.offset.parent = this._getParentOffset();
			}
	
			var i, item, t, p;
	
			for (i = this.items.length - 1; i >= 0; i--){
				item = this.items[i];
	
				//We ignore calculating positions of all connected containers when we're not over them
				if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
					continue;
				}
	
				t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
	
				if (!fast) {
					item.width = t.outerWidth();
					item.height = t.outerHeight();
				}
	
				p = t.offset();
				item.left = p.left;
				item.top = p.top;
			}
	
			if(this.options.custom && this.options.custom.refreshContainers) {
				this.options.custom.refreshContainers.call(this);
			} else {
				for (i = this.containers.length - 1; i >= 0; i--){
					p = this.containers[i].element.offset();
					this.containers[i].containerCache.left = p.left;
					this.containers[i].containerCache.top = p.top;
					this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
					this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
				}
			}
	
			return this;
		},
	
		_createPlaceholder: function(that) {
			that = that || this;
			var className,
				o = that.options;
	
			if(!o.placeholder || o.placeholder.constructor === String) {
				className = o.placeholder;
				o.placeholder = {
					element: function() {
	
						var nodeName = that.currentItem[0].nodeName.toLowerCase(),
							element = $( "<" + nodeName + ">", that.document[0] )
								.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
								.removeClass("ui-sortable-helper");
	
						if ( nodeName === "tbody" ) {
							that._createTrPlaceholder(
								that.currentItem.find( "tr" ).eq( 0 ),
								$( "<tr>", that.document[ 0 ] ).appendTo( element )
							);
						} else if ( nodeName === "tr" ) {
							that._createTrPlaceholder( that.currentItem, element );
						} else if ( nodeName === "img" ) {
							element.attr( "src", that.currentItem.attr( "src" ) );
						}
	
						if ( !className ) {
							element.css( "visibility", "hidden" );
						}
	
						return element;
					},
					update: function(container, p) {
	
						// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
						// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
						if(className && !o.forcePlaceholderSize) {
							return;
						}
	
						//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
						if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
						if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
					}
				};
			}
	
			//Create the placeholder
			that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
	
			//Append it after the actual current item
			that.currentItem.after(that.placeholder);
	
			//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
			o.placeholder.update(that, that.placeholder);
	
		},
	
		_createTrPlaceholder: function( sourceTr, targetTr ) {
			var that = this;
	
			sourceTr.children().each(function() {
				$( "<td>&#160;</td>", that.document[ 0 ] )
					.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
					.appendTo( targetTr );
			});
		},
	
		_contactContainers: function(event) {
			var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
				innermostContainer = null,
				innermostIndex = null;
	
			// get innermost container that intersects with item
			for (i = this.containers.length - 1; i >= 0; i--) {
	
				// never consider a container that's located within the item itself
				if($.contains(this.currentItem[0], this.containers[i].element[0])) {
					continue;
				}
	
				if(this._intersectsWith(this.containers[i].containerCache)) {
	
					// if we've already found a container and it's more "inner" than this, then continue
					if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
						continue;
					}
	
					innermostContainer = this.containers[i];
					innermostIndex = i;
	
				} else {
					// container doesn't intersect. trigger "out" event if necessary
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", event, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			// if no intersecting containers found, return
			if(!innermostContainer) {
				return;
			}
	
			// move the item into the container if it's not there already
			if(this.containers.length === 1) {
				if (!this.containers[innermostIndex].containerCache.over) {
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			} else {
	
				//When entering a new container, we will find the item with the least distance and append our item near it
				dist = 10000;
				itemWithLeastDistance = null;
				floating = innermostContainer.floating || this._isFloating(this.currentItem);
				posProperty = floating ? "left" : "top";
				sizeProperty = floating ? "width" : "height";
				axis = floating ? "clientX" : "clientY";
	
				for (j = this.items.length - 1; j >= 0; j--) {
					if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
						continue;
					}
					if(this.items[j].item[0] === this.currentItem[0]) {
						continue;
					}
	
					cur = this.items[j].item.offset()[posProperty];
					nearBottom = false;
					if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
						nearBottom = true;
					}
	
					if ( Math.abs( event[ axis ] - cur ) < dist ) {
						dist = Math.abs( event[ axis ] - cur );
						itemWithLeastDistance = this.items[ j ];
						this.direction = nearBottom ? "up": "down";
					}
				}
	
				//Check if dropOnEmpty is enabled
				if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
					return;
				}
	
				if(this.currentContainer === this.containers[innermostIndex]) {
					if ( !this.currentContainer.containerCache.over ) {
						this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
						this.currentContainer.containerCache.over = 1;
					}
					return;
				}
	
				itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
				this._trigger("change", event, this._uiHash());
				this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
				this.currentContainer = this.containers[innermostIndex];
	
				//Update the placeholder
				this.options.placeholder.update(this.currentContainer, this.placeholder);
	
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
	
	
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
	
			//Add the helper to the DOM if that didn't happen already
			if(!helper.parents("body").length) {
				$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
			}
	
			if(helper[0] === this.currentItem[0]) {
				this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
			}
	
			if(!helper[0].style.width || o.forceHelperSize) {
				helper.width(this.currentItem.width());
			}
			if(!helper[0].style.height || o.forceHelperSize) {
				helper.height(this.currentItem.height());
			}
	
			return helper;
	
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_getParentOffset: function() {
	
	
			//Get the offsetParent and cache its position
			this.offsetParent = this.helper.offsetParent();
			var po = this.offsetParent.offset();
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			// This needs to be actually done for all browsers, since pageX/pageY includes this information
			// with an ugly IE fix
			if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
	
			if(this.cssPosition === "relative") {
				var p = this.currentItem.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
				top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var ce, co, over,
				o = this.options;
			if(o.containment === "parent") {
				o.containment = this.helper[0].parentNode;
			}
			if(o.containment === "document" || o.containment === "window") {
				this.containment = [
					0 - this.offset.relative.left - this.offset.parent.left,
					0 - this.offset.relative.top - this.offset.parent.top,
					o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
					(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
				];
			}
	
			if(!(/^(document|window|parent)$/).test(o.containment)) {
				ce = $(o.containment)[0];
				co = $(o.containment).offset();
				over = ($(ce).css("overflow") !== "hidden");
	
				this.containment = [
					co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
					co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
					co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
					co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
				];
			}
	
		},
	
		_convertPositionTo: function(d, pos) {
	
			if(!pos) {
				pos = this.position;
			}
			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
				)
			};
	
		},
	
		_generatePosition: function(event) {
	
			var top, left,
				o = this.options,
				pageX = event.pageX,
				pageY = event.pageY,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			// This is another very weird special case that only happens for relative elements:
			// 1. If the css position is relative
			// 2. and the scroll parent is the document or similar to the offset parent
			// we have to refresh the relative offset during the scroll so there are no jumps
			if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
				this.offset.relative = this._getRelativeOffset();
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			if(this.originalPosition) { //If we are not dragging yet, we won't check for options
	
				if(this.containment) {
					if(event.pageX - this.offset.click.left < this.containment[0]) {
						pageX = this.containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < this.containment[1]) {
						pageY = this.containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > this.containment[2]) {
						pageX = this.containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > this.containment[3]) {
						pageY = this.containment[3] + this.offset.click.top;
					}
				}
	
				if(o.grid) {
					top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
					pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
					pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
			}
	
			return {
				top: (
					pageY -																// The absolute mouse position
					this.offset.click.top -													// Click offset (relative to the element)
					this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
				),
				left: (
					pageX -																// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
				)
			};
	
		},
	
		_rearrange: function(event, i, a, hardRefresh) {
	
			a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
	
			//Various things done here to improve the performance:
			// 1. we create a setTimeout, that calls refreshPositions
			// 2. on the instance, we have a counter variable, that get's higher after every append
			// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
			// 4. this lets only the last addition to the timeout stack through
			this.counter = this.counter ? ++this.counter : 1;
			var counter = this.counter;
	
			this._delay(function() {
				if(counter === this.counter) {
					this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
				}
			});
	
		},
	
		_clear: function(event, noPropagation) {
	
			this.reverting = false;
			// We delay all events that have to be triggered to after the point where the placeholder has been removed and
			// everything else normalized again
			var i,
				delayedTriggers = [];
	
			// We first have to update the dom position of the actual currentItem
			// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
			if(!this._noFinalSort && this.currentItem.parent().length) {
				this.placeholder.before(this.currentItem);
			}
			this._noFinalSort = null;
	
			if(this.helper[0] === this.currentItem[0]) {
				for(i in this._storedCSS) {
					if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
						this._storedCSS[i] = "";
					}
				}
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}
	
			if(this.fromOutside && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
			}
			if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
			}
	
			// Check if the items Container has Changed and trigger appropriate
			// events.
			if (this !== this.currentContainer) {
				if(!noPropagation) {
					delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
				}
			}
	
	
			//Post events to containers
			function delayEvent( type, instance, container ) {
				return function( event ) {
					container._trigger( type, event, instance._uiHash( instance ) );
				};
			}
			for (i = this.containers.length - 1; i >= 0; i--){
				if (!noPropagation) {
					delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
				}
				if(this.containers[i].containerCache.over) {
					delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
					this.containers[i].containerCache.over = 0;
				}
			}
	
			//Do what was originally in plugins
			if ( this.storedCursor ) {
				this.document.find( "body" ).css( "cursor", this.storedCursor );
				this.storedStylesheet.remove();
			}
			if(this._storedOpacity) {
				this.helper.css("opacity", this._storedOpacity);
			}
			if(this._storedZIndex) {
				this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
			}
	
			this.dragging = false;
	
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
			}
	
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
	
			if ( !this.cancelHelperRemoval ) {
				if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
					this.helper.remove();
				}
				this.helper = null;
			}
	
			if(!noPropagation) {
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
	
			this.fromOutside = false;
			return !this.cancelHelperRemoval;
	
		},
	
		_trigger: function() {
			if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
				this.cancel();
			}
		},
	
		_uiHash: function(_inst) {
			var inst = _inst || this;
			return {
				helper: inst.helper,
				placeholder: inst.placeholder || $([]),
				position: inst.position,
				originalPosition: inst.originalPosition,
				offset: inst.positionAbs,
				item: inst.currentItem,
				sender: _inst ? _inst.element : null
			};
		}
	
	});
	
	
	/*!
	 * jQuery UI Effects 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/effects-core/
	 */
	
	
	var dataSpace = "ui-effects-",
	
		// Create a local jQuery because jQuery Color relies on it and the
		// global may not exist with AMD and a custom build (#10199)
		jQuery = $;
	
	$.effects = {
		effect: {}
	};
	
	/*!
	 * jQuery Color Animations v2.1.2
	 * https://github.com/jquery/jquery-color
	 *
	 * Copyright 2014 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: Wed Jan 16 08:47:09 2013 -0600
	 */
	(function( jQuery, undefined ) {
	
		var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
	
		// plusequals test for += 100 -= 100
		rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
		// a set of RE's that can match strings and generate color tuples.
		stringParsers = [ {
				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ],
						execResult[ 3 ],
						execResult[ 4 ]
					];
				}
			}, {
				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ] * 2.55,
						execResult[ 2 ] * 2.55,
						execResult[ 3 ] * 2.55,
						execResult[ 4 ]
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ], 16 )
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
					];
				}
			}, {
				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				space: "hsla",
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ] / 100,
						execResult[ 3 ] / 100,
						execResult[ 4 ]
					];
				}
			} ],
	
		// jQuery.Color( )
		color = jQuery.Color = function( color, green, blue, alpha ) {
			return new jQuery.Color.fn.parse( color, green, blue, alpha );
		},
		spaces = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},
	
			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		propTypes = {
			"byte": {
				floor: true,
				max: 255
			},
			"percent": {
				max: 1
			},
			"degrees": {
				mod: 360,
				floor: true
			}
		},
		support = color.support = {},
	
		// element for support tests
		supportElem = jQuery( "<p>" )[ 0 ],
	
		// colors = jQuery.Color.names
		colors,
	
		// local aliases of functions called often
		each = jQuery.each;
	
	// determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
	
	// define cache name and alpha properties
	// for rgba and hsla spaces
	each( spaces, function( spaceName, space ) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	});
	
	function clamp( value, prop, allowEmpty ) {
		var type = propTypes[ prop.type ] || {};
	
		if ( value == null ) {
			return (allowEmpty || !prop.def) ? null : prop.def;
		}
	
		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat( value );
	
		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if ( isNaN( value ) ) {
			return prop.def;
		}
	
		if ( type.mod ) {
			// we add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return (value + type.mod) % type.mod;
		}
	
		// for now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}
	
	function stringParse( string ) {
		var inst = color(),
			rgba = inst._rgba = [];
	
		string = string.toLowerCase();
	
		each( stringParsers, function( i, parser ) {
			var parsed,
				match = parser.re.exec( string ),
				values = match && parser.parse( match ),
				spaceName = parser.space || "rgba";
	
			if ( values ) {
				parsed = inst[ spaceName ]( values );
	
				// if this was an rgba parse the assignment might happen twice
				// oh well....
				inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
				rgba = inst._rgba = parsed._rgba;
	
				// exit each( stringParsers ) here because we matched
				return false;
			}
		});
	
		// Found a stringParser that handled it
		if ( rgba.length ) {
	
			// if this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if ( rgba.join() === "0,0,0,0" ) {
				jQuery.extend( rgba, colors.transparent );
			}
			return inst;
		}
	
		// named colors
		return colors[ string ];
	}
	
	color.fn = jQuery.extend( color.prototype, {
		parse: function( red, green, blue, alpha ) {
			if ( red === undefined ) {
				this._rgba = [ null, null, null, null ];
				return this;
			}
			if ( red.jquery || red.nodeType ) {
				red = jQuery( red ).css( green );
				green = undefined;
			}
	
			var inst = this,
				type = jQuery.type( red ),
				rgba = this._rgba = [];
	
			// more than 1 argument specified - assume ( red, green, blue, alpha )
			if ( green !== undefined ) {
				red = [ red, green, blue, alpha ];
				type = "array";
			}
	
			if ( type === "string" ) {
				return this.parse( stringParse( red ) || colors._default );
			}
	
			if ( type === "array" ) {
				each( spaces.rgba.props, function( key, prop ) {
					rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
				});
				return this;
			}
	
			if ( type === "object" ) {
				if ( red instanceof color ) {
					each( spaces, function( spaceName, space ) {
						if ( red[ space.cache ] ) {
							inst[ space.cache ] = red[ space.cache ].slice();
						}
					});
				} else {
					each( spaces, function( spaceName, space ) {
						var cache = space.cache;
						each( space.props, function( key, prop ) {
	
							// if the cache doesn't exist, and we know how to convert
							if ( !inst[ cache ] && space.to ) {
	
								// if the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if ( key === "alpha" || red[ key ] == null ) {
									return;
								}
								inst[ cache ] = space.to( inst._rgba );
							}
	
							// this is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
						});
	
						// everything defined but alpha?
						if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
							// use the default of 1
							inst[ cache ][ 3 ] = 1;
							if ( space.from ) {
								inst._rgba = space.from( inst[ cache ] );
							}
						}
					});
				}
				return this;
			}
		},
		is: function( compare ) {
			var is = color( compare ),
				same = true,
				inst = this;
	
			each( spaces, function( _, space ) {
				var localCache,
					isCache = is[ space.cache ];
				if (isCache) {
					localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
					each( space.props, function( _, prop ) {
						if ( isCache[ prop.idx ] != null ) {
							same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
							return same;
						}
					});
				}
				return same;
			});
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each( spaces, function( spaceName, space ) {
				if ( inst[ space.cache ] ) {
					used.push( spaceName );
				}
			});
			return used.pop();
		},
		transition: function( other, distance ) {
			var end = color( other ),
				spaceName = end._space(),
				space = spaces[ spaceName ],
				startColor = this.alpha() === 0 ? color( "transparent" ) : this,
				start = startColor[ space.cache ] || space.to( startColor._rgba ),
				result = start.slice();
	
			end = end[ space.cache ];
			each( space.props, function( key, prop ) {
				var index = prop.idx,
					startValue = start[ index ],
					endValue = end[ index ],
					type = propTypes[ prop.type ] || {};
	
				// if null, don't override start value
				if ( endValue === null ) {
					return;
				}
				// if null - use end
				if ( startValue === null ) {
					result[ index ] = endValue;
				} else {
					if ( type.mod ) {
						if ( endValue - startValue > type.mod / 2 ) {
							startValue += type.mod;
						} else if ( startValue - endValue > type.mod / 2 ) {
							startValue -= type.mod;
						}
					}
					result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
				}
			});
			return this[ spaceName ]( result );
		},
		blend: function( opaque ) {
			// if we are already opaque - return ourself
			if ( this._rgba[ 3 ] === 1 ) {
				return this;
			}
	
			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color( opaque )._rgba;
	
			return color( jQuery.map( rgb, function( v, i ) {
				return ( 1 - a ) * blend[ i ] + a * v;
			}));
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map( this._rgba, function( v, i ) {
					return v == null ? ( i > 2 ? 1 : 0 ) : v;
				});
	
			if ( rgba[ 3 ] === 1 ) {
				rgba.pop();
				prefix = "rgb(";
			}
	
			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map( this.hsla(), function( v, i ) {
					if ( v == null ) {
						v = i > 2 ? 1 : 0;
					}
	
					// catch 1 and 2
					if ( i && i < 3 ) {
						v = Math.round( v * 100 ) + "%";
					}
					return v;
				});
	
			if ( hsla[ 3 ] === 1 ) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function( includeAlpha ) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();
	
			if ( includeAlpha ) {
				rgba.push( ~~( alpha * 255 ) );
			}
	
			return "#" + jQuery.map( rgba, function( v ) {
	
				// default to 0 when nulls exist
				v = ( v || 0 ).toString( 16 );
				return v.length === 1 ? "0" + v : v;
			}).join("");
		},
		toString: function() {
			return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
		}
	});
	color.fn.parse.prototype = color.fn;
	
	// hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
	
	function hue2rgb( p, q, h ) {
		h = ( h + 1 ) % 1;
		if ( h * 6 < 1 ) {
			return p + ( q - p ) * h * 6;
		}
		if ( h * 2 < 1) {
			return q;
		}
		if ( h * 3 < 2 ) {
			return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
		}
		return p;
	}
	
	spaces.hsla.to = function( rgba ) {
		if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
			return [ null, null, null, rgba[ 3 ] ];
		}
		var r = rgba[ 0 ] / 255,
			g = rgba[ 1 ] / 255,
			b = rgba[ 2 ] / 255,
			a = rgba[ 3 ],
			max = Math.max( r, g, b ),
			min = Math.min( r, g, b ),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;
	
		if ( min === max ) {
			h = 0;
		} else if ( r === max ) {
			h = ( 60 * ( g - b ) / diff ) + 360;
		} else if ( g === max ) {
			h = ( 60 * ( b - r ) / diff ) + 120;
		} else {
			h = ( 60 * ( r - g ) / diff ) + 240;
		}
	
		// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
		// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
		if ( diff === 0 ) {
			s = 0;
		} else if ( l <= 0.5 ) {
			s = diff / add;
		} else {
			s = diff / ( 2 - add );
		}
		return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
	};
	
	spaces.hsla.from = function( hsla ) {
		if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
			return [ null, null, null, hsla[ 3 ] ];
		}
		var h = hsla[ 0 ] / 360,
			s = hsla[ 1 ],
			l = hsla[ 2 ],
			a = hsla[ 3 ],
			q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
			p = 2 * l - q;
	
		return [
			Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
			Math.round( hue2rgb( p, q, h ) * 255 ),
			Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
			a
		];
	};
	
	each( spaces, function( spaceName, space ) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;
	
		// makes rgba() and hsla()
		color.fn[ spaceName ] = function( value ) {
	
			// generate a cache for this space if it doesn't exist
			if ( to && !this[ cache ] ) {
				this[ cache ] = to( this._rgba );
			}
			if ( value === undefined ) {
				return this[ cache ].slice();
			}
	
			var ret,
				type = jQuery.type( value ),
				arr = ( type === "array" || type === "object" ) ? value : arguments,
				local = this[ cache ].slice();
	
			each( props, function( key, prop ) {
				var val = arr[ type === "object" ? key : prop.idx ];
				if ( val == null ) {
					val = local[ prop.idx ];
				}
				local[ prop.idx ] = clamp( val, prop );
			});
	
			if ( from ) {
				ret = color( from( local ) );
				ret[ cache ] = local;
				return ret;
			} else {
				return color( local );
			}
		};
	
		// makes red() green() blue() alpha() hue() saturation() lightness()
		each( props, function( key, prop ) {
			// alpha is included in more than one space
			if ( color.fn[ key ] ) {
				return;
			}
			color.fn[ key ] = function( value ) {
				var vtype = jQuery.type( value ),
					fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
					local = this[ fn ](),
					cur = local[ prop.idx ],
					match;
	
				if ( vtype === "undefined" ) {
					return cur;
				}
	
				if ( vtype === "function" ) {
					value = value.call( this, cur );
					vtype = jQuery.type( value );
				}
				if ( value == null && prop.empty ) {
					return this;
				}
				if ( vtype === "string" ) {
					match = rplusequals.exec( value );
					if ( match ) {
						value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
					}
				}
				local[ prop.idx ] = value;
				return this[ fn ]( local );
			};
		});
	});
	
	// add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function( hook ) {
		var hooks = hook.split( " " );
		each( hooks, function( i, hook ) {
			jQuery.cssHooks[ hook ] = {
				set: function( elem, value ) {
					var parsed, curElem,
						backgroundColor = "";
	
					if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
						value = color( parsed || value );
						if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								(backgroundColor === "" || backgroundColor === "transparent") &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css( curElem, "backgroundColor" );
									curElem = curElem.parentNode;
								} catch ( e ) {
								}
							}
	
							value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default" );
						}
	
						value = value.toRgbaString();
					}
					try {
						elem.style[ hook ] = value;
					} catch ( e ) {
						// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[ hook ] = function( fx ) {
				if ( !fx.colorInit ) {
					fx.start = color( fx.elem, hook );
					fx.end = color( fx.end );
					fx.colorInit = true;
				}
				jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
			};
		});
	
	};
	
	color.hook( stepHooks );
	
	jQuery.cssHooks.borderColor = {
		expand: function( value ) {
			var expanded = {};
	
			each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
				expanded[ "border" + part + "Color" ] = value;
			});
			return expanded;
		}
	};
	
	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",
	
		// 4.2.3. "transparent" color keyword
		transparent: [ null, null, null, 0 ],
	
		_default: "#ffffff"
	};
	
	})( jQuery );
	
	/******************************************************************************/
	/****************************** CLASS ANIMATIONS ******************************/
	/******************************************************************************/
	(function() {
	
	var classAnimationActions = [ "add", "remove", "toggle" ],
		shorthandStyles = {
			border: 1,
			borderBottom: 1,
			borderColor: 1,
			borderLeft: 1,
			borderRight: 1,
			borderTop: 1,
			borderWidth: 1,
			margin: 1,
			padding: 1
		};
	
	$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	});
	
	function getElementStyles( elem ) {
		var key, len,
			style = elem.ownerDocument.defaultView ?
				elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
				elem.currentStyle,
			styles = {};
	
		if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
			len = style.length;
			while ( len-- ) {
				key = style[ len ];
				if ( typeof style[ key ] === "string" ) {
					styles[ $.camelCase( key ) ] = style[ key ];
				}
			}
		// support: Opera, IE <9
		} else {
			for ( key in style ) {
				if ( typeof style[ key ] === "string" ) {
					styles[ key ] = style[ key ];
				}
			}
		}
	
		return styles;
	}
	
	function styleDifference( oldStyle, newStyle ) {
		var diff = {},
			name, value;
	
		for ( name in newStyle ) {
			value = newStyle[ name ];
			if ( oldStyle[ name ] !== value ) {
				if ( !shorthandStyles[ name ] ) {
					if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
						diff[ name ] = value;
					}
				}
			}
		}
	
		return diff;
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	$.effects.animateClass = function( value, duration, easing, callback ) {
		var o = $.speed( duration, easing, callback );
	
		return this.queue( function() {
			var animated = $( this ),
				baseClass = animated.attr( "class" ) || "",
				applyClassChange,
				allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
	
			// map the animated objects to store the original styles.
			allAnimations = allAnimations.map(function() {
				var el = $( this );
				return {
					el: el,
					start: getElementStyles( this )
				};
			});
	
			// apply class change
			applyClassChange = function() {
				$.each( classAnimationActions, function(i, action) {
					if ( value[ action ] ) {
						animated[ action + "Class" ]( value[ action ] );
					}
				});
			};
			applyClassChange();
	
			// map all animated objects again - calculate new styles and diff
			allAnimations = allAnimations.map(function() {
				this.end = getElementStyles( this.el[ 0 ] );
				this.diff = styleDifference( this.start, this.end );
				return this;
			});
	
			// apply original class
			animated.attr( "class", baseClass );
	
			// map all animated objects again - this time collecting a promise
			allAnimations = allAnimations.map(function() {
				var styleInfo = this,
					dfd = $.Deferred(),
					opts = $.extend({}, o, {
						queue: false,
						complete: function() {
							dfd.resolve( styleInfo );
						}
					});
	
				this.el.animate( this.diff, opts );
				return dfd.promise();
			});
	
			// once all animations have completed:
			$.when.apply( $, allAnimations.get() ).done(function() {
	
				// set the final class
				applyClassChange();
	
				// for each animated element,
				// clear all css properties that were animated
				$.each( arguments, function() {
					var el = this.el;
					$.each( this.diff, function(key) {
						el.css( key, "" );
					});
				});
	
				// this is guarnteed to be there if you use jQuery.speed()
				// it also handles dequeuing the next anim...
				o.complete.call( animated[ 0 ] );
			});
		});
	};
	
	$.fn.extend({
		addClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return speed ?
					$.effects.animateClass.call( this,
						{ add: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.addClass ),
	
		removeClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return arguments.length > 1 ?
					$.effects.animateClass.call( this,
						{ remove: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.removeClass ),
	
		toggleClass: (function( orig ) {
			return function( classNames, force, speed, easing, callback ) {
				if ( typeof force === "boolean" || force === undefined ) {
					if ( !speed ) {
						// without speed parameter
						return orig.apply( this, arguments );
					} else {
						return $.effects.animateClass.call( this,
							(force ? { add: classNames } : { remove: classNames }),
							speed, easing, callback );
					}
				} else {
					// without force parameter
					return $.effects.animateClass.call( this,
						{ toggle: classNames }, force, speed, easing );
				}
			};
		})( $.fn.toggleClass ),
	
		switchClass: function( remove, add, speed, easing, callback) {
			return $.effects.animateClass.call( this, {
				add: add,
				remove: remove
			}, speed, easing, callback );
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EFFECTS **********************************/
	/******************************************************************************/
	
	(function() {
	
	$.extend( $.effects, {
		version: "1.11.4",
	
		// Saves a set of properties in a data storage
		save: function( element, set ) {
			for ( var i = 0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},
	
		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i;
			for ( i = 0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					// support: jQuery 1.6.2
					// http://bugs.jquery.com/ticket/9917
					// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
					// We can't differentiate between "" and 0 here, so we just assume
					// empty string since it's likely to be a more common value...
					if ( val === undefined ) {
						val = "";
					}
					element.css( set[ i ], val );
				}
			}
		},
	
		setMode: function( el, mode ) {
			if (mode === "toggle") {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},
	
		// Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		getBaseline: function( origin, original ) {
			var y, x;
			switch ( origin[ 0 ] ) {
				case "top": y = 0; break;
				case "middle": y = 0.5; break;
				case "bottom": y = 1; break;
				default: y = origin[ 0 ] / original.height;
			}
			switch ( origin[ 1 ] ) {
				case "left": x = 0; break;
				case "center": x = 0.5; break;
				case "right": x = 1; break;
				default: x = origin[ 1 ] / original.width;
			}
			return {
				x: x,
				y: y
			};
		},
	
		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {
	
			// if the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" )) {
				return element.parent();
			}
	
			// wrap the element
			var props = {
					width: element.outerWidth(true),
					height: element.outerHeight(true),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css({
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					}),
				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;
	
			// support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch ( e ) {
				active = document.body;
			}
	
			element.wrap( wrapper );
	
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
	
			wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
	
			// transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css({ position: "relative" });
				element.css({ position: "relative" });
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				});
				$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				});
				element.css({
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				});
			}
			element.css(size);
	
			return wrapper.css( props ).show();
		},
	
		removeWrapper: function( element ) {
			var active = document.activeElement;
	
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );
	
				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).focus();
				}
			}
	
			return element;
		},
	
		setTransition: function( element, list, factor, value ) {
			value = value || {};
			$.each( list, function( i, x ) {
				var unit = element.cssUnit( x );
				if ( unit[ 0 ] > 0 ) {
					value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
				}
			});
			return value;
		}
	});
	
	// return an effect options object for the given parameters:
	function _normalizeArguments( effect, options, speed, callback ) {
	
		// allow passing all options as the first parameter
		if ( $.isPlainObject( effect ) ) {
			options = effect;
			effect = effect.effect;
		}
	
		// convert to an object
		effect = { effect: effect };
	
		// catch (effect, null, ...)
		if ( options == null ) {
			options = {};
		}
	
		// catch (effect, callback)
		if ( $.isFunction( options ) ) {
			callback = options;
			speed = null;
			options = {};
		}
	
		// catch (effect, speed, ?)
		if ( typeof options === "number" || $.fx.speeds[ options ] ) {
			callback = speed;
			speed = options;
			options = {};
		}
	
		// catch (effect, options, callback)
		if ( $.isFunction( speed ) ) {
			callback = speed;
			speed = null;
		}
	
		// add options to effect
		if ( options ) {
			$.extend( effect, options );
		}
	
		speed = speed || options.duration;
		effect.duration = $.fx.off ? 0 :
			typeof speed === "number" ? speed :
			speed in $.fx.speeds ? $.fx.speeds[ speed ] :
			$.fx.speeds._default;
	
		effect.complete = callback || options.complete;
	
		return effect;
	}
	
	function standardAnimationOption( option ) {
		// Valid standard speeds (nothing, number, named speed)
		if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
			return true;
		}
	
		// Invalid strings - treat as "normal" speed
		if ( typeof option === "string" && !$.effects.effect[ option ] ) {
			return true;
		}
	
		// Complete callback
		if ( $.isFunction( option ) ) {
			return true;
		}
	
		// Options hash (but not naming an effect)
		if ( typeof option === "object" && !option.effect ) {
			return true;
		}
	
		// Didn't match any standard API
		return false;
	}
	
	$.fn.extend({
		effect: function( /* effect, options, speed, callback */ ) {
			var args = _normalizeArguments.apply( this, arguments ),
				mode = args.mode,
				queue = args.queue,
				effectMethod = $.effects.effect[ args.effect ];
	
			if ( $.fx.off || !effectMethod ) {
				// delegate to the original method (e.g., .show()) if possible
				if ( mode ) {
					return this[ mode ]( args.duration, args.complete );
				} else {
					return this.each( function() {
						if ( args.complete ) {
							args.complete.call( this );
						}
					});
				}
			}
	
			function run( next ) {
				var elem = $( this ),
					complete = args.complete,
					mode = args.mode;
	
				function done() {
					if ( $.isFunction( complete ) ) {
						complete.call( elem[0] );
					}
					if ( $.isFunction( next ) ) {
						next();
					}
				}
	
				// If the element already has the correct final state, delegate to
				// the core methods so the internal tracking of "olddisplay" works.
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[0], args, done );
				}
			}
	
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		},
	
		show: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "show";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.show ),
	
		hide: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "hide";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.hide ),
	
		toggle: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "toggle";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.toggle ),
	
		// helper functions
		cssUnit: function(key) {
			var style = this.css( key ),
				val = [];
	
			$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
				if ( style.indexOf( unit ) > 0 ) {
					val = [ parseFloat( style ), unit ];
				}
			});
			return val;
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EASING ***********************************/
	/******************************************************************************/
	
	(function() {
	
	// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
	
	var baseEasings = {};
	
	$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
		baseEasings[ name ] = function( p ) {
			return Math.pow( p, i + 2 );
		};
	});
	
	$.extend( baseEasings, {
		Sine: function( p ) {
			return 1 - Math.cos( p * Math.PI / 2 );
		},
		Circ: function( p ) {
			return 1 - Math.sqrt( 1 - p * p );
		},
		Elastic: function( p ) {
			return p === 0 || p === 1 ? p :
				-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
		},
		Back: function( p ) {
			return p * p * ( 3 * p - 2 );
		},
		Bounce: function( p ) {
			var pow2,
				bounce = 4;
	
			while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
			return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
		}
	});
	
	$.each( baseEasings, function( name, easeIn ) {
		$.easing[ "easeIn" + name ] = easeIn;
		$.easing[ "easeOut" + name ] = function( p ) {
			return 1 - easeIn( 1 - p );
		};
		$.easing[ "easeInOut" + name ] = function( p ) {
			return p < 0.5 ?
				easeIn( p * 2 ) / 2 :
				1 - easeIn( p * -2 + 2 ) / 2;
		};
	});
	
	})();
	
	var effect = $.effects;
	
	
	/*!
	 * jQuery UI Effects Blind 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/blind-effect/
	 */
	
	
	var effectBlind = $.effects.effect.blind = function( o, done ) {
		// Create element
		var el = $( this ),
			rvertical = /up|down|vertical/,
			rpositivemotion = /up|left|vertical|horizontal/,
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			direction = o.direction || "up",
			vertical = rvertical.test( direction ),
			ref = vertical ? "height" : "width",
			ref2 = vertical ? "top" : "left",
			motion = rpositivemotion.test( direction ),
			animation = {},
			show = mode === "show",
			wrapper, distance, margin;
	
		// if already wrapped, the wrapper's properties are my property. #6245
		if ( el.parent().is( ".ui-effects-wrapper" ) ) {
			$.effects.save( el.parent(), props );
		} else {
			$.effects.save( el, props );
		}
		el.show();
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		distance = wrapper[ ref ]();
		margin = parseFloat( wrapper.css( ref2 ) ) || 0;
	
		animation[ ref ] = show ? distance : 0;
		if ( !motion ) {
			el
				.css( vertical ? "bottom" : "right", 0 )
				.css( vertical ? "top" : "left", "auto" )
				.css({ position: "absolute" });
	
			animation[ ref2 ] = show ? margin : distance + margin;
		}
	
		// start at 0 if we are showing
		if ( show ) {
			wrapper.css( ref, 0 );
			if ( !motion ) {
				wrapper.css( ref2, margin + distance );
			}
		}
	
		// Animate
		wrapper.animate( animation, {
			duration: o.duration,
			easing: o.easing,
			queue: false,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Bounce 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/bounce-effect/
	 */
	
	
	var effectBounce = $.effects.effect.bounce = function( o, done ) {
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
	
			// defaults:
			mode = $.effects.setMode( el, o.mode || "effect" ),
			hide = mode === "hide",
			show = mode === "show",
			direction = o.direction || "up",
			distance = o.distance,
			times = o.times || 5,
	
			// number of internal animations
			anims = times * 2 + ( show || hide ? 1 : 0 ),
			speed = o.duration / anims,
			easing = o.easing,
	
			// utility:
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ),
			i,
			upAnim,
			downAnim,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		// Avoid touching opacity to prevent clearType and PNG issues in IE
		if ( show || hide ) {
			props.push( "opacity" );
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el ); // Create Wrapper
	
		// default distance for the BIGGEST bounce is the outer Distance / 3
		if ( !distance ) {
			distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
		}
	
		if ( show ) {
			downAnim = { opacity: 1 };
			downAnim[ ref ] = 0;
	
			// if we are showing, force opacity 0 and set the initial position
			// then do the "first" animation
			el.css( "opacity", 0 )
				.css( ref, motion ? -distance * 2 : distance * 2 )
				.animate( downAnim, speed, easing );
		}
	
		// start at the smallest distance if we are hiding
		if ( hide ) {
			distance = distance / Math.pow( 2, times - 1 );
		}
	
		downAnim = {};
		downAnim[ ref ] = 0;
		// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
		for ( i = 0; i < times; i++ ) {
			upAnim = {};
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing )
				.animate( downAnim, speed, easing );
	
			distance = hide ? distance * 2 : distance / 2;
		}
	
		// Last Bounce when Hiding
		if ( hide ) {
			upAnim = { opacity: 0 };
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing );
		}
	
		el.queue(function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	
	/*!
	 * jQuery UI Effects Clip 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/clip-effect/
	 */
	
	
	var effectClip = $.effects.effect.clip = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "vertical",
			vert = direction === "vertical",
			size = vert ? "height" : "width",
			position = vert ? "top" : "left",
			animation = {},
			wrapper, animate, distance;
	
		// Save & Show
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
		distance = animate[ size ]();
	
		// Shift
		if ( show ) {
			animate.css( size, 0 );
			animate.css( position, distance / 2 );
		}
	
		// Create Animation Object:
		animation[ size ] = show ? distance : 0;
		animation[ position ] = show ? 0 : distance / 2;
	
		// Animate
		animate.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( !show ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	
	/*!
	 * jQuery UI Effects Drop 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/drop-effect/
	 */
	
	
	var effectDrop = $.effects.effect.drop = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
			animation = {
				opacity: show ? 1 : 0
			},
			distance;
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;
	
		if ( show ) {
			el
				.css( "opacity", 0 )
				.css( ref, motion === "pos" ? -distance : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( motion === "pos" ? "+=" : "-=" ) :
			( motion === "pos" ? "-=" : "+=" ) ) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Explode 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/explode-effect/
	 */
	
	
	var effectExplode = $.effects.effect.explode = function( o, done ) {
	
		var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
			cells = rows,
			el = $( this ),
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
	
			// show and then visibility:hidden the element before calculating offset
			offset = el.show().css( "visibility", "hidden" ).offset(),
	
			// width and height of a piece
			width = Math.ceil( el.outerWidth() / cells ),
			height = Math.ceil( el.outerHeight() / rows ),
			pieces = [],
	
			// loop
			i, j, left, top, mx, my;
	
		// children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}
	
		// clone the element for each row and cell.
		for ( i = 0; i < rows ; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2 ;
	
			for ( j = 0; j < cells ; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2 ;
	
				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				el
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css({
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					})
	
				// select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
					.parent()
					.addClass( "ui-effects-explode" )
					.css({
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					}).animate({
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, o.duration || 500, o.easing, childComplete );
			}
		}
	
		function animComplete() {
			el.css({
				visibility: "visible"
			});
			$( pieces ).remove();
			if ( !show ) {
				el.hide();
			}
			done();
		}
	};
	
	
	/*!
	 * jQuery UI Effects Fade 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/fade-effect/
	 */
	
	
	var effectFade = $.effects.effect.fade = function( o, done ) {
		var el = $( this ),
			mode = $.effects.setMode( el, o.mode || "toggle" );
	
		el.animate({
			opacity: mode
		}, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: done
		});
	};
	
	
	/*!
	 * jQuery UI Effects Fold 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/fold-effect/
	 */
	
	
	var effectFold = $.effects.effect.fold = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			hide = mode === "hide",
			size = o.size || 15,
			percent = /([0-9]+)%/.exec( size ),
			horizFirst = !!o.horizFirst,
			widthFirst = show !== horizFirst,
			ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
			duration = o.duration / 2,
			wrapper, distance,
			animation1 = {},
			animation2 = {};
	
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		distance = widthFirst ?
			[ wrapper.width(), wrapper.height() ] :
			[ wrapper.height(), wrapper.width() ];
	
		if ( percent ) {
			size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
		}
		if ( show ) {
			wrapper.css( horizFirst ? {
				height: 0,
				width: size
			} : {
				height: size,
				width: 0
			});
		}
	
		// Animation
		animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
		animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;
	
		// Animate
		wrapper
			.animate( animation1, duration, o.easing )
			.animate( animation2, duration, o.easing, function() {
				if ( hide ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
	};
	
	
	/*!
	 * jQuery UI Effects Highlight 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/highlight-effect/
	 */
	
	
	var effectHighlight = $.effects.effect.highlight = function( o, done ) {
		var elem = $( this ),
			props = [ "backgroundImage", "backgroundColor", "opacity" ],
			mode = $.effects.setMode( elem, o.mode || "show" ),
			animation = {
				backgroundColor: elem.css( "backgroundColor" )
			};
	
		if (mode === "hide") {
			animation.opacity = 0;
		}
	
		$.effects.save( elem, props );
	
		elem
			.show()
			.css({
				backgroundImage: "none",
				backgroundColor: o.color || "#ffff99"
			})
			.animate( animation, {
				queue: false,
				duration: o.duration,
				easing: o.easing,
				complete: function() {
					if ( mode === "hide" ) {
						elem.hide();
					}
					$.effects.restore( elem, props );
					done();
				}
			});
	};
	
	
	/*!
	 * jQuery UI Effects Size 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/size-effect/
	 */
	
	
	var effectSize = $.effects.effect.size = function( o, done ) {
	
		// Create element
		var original, baseline, factor,
			el = $( this ),
			props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],
	
			// Always restore
			props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],
	
			// Copy for children
			props2 = [ "width", "height", "overflow" ],
			cProps = [ "fontSize" ],
			vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
			hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
	
			// Set options
			mode = $.effects.setMode( el, o.mode || "effect" ),
			restore = o.restore || mode !== "effect",
			scale = o.scale || "both",
			origin = o.origin || [ "middle", "center" ],
			position = el.css( "position" ),
			props = restore ? props0 : props1,
			zero = {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
	
		if ( mode === "show" ) {
			el.show();
		}
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		};
	
		if ( o.mode === "toggle" && mode === "show" ) {
			el.from = o.to || zero;
			el.to = o.from || original;
		} else {
			el.from = o.from || ( mode === "show" ? zero : original );
			el.to = o.to || ( mode === "hide" ? zero : original );
		}
	
		// Set scaling factor
		factor = {
			from: {
				y: el.from.height / original.height,
				x: el.from.width / original.width
			},
			to: {
				y: el.to.height / original.height,
				x: el.to.width / original.width
			}
		};
	
		// Scale the css box
		if ( scale === "box" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( vProps );
				el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
			}
	
			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				props = props.concat( hProps );
				el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
				el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
			}
		}
	
		// Scale the content
		if ( scale === "content" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( cProps ).concat( props2 );
				el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
			}
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
		el.css( "overflow", "hidden" ).css( el.from );
	
		// Adjust
		if (origin) { // Calculate baseline shifts
			baseline = $.effects.getBaseline( origin, original );
			el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
			el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
			el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
			el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
		}
		el.css( el.from ); // set top & left
	
		// Animate
		if ( scale === "content" || scale === "both" ) { // Scale the children
	
			// Add margins/font-size
			vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
			hProps = hProps.concat([ "marginLeft", "marginRight" ]);
			props2 = props0.concat(vProps).concat(hProps);
	
			el.find( "*[width]" ).each( function() {
				var child = $( this ),
					c_original = {
						height: child.height(),
						width: child.width(),
						outerHeight: child.outerHeight(),
						outerWidth: child.outerWidth()
					};
				if (restore) {
					$.effects.save(child, props2);
				}
	
				child.from = {
					height: c_original.height * factor.from.y,
					width: c_original.width * factor.from.x,
					outerHeight: c_original.outerHeight * factor.from.y,
					outerWidth: c_original.outerWidth * factor.from.x
				};
				child.to = {
					height: c_original.height * factor.to.y,
					width: c_original.width * factor.to.x,
					outerHeight: c_original.height * factor.to.y,
					outerWidth: c_original.width * factor.to.x
				};
	
				// Vertical props scaling
				if ( factor.from.y !== factor.to.y ) {
					child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
					child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
				}
	
				// Horizontal props scaling
				if ( factor.from.x !== factor.to.x ) {
					child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
					child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
				}
	
				// Animate children
				child.css( child.from );
				child.animate( child.to, o.duration, o.easing, function() {
	
					// Restore children
					if ( restore ) {
						$.effects.restore( child, props2 );
					}
				});
			});
		}
	
		// Animate
		el.animate( el.to, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( el.to.opacity === 0 ) {
					el.css( "opacity", el.from.opacity );
				}
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				if ( !restore ) {
	
					// we need to calculate our new positioning based on the scaling
					if ( position === "static" ) {
						el.css({
							position: "relative",
							top: el.to.top,
							left: el.to.left
						});
					} else {
						$.each([ "top", "left" ], function( idx, pos ) {
							el.css( pos, function( _, str ) {
								var val = parseInt( str, 10 ),
									toRef = idx ? el.to.left : el.to.top;
	
								// if original was "auto", recalculate the new value from wrapper
								if ( str === "auto" ) {
									return toRef + "px";
								}
	
								return val + toRef + "px";
							});
						});
					}
				}
	
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	
	/*!
	 * jQuery UI Effects Scale 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/scale-effect/
	 */
	
	
	var effectScale = $.effects.effect.scale = function( o, done ) {
	
		// Create element
		var el = $( this ),
			options = $.extend( true, {}, o ),
			mode = $.effects.setMode( el, o.mode || "effect" ),
			percent = parseInt( o.percent, 10 ) ||
				( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
			direction = o.direction || "both",
			origin = o.origin,
			original = {
				height: el.height(),
				width: el.width(),
				outerHeight: el.outerHeight(),
				outerWidth: el.outerWidth()
			},
			factor = {
				y: direction !== "horizontal" ? (percent / 100) : 1,
				x: direction !== "vertical" ? (percent / 100) : 1
			};
	
		// We are going to pass this effect to the size effect:
		options.effect = "size";
		options.queue = false;
		options.complete = done;
	
		// Set default origin and restore for show/hide
		if ( mode !== "effect" ) {
			options.origin = origin || [ "middle", "center" ];
			options.restore = true;
		}
	
		options.from = o.from || ( mode === "show" ? {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		} : original );
		options.to = {
			height: original.height * factor.y,
			width: original.width * factor.x,
			outerHeight: original.outerHeight * factor.y,
			outerWidth: original.outerWidth * factor.x
		};
	
		// Fade option to support puff
		if ( options.fade ) {
			if ( mode === "show" ) {
				options.from.opacity = 0;
				options.to.opacity = 1;
			}
			if ( mode === "hide" ) {
				options.from.opacity = 1;
				options.to.opacity = 0;
			}
		}
	
		// Animate
		el.effect( options );
	
	};
	
	
	/*!
	 * jQuery UI Effects Puff 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/puff-effect/
	 */
	
	
	var effectPuff = $.effects.effect.puff = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "hide" ),
			hide = mode === "hide",
			percent = parseInt( o.percent, 10 ) || 150,
			factor = percent / 100,
			original = {
				height: elem.height(),
				width: elem.width(),
				outerHeight: elem.outerHeight(),
				outerWidth: elem.outerWidth()
			};
	
		$.extend( o, {
			effect: "scale",
			queue: false,
			fade: true,
			mode: mode,
			complete: done,
			percent: hide ? percent : 100,
			from: hide ?
				original :
				{
					height: original.height * factor,
					width: original.width * factor,
					outerHeight: original.outerHeight * factor,
					outerWidth: original.outerWidth * factor
				}
		});
	
		elem.effect( o );
	};
	
	
	/*!
	 * jQuery UI Effects Pulsate 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/pulsate-effect/
	 */
	
	
	var effectPulsate = $.effects.effect.pulsate = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "show" ),
			show = mode === "show",
			hide = mode === "hide",
			showhide = ( show || mode === "hide" ),
	
			// showing or hiding leaves of the "last" animation
			anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = o.duration / anims,
			animateTo = 0,
			queue = elem.queue(),
			queuelen = queue.length,
			i;
	
		if ( show || !elem.is(":visible")) {
			elem.css( "opacity", 0 ).show();
			animateTo = 1;
		}
	
		// anims - 1 opacity "toggles"
		for ( i = 1; i < anims; i++ ) {
			elem.animate({
				opacity: animateTo
			}, duration, o.easing );
			animateTo = 1 - animateTo;
		}
	
		elem.animate({
			opacity: animateTo
		}, duration, o.easing);
	
		elem.queue(function() {
			if ( hide ) {
				elem.hide();
			}
			done();
		});
	
		// We just queued up "anims" animations, we need to put them next in the queue
		if ( queuelen > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		elem.dequeue();
	};
	
	
	/*!
	 * jQuery UI Effects Shake 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/shake-effect/
	 */
	
	
	var effectShake = $.effects.effect.shake = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "effect" ),
			direction = o.direction || "left",
			distance = o.distance || 20,
			times = o.times || 3,
			anims = times * 2 + 1,
			speed = Math.round( o.duration / anims ),
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			animation = {},
			animation1 = {},
			animation2 = {},
			i,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		// Animation
		animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
		animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
		animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
	
		// Animate
		el.animate( animation, speed, o.easing );
	
		// Shakes
		for ( i = 1; i < times; i++ ) {
			el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
		}
		el
			.animate( animation1, speed, o.easing )
			.animate( animation, speed / 2, o.easing )
			.queue(function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	
	/*!
	 * jQuery UI Effects Slide 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/slide-effect/
	 */
	
	
	var effectSlide = $.effects.effect.slide = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
			mode = $.effects.setMode( el, o.mode || "show" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			distance,
			animation = {};
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );
	
		$.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		if ( show ) {
			el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( positiveMotion ? "+=" : "-=") :
			( positiveMotion ? "-=" : "+=")) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Transfer 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/transfer-effect/
	 */
	
	
	var effectTransfer = $.effects.effect.transfer = function( o, done ) {
		var elem = $( this ),
			target = $( o.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $("body"),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop,
				left: endPosition.left - fixLeft,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( document.body )
				.addClass( o.className )
				.css({
					top: startPosition.top - fixTop,
					left: startPosition.left - fixLeft,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				})
				.animate( animation, o.duration, o.easing, function() {
					transfer.remove();
					done();
				});
	};
	
	
	
	}));

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*! 
	 * jquery.event.drag - v 2.2
	 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
	 * Open Source MIT License - http://threedubmedia.com/code/license
	 */
	// Created: 2008-06-04 
	// Updated: 2012-05-21
	// REQUIRES: jquery 1.7.x
	
	;(function( $ ){
	
	// add the jquery instance method
	$.fn.drag = function( str, arg, opts ){
		// figure out the event type
		var type = typeof str == "string" ? str : "",
		// figure out the event handler...
		fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
		// fix the event type
		if ( type.indexOf("drag") !== 0 ) 
			type = "drag"+ type;
		// were options passed
		opts = ( str == fn ? arg : opts ) || {};
		// trigger or bind event handler
		return fn ? this.bind( type, opts, fn ) : this.trigger( type );
	};
	
	// local refs (increase compression)
	var $event = $.event, 
	$special = $event.special,
	// configure the drag special event 
	drag = $special.drag = {
		
		// these are the default settings
		defaults: {
			which: 1, // mouse button pressed to start drag sequence
			distance: 0, // distance dragged before dragstart
			not: ':input', // selector to suppress dragging on target elements
			handle: null, // selector to match handle target elements
			relative: false, // true to use "position", false to use "offset"
			drop: true, // false to suppress drop events, true or selector to allow
			click: false // false to suppress click events after dragend (no proxy)
		},
		
		// the key name for stored drag data
		datakey: "dragdata",
		
		// prevent bubbling for better performance
		noBubble: true,
		
		// count bound related events
		add: function( obj ){ 
			// read the interaction data
			var data = $.data( this, drag.datakey ),
			// read any passed options 
			opts = obj.data || {};
			// count another realted event
			data.related += 1;
			// extend data options bound with this event
			// don't iterate "opts" in case it is a node 
			$.each( drag.defaults, function( key, def ){
				if ( opts[ key ] !== undefined )
					data[ key ] = opts[ key ];
			});
		},
		
		// forget unbound related events
		remove: function(){
			$.data( this, drag.datakey ).related -= 1;
		},
		
		// configure interaction, capture settings
		setup: function(){
			// check for related events
			if ( $.data( this, drag.datakey ) ) 
				return;
			// initialize the drag data with copied defaults
			var data = $.extend({ related:0 }, drag.defaults );
			// store the interaction data
			$.data( this, drag.datakey, data );
			// bind the mousedown event, which starts drag interactions
			$event.add( this, "touchstart mousedown", drag.init, data );
			// prevent image dragging in IE...
			if ( this.attachEvent ) 
				this.attachEvent("ondragstart", drag.dontstart ); 
		},
		
		// destroy configured interaction
		teardown: function(){
			var data = $.data( this, drag.datakey ) || {};
			// check for related events
			if ( data.related ) 
				return;
			// remove the stored data
			$.removeData( this, drag.datakey );
			// remove the mousedown event
			$event.remove( this, "touchstart mousedown", drag.init );
			// enable text selection
			drag.textselect( true ); 
			// un-prevent image dragging in IE...
			if ( this.detachEvent ) 
				this.detachEvent("ondragstart", drag.dontstart ); 
		},
			
		// initialize the interaction
		init: function( event ){ 
			// sorry, only one touch at a time
			if ( drag.touched ) 
				return;
			// the drag/drop interaction data
			var dd = event.data, results;
			// check the which directive
			if ( event.which != 0 && dd.which > 0 && event.which != dd.which ) 
				return; 
			// check for suppressed selector
			if ( $( event.target ).is( dd.not ) ) 
				return;
			// check for handle selector
			if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length ) 
				return;
	
			drag.touched = event.type == 'touchstart' ? this : null;
			dd.propagates = 1;
			dd.mousedown = this;
			dd.interactions = [ drag.interaction( this, dd ) ];
			dd.target = event.target;
			dd.pageX = event.pageX;
			dd.pageY = event.pageY;
			dd.dragging = null;
			// handle draginit event... 
			results = drag.hijack( event, "draginit", dd );
			// early cancel
			if ( !dd.propagates )
				return;
			// flatten the result set
			results = drag.flatten( results );
			// insert new interaction elements
			if ( results && results.length ){
				dd.interactions = [];
				$.each( results, function(){
					dd.interactions.push( drag.interaction( this, dd ) );
				});
			}
			// remember how many interactions are propagating
			dd.propagates = dd.interactions.length;
			// locate and init the drop targets
			if ( dd.drop !== false && $special.drop ) 
				$special.drop.handler( event, dd );
			// disable text selection
			drag.textselect( false ); 
			// bind additional events...
			if ( drag.touched )
				$event.add( drag.touched, "touchmove touchend", drag.handler, dd );
			else 
				$event.add( document, "mousemove mouseup", drag.handler, dd );
			// helps prevent text selection or scrolling
			if ( !drag.touched || dd.live )
				return false;
		},	
		
		// returns an interaction object
		interaction: function( elem, dd ){
			var offset = $( elem )[ dd.relative ? "position" : "offset" ]() || { top:0, left:0 };
			return {
				drag: elem, 
				callback: new drag.callback(), 
				droppable: [],
				offset: offset
			};
		},
		
		// handle drag-releatd DOM events
		handler: function( event ){ 
			// read the data before hijacking anything
			var dd = event.data;	
			// handle various events
			switch ( event.type ){
				// mousemove, check distance, start dragging
				case !dd.dragging && 'touchmove': 
					event.preventDefault();
				case !dd.dragging && 'mousemove':
					//  drag tolerance, x + y = distance
					if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) ) 
						break; // distance tolerance not reached
					event.target = dd.target; // force target from "mousedown" event (fix distance issue)
					drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
					if ( dd.propagates ) // "dragstart" not rejected
						dd.dragging = true; // activate interaction
				// mousemove, dragging
				case 'touchmove':
					event.preventDefault();
				case 'mousemove':
					if ( dd.dragging ){
						// trigger "drag"		
						drag.hijack( event, "drag", dd );
						if ( dd.propagates ){
							// manage drop events
							if ( dd.drop !== false && $special.drop )
								$special.drop.handler( event, dd ); // "dropstart", "dropend"							
							break; // "drag" not rejected, stop		
						}
						event.type = "mouseup"; // helps "drop" handler behave
					}
				// mouseup, stop dragging
				case 'touchend': 
				case 'mouseup': 
				default:
					if ( drag.touched )
						$event.remove( drag.touched, "touchmove touchend", drag.handler ); // remove touch events
					else 
						$event.remove( document, "mousemove mouseup", drag.handler ); // remove page events	
					if ( dd.dragging ){
						if ( dd.drop !== false && $special.drop )
							$special.drop.handler( event, dd ); // "drop"
						drag.hijack( event, "dragend", dd ); // trigger "dragend"	
					}
					drag.textselect( true ); // enable text selection
					// if suppressing click events...
					if ( dd.click === false && dd.dragging )
						$.data( dd.mousedown, "suppress.click", new Date().getTime() + 5 );
					dd.dragging = drag.touched = false; // deactivate element	
					break;
			}
		},
			
		// re-use event object for custom events
		hijack: function( event, type, dd, x, elem ){
			// not configured
			if ( !dd ) 
				return;
			// remember the original event and type
			var orig = { event:event.originalEvent, type:event.type },
			// is the event drag related or drog related?
			mode = type.indexOf("drop") ? "drag" : "drop",
			// iteration vars
			result, i = x || 0, ia, $elems, callback,
			len = !isNaN( x ) ? x : dd.interactions.length;
			// modify the event type
			event.type = type;
			// remove the original event
			event.originalEvent = null;
			// initialize the results
			dd.results = [];
			// handle each interacted element
			do if ( ia = dd.interactions[ i ] ){
				// validate the interaction
				if ( type !== "dragend" && ia.cancelled )
					continue;
				// set the dragdrop properties on the event object
				callback = drag.properties( event, dd, ia );
				// prepare for more results
				ia.results = [];
				// handle each element
				$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
					// identify drag or drop targets individually
					callback.target = subject;
					// force propagtion of the custom event
					event.isPropagationStopped = function(){ return false; };
					// handle the event	
					result = subject ? $event.dispatch.call( subject, event, callback ) : null;
					// stop the drag interaction for this element
					if ( result === false ){
						if ( mode == "drag" ){
							ia.cancelled = true;
							dd.propagates -= 1;
						}
						if ( type == "drop" ){
							ia[ mode ][p] = null;
						}
					}
					// assign any dropinit elements
					else if ( type == "dropinit" )
						ia.droppable.push( drag.element( result ) || subject );
					// accept a returned proxy element 
					if ( type == "dragstart" )
						ia.proxy = $( drag.element( result ) || ia.drag )[0];
					// remember this result	
					ia.results.push( result );
					// forget the event result, for recycling
					delete event.result;
					// break on cancelled handler
					if ( type !== "dropinit" )
						return result;
				});	
				// flatten the results	
				dd.results[ i ] = drag.flatten( ia.results );	
				// accept a set of valid drop targets
				if ( type == "dropinit" )
					ia.droppable = drag.flatten( ia.droppable );
				// locate drop targets
				if ( type == "dragstart" && !ia.cancelled )
					callback.update(); 
			}
			while ( ++i < len )
			// restore the original event & type
			event.type = orig.type;
			event.originalEvent = orig.event;
			// return all handler results
			return drag.flatten( dd.results );
		},
			
		// extend the callback object with drag/drop properties...
		properties: function( event, dd, ia ){		
			var obj = ia.callback;
			// elements
			obj.drag = ia.drag;
			obj.proxy = ia.proxy || ia.drag;
			// starting mouse position
			obj.startX = dd.pageX;
			obj.startY = dd.pageY;
			// current distance dragged
			obj.deltaX = event.pageX - dd.pageX;
			obj.deltaY = event.pageY - dd.pageY;
			// original element position
			obj.originalX = ia.offset.left;
			obj.originalY = ia.offset.top;
			// adjusted element position
			obj.offsetX = obj.originalX + obj.deltaX; 
			obj.offsetY = obj.originalY + obj.deltaY;
			// assign the drop targets information
			obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
			obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
			return obj;	
		},
		
		// determine is the argument is an element or jquery instance
		element: function( arg ){
			if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
				return arg;
		},
		
		// flatten nested jquery objects and arrays into a single dimension array
		flatten: function( arr ){
			return $.map( arr, function( member ){
				return member && member.jquery ? $.makeArray( member ) : 
					member && member.length ? drag.flatten( member ) : member;
			});
		},
		
		// toggles text selection attributes ON (true) or OFF (false)
		textselect: function( bool ){ 
			$( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
				.css("MozUserSelect", bool ? "" : "none" );
			// .attr("unselectable", bool ? "off" : "on" )
			document.unselectable = bool ? "off" : "on"; 
		},
		
		// suppress "selectstart" and "ondragstart" events
		dontstart: function(){ 
			return false; 
		},
		
		// a callback instance contructor
		callback: function(){}
		
	};
	
	// callback methods
	drag.callback.prototype = {
		update: function(){
			if ( $special.drop && this.available.length )
				$.each( this.available, function( i ){
					$special.drop.locate( this, i );
				});
		}
	};
	
	// patch $.event.$dispatch to allow suppressing clicks
	var $dispatch = $event.dispatch;
	$event.dispatch = function( event ){
		if ( $.data( this, "suppress."+ event.type ) - new Date().getTime() > 0 ){
			$.removeData( this, "suppress."+ event.type );
			return;
		}
		return $dispatch.apply( this, arguments );
	};
	
	// event fix hooks for touch events...
	var touchHooks = 
	$event.fixHooks.touchstart = 
	$event.fixHooks.touchmove = 
	$event.fixHooks.touchend =
	$event.fixHooks.touchcancel = {
		props: "clientX clientY pageX pageY screenX screenY".split( " " ),
		filter: function( event, orig ) {
			if ( orig ){
				var touched = ( orig.touches && orig.touches[0] )
					|| ( orig.changedTouches && orig.changedTouches[0] )
					|| null; 
				// iOS webkit: touchstart, touchmove, touchend
				if ( touched ) 
					$.each( touchHooks.props, function( i, prop ){
						event[ prop ] = touched[ prop ];
					});
			}
			return event;
		}
	};
	
	// share the same special event configuration with related events...
	$special.draginit = $special.dragstart = $special.dragend = drag;
	
	})( jQuery );
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*! 
	 * jquery.event.drop - v 2.2
	 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
	 * Open Source MIT License - http://threedubmedia.com/code/license
	 */
	// Created: 2008-06-04 
	// Updated: 2012-05-21
	// REQUIRES: jquery 1.7.x, event.drag 2.2
	
	;(function($){ // secure $ jQuery alias
	
	// Events: drop, dropstart, dropend
	
	// add the jquery instance method
	$.fn.drop = function( str, arg, opts ){
		// figure out the event type
		var type = typeof str == "string" ? str : "",
		// figure out the event handler...
		fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
		// fix the event type
		if ( type.indexOf("drop") !== 0 ) 
			type = "drop"+ type;
		// were options passed
		opts = ( str == fn ? arg : opts ) || {};
		// trigger or bind event handler
		return fn ? this.bind( type, opts, fn ) : this.trigger( type );
	};
	
	// DROP MANAGEMENT UTILITY
	// returns filtered drop target elements, caches their positions
	$.drop = function( opts ){ 
		opts = opts || {};
		// safely set new options...
		drop.multi = opts.multi === true ? Infinity : 
			opts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;
		drop.delay = opts.delay || drop.delay;
		drop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance : 
			opts.tolerance === null ? null : drop.tolerance;
		drop.mode = opts.mode || drop.mode || 'intersect';
	};
	
	// local refs (increase compression)
	var $event = $.event, 
	$special = $event.special,
	// configure the drop special event
	drop = $.event.special.drop = {
	
		// these are the default settings
		multi: 1, // allow multiple drop winners per dragged element
		delay: 20, // async timeout delay
		mode: 'overlap', // drop tolerance mode
			
		// internal cache
		targets: [], 
		
		// the key name for stored drop data
		datakey: "dropdata",
			
		// prevent bubbling for better performance
		noBubble: true,
		
		// count bound related events
		add: function( obj ){ 
			// read the interaction data
			var data = $.data( this, drop.datakey );
			// count another realted event
			data.related += 1;
		},
		
		// forget unbound related events
		remove: function(){
			$.data( this, drop.datakey ).related -= 1;
		},
		
		// configure the interactions
		setup: function(){
			// check for related events
			if ( $.data( this, drop.datakey ) ) 
				return;
			// initialize the drop element data
			var data = { 
				related: 0,
				active: [],
				anyactive: 0,
				winner: 0,
				location: {}
			};
			// store the drop data on the element
			$.data( this, drop.datakey, data );
			// store the drop target in internal cache
			drop.targets.push( this );
		},
		
		// destroy the configure interaction	
		teardown: function(){ 
			var data = $.data( this, drop.datakey ) || {};
			// check for related events
			if ( data.related ) 
				return;
			// remove the stored data
			$.removeData( this, drop.datakey );
			// reference the targeted element
			var element = this;
			// remove from the internal cache
			drop.targets = $.grep( drop.targets, function( target ){ 
				return ( target !== element ); 
			});
		},
		
		// shared event handler
		handler: function( event, dd ){ 
			// local vars
			var results, $targets;
			// make sure the right data is available
			if ( !dd ) 
				return;
			// handle various events
			switch ( event.type ){
				// draginit, from $.event.special.drag
				case 'mousedown': // DROPINIT >>
				case 'touchstart': // DROPINIT >>
					// collect and assign the drop targets
					$targets =  $( drop.targets );
					if ( typeof dd.drop == "string" )
						$targets = $targets.filter( dd.drop );
					// reset drop data winner properties
					$targets.each(function(){
						var data = $.data( this, drop.datakey );
						data.active = [];
						data.anyactive = 0;
						data.winner = 0;
					});
					// set available target elements
					dd.droppable = $targets;
					// activate drop targets for the initial element being dragged
					$special.drag.hijack( event, "dropinit", dd ); 
					break;
				// drag, from $.event.special.drag
				case 'mousemove': // TOLERATE >>
				case 'touchmove': // TOLERATE >>
					drop.event = event; // store the mousemove event
					if ( !drop.timer )
						// monitor drop targets
						drop.tolerate( dd ); 
					break;
				// dragend, from $.event.special.drag
				case 'mouseup': // DROP >> DROPEND >>
				case 'touchend': // DROP >> DROPEND >>
					drop.timer = clearTimeout( drop.timer ); // delete timer	
					if ( dd.propagates ){
						$special.drag.hijack( event, "drop", dd ); 
						$special.drag.hijack( event, "dropend", dd ); 
					}
					break;
					
			}
		},
			
		// returns the location positions of an element
		locate: function( elem, index ){ 
			var data = $.data( elem, drop.datakey ),
			$elem = $( elem ), 
			posi = $elem.offset() || {}, 
			height = $elem.outerHeight(), 
			width = $elem.outerWidth(),
			location = { 
				elem: elem, 
				width: width, 
				height: height,
				top: posi.top, 
				left: posi.left, 
				right: posi.left + width, 
				bottom: posi.top + height
			};
			// drag elements might not have dropdata
			if ( data ){
				data.location = location;
				data.index = index;
				data.elem = elem;
			}
			return location;
		},
		
		// test the location positions of an element against another OR an X,Y coord
		contains: function( target, test ){ // target { location } contains test [x,y] or { location }
			return ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right
				&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom ); 
		},
		
		// stored tolerance modes
		modes: { // fn scope: "$.event.special.drop" object 
			// target with mouse wins, else target with most overlap wins
			'intersect': function( event, proxy, target ){
				return this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor
					1e9 : this.modes.overlap.apply( this, arguments ); // check overlap
			},
			// target with most overlap wins	
			'overlap': function( event, proxy, target ){
				// calculate the area of overlap...
				return Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )
					* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );
			},
			// proxy is completely contained within target bounds	
			'fit': function( event, proxy, target ){
				return this.contains( target, proxy ) ? 1 : 0;
			},
			// center of the proxy is contained within target bounds	
			'middle': function( event, proxy, target ){
				return this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;
			}
		},	
		
		// sort drop target cache by by winner (dsc), then index (asc)
		sort: function( a, b ){
			return ( b.winner - a.winner ) || ( a.index - b.index );
		},
			
		// async, recursive tolerance execution
		tolerate: function( dd ){		
			// declare local refs
			var i, drp, drg, data, arr, len, elem,
			// interaction iteration variables
			x = 0, ia, end = dd.interactions.length,
			// determine the mouse coords
			xy = [ drop.event.pageX, drop.event.pageY ],
			// custom or stored tolerance fn
			tolerance = drop.tolerance || drop.modes[ drop.mode ];
			// go through each passed interaction...
			do if ( ia = dd.interactions[x] ){
				// check valid interaction
				if ( !ia )
					return; 
				// initialize or clear the drop data
				ia.drop = [];
				// holds the drop elements
				arr = []; 
				len = ia.droppable.length;
				// determine the proxy location, if needed
				if ( tolerance )
					drg = drop.locate( ia.proxy ); 
				// reset the loop
				i = 0;
				// loop each stored drop target
				do if ( elem = ia.droppable[i] ){ 
					data = $.data( elem, drop.datakey );
					drp = data.location;
					if ( !drp ) continue;
					// find a winner: tolerance function is defined, call it
					data.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp ) 
						// mouse position is always the fallback
						: drop.contains( drp, xy ) ? 1 : 0; 
					arr.push( data );	
				} while ( ++i < len ); // loop 
				// sort the drop targets
				arr.sort( drop.sort );			
				// reset the loop
				i = 0;
				// loop through all of the targets again
				do if ( data = arr[ i ] ){
					// winners...
					if ( data.winner && ia.drop.length < drop.multi ){
						// new winner... dropstart
						if ( !data.active[x] && !data.anyactive ){
							// check to make sure that this is not prevented
							if ( $special.drag.hijack( drop.event, "dropstart", dd, x, data.elem )[0] !== false ){ 	
								data.active[x] = 1;
								data.anyactive += 1;
							}
							// if false, it is not a winner
							else
								data.winner = 0;
						}
						// if it is still a winner
						if ( data.winner )
							ia.drop.push( data.elem );
					}
					// losers... 
					else if ( data.active[x] && data.anyactive == 1 ){
						// former winner... dropend
						$special.drag.hijack( drop.event, "dropend", dd, x, data.elem ); 
						data.active[x] = 0;
						data.anyactive -= 1;
					}
				} while ( ++i < len ); // loop 		
			} while ( ++x < end ) // loop
			// check if the mouse is still moving or is idle
			if ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY ) 
				delete drop.timer; // idle, don't recurse
			else  // recurse
				drop.timer = setTimeout(function(){ 
					drop.tolerate( dd ); 
				}, drop.delay );
			// remember event, to compare idleness
			drop.last = drop.event; 
		}
		
	};
	
	// share the same special event configuration with related events...
	$special.dropinit = $special.dropstart = $special.dropend = drop;
	
	})(jQuery); // confine scope	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/**
	 * @license
	 * (c) 2009-2013 Michael Leibman
	 * michael{dot}leibman{at}gmail{dot}com
	 * http://github.com/mleibman/slickgrid
	 *
	 * Distributed under MIT license.
	 * All rights reserved.
	 *
	 * SlickGrid v2.2
	 *
	 * NOTES:
	 *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.
	 *     This increases the speed dramatically, but can only be done safely because there are no event handlers
	 *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()
	 *     and do proper cleanup.
	 */
	
	// make sure required JavaScript modules are loaded
	if (typeof jQuery === "undefined") {
	  throw "SlickGrid requires jquery module to be loaded";
	}
	if (!jQuery.fn.drag) {
	  throw "SlickGrid requires jquery.event.drag module to be loaded";
	}
	if (typeof Slick === "undefined") {
	  throw "slick.core.js not loaded";
	}
	
	
	(function ($) {
	  // Slick.Grid
	  $.extend(true, window, {
	    Slick: {
	      Grid: SlickGrid
	    }
	  });
	
	  // shared across all grids on the page
	  var scrollbarDimensions;
	  var maxSupportedCssHeight;  // browser's breaking point
	
	  //////////////////////////////////////////////////////////////////////////////////////////////
	  // SlickGrid class implementation (available as Slick.Grid)
	
	  /**
	   * Creates a new instance of the grid.
	   * @class SlickGrid
	   * @constructor
	   * @param {Node}              container   Container node to create the grid in.
	   * @param {Array,Object}      data        An array of objects for databinding.
	   * @param {Array}             columns     An array of column definitions.
	   * @param {Object}            options     Grid options.
	   **/
	  function SlickGrid(container, data, columns, options) {
	    // settings
	    var defaults = {
	      explicitInitialization: false,
	      rowHeight: 25,
	      defaultColumnWidth: 80,
	      enableAddRow: false,
	      leaveSpaceForNewRows: false,
	      editable: false,
	      autoEdit: true,
	      enableCellNavigation: true,
	      enableColumnReorder: true,
	      asyncEditorLoading: false,
	      asyncEditorLoadDelay: 100,
	      forceFitColumns: false,
	      enableAsyncPostRender: false,
	      asyncPostRenderDelay: 50,
	      autoHeight: false,
	      editorLock: Slick.GlobalEditorLock,
	      showHeaderRow: false,
	      headerRowHeight: 25,
	      showTopPanel: false,
	      topPanelHeight: 25,
	      formatterFactory: null,
	      editorFactory: null,
	      cellFlashingCssClass: "flashing",
	      selectedCellCssClass: "selected",
	      multiSelect: true,
	      enableTextSelectionOnCells: false,
	      dataItemColumnValueExtractor: null,
	      fullWidthRows: false,
	      multiColumnSort: false,
	      defaultFormatter: defaultFormatter,
	      forceSyncScrolling: false,
	      addNewRowCssClass: "new-row"
	    };
	
	    var columnDefaults = {
	      name: "",
	      resizable: true,
	      sortable: false,
	      minWidth: 30,
	      rerenderOnResize: false,
	      headerCssClass: null,
	      defaultSortAsc: true,
	      focusable: true,
	      selectable: true
	    };
	
	    // scroller
	    var th;   // virtual height
	    var h;    // real scrollable height
	    var ph;   // page height
	    var n;    // number of pages
	    var cj;   // "jumpiness" coefficient
	
	    var page = 0;       // current page
	    var offset = 0;     // current page offset
	    var vScrollDir = 1;
	
	    // private
	    var initialized = false;
	    var $container;
	    var uid = "slickgrid_" + Math.round(1000000 * Math.random());
	    var self = this;
	    var $focusSink, $focusSink2;
	    var $headerScroller;
	    var $headers;
	    var $headerRow, $headerRowScroller, $headerRowSpacer;
	    var $topPanelScroller;
	    var $topPanel;
	    var $viewport;
	    var $canvas;
	    var $style;
	    var $boundAncestors;
	    var stylesheet, columnCssRulesL, columnCssRulesR;
	    var viewportH, viewportW;
	    var canvasWidth;
	    var viewportHasHScroll, viewportHasVScroll;
	    var headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, // border+padding
	        cellWidthDiff = 0, cellHeightDiff = 0;
	    var absoluteColumnMinWidth;
	
	    var tabbingDirection = 1;
	    var activePosX;
	    var activeRow, activeCell;
	    var activeCellNode = null;
	    var currentEditor = null;
	    var serializedEditorValue;
	    var editController;
	
	    var rowsCache = {};
	    var renderedRows = 0;
	    var numVisibleRows;
	    var prevScrollTop = 0;
	    var scrollTop = 0;
	    var lastRenderedScrollTop = 0;
	    var lastRenderedScrollLeft = 0;
	    var prevScrollLeft = 0;
	    var scrollLeft = 0;
	
	    var selectionModel;
	    var selectedRows = [];
	
	    var plugins = [];
	    var cellCssClasses = {};
	
	    var columnsById = {};
	    var sortColumns = [];
	    var columnPosLeft = [];
	    var columnPosRight = [];
	
	
	    // async call handles
	    var h_editorLoader = null;
	    var h_render = null;
	    var h_postrender = null;
	    var postProcessedRows = {};
	    var postProcessToRow = null;
	    var postProcessFromRow = null;
	
	    // perf counters
	    var counter_rows_rendered = 0;
	    var counter_rows_removed = 0;
	
	    // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.
	    // See http://crbug.com/312427.
	    var rowNodeFromLastMouseWheelEvent;  // this node must not be deleted while inertial scrolling
	    var zombieRowNodeFromLastMouseWheelEvent;  // node that was hidden instead of getting deleted
	
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Initialization
	
	    function init() {
	      $container = $(container);
	      if ($container.length < 1) {
	        throw new Error("SlickGrid requires a valid container, " + container + " does not exist in the DOM.");
	      }
	
	      // calculate these only once and share between grid instances
	      maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();
	      scrollbarDimensions = scrollbarDimensions || measureScrollbar();
	
	      options = $.extend({}, defaults, options);
	      validateAndEnforceOptions();
	      columnDefaults.width = options.defaultColumnWidth;
	
	      columnsById = {};
	      for (var i = 0; i < columns.length; i++) {
	        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);
	        columnsById[m.id] = i;
	        if (m.minWidth && m.width < m.minWidth) {
	          m.width = m.minWidth;
	        }
	        if (m.maxWidth && m.width > m.maxWidth) {
	          m.width = m.maxWidth;
	        }
	      }
	
	      // validate loaded JavaScript modules against requested options
	      if (options.enableColumnReorder && !$.fn.sortable) {
	        throw new Error("SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded");
	      }
	
	      editController = {
	        "commitCurrentEdit": commitCurrentEdit,
	        "cancelCurrentEdit": cancelCurrentEdit
	      };
	
	      $container
	          .empty()
	          .css("overflow", "hidden")
	          .css("outline", 0)
	          .addClass(uid)
	          .addClass("ui-widget");
	
	      // set up a positioning container if needed
	      if (!/relative|absolute|fixed/.test($container.css("position"))) {
	        $container.css("position", "relative");
	      }
	
	      $focusSink = $("<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>").appendTo($container);
	
	      $headerScroller = $("<div class='slick-header ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
	      $headers = $("<div class='slick-header-columns' style='left:-1000px' />").appendTo($headerScroller);
	      $headers.width(getHeadersWidth());
	
	      $headerRowScroller = $("<div class='slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
	      $headerRow = $("<div class='slick-headerrow-columns' />").appendTo($headerRowScroller);
	      $headerRowSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>")
	          .css("width", getCanvasWidth() + scrollbarDimensions.width + "px")
	          .appendTo($headerRowScroller);
	
	      $topPanelScroller = $("<div class='slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
	      $topPanel = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScroller);
	
	      if (!options.showTopPanel) {
	        $topPanelScroller.hide();
	      }
	
	      if (!options.showHeaderRow) {
	        $headerRowScroller.hide();
	      }
	
	      $viewport = $("<div class='slick-viewport-shadow' style='width:100%;height:100%;position:absolute;'></div>").appendTo($container);
	      $viewport = $("<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>").appendTo($container);
	      $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto");
	
	      $canvas = $("<div class='grid-canvas' />").appendTo($viewport);
	
	      $focusSink2 = $focusSink.clone().appendTo($container);
	
	      if (!options.explicitInitialization) {
	        finishInitialization();
	      }
	    }
	
	    function finishInitialization() {
	      if (!initialized) {
	        initialized = true;
	
	        viewportW = parseFloat($.css($container[0], "width", true));
	
	        // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)
	        // calculate the diff so we can set consistent sizes
	        measureCellPaddingAndBorder();
	
	        // for usability reasons, all text selection in SlickGrid is disabled
	        // with the exception of input and textarea elements (selection must
	        // be enabled there so that editors work as expected); note that
	        // selection in grid cells (grid body) is already unavailable in
	        // all browsers except IE
	        disableSelection($headers); // disable all text selection in header (including input and textarea)
	
	        if (!options.enableTextSelectionOnCells) {
	          // disable text selection in grid cells except in input and textarea elements
	          // (this is IE-specific, because selectstart event will only fire in IE)
	          $viewport.bind("selectstart.ui", function (event) {
	            return $(event.target).is("input,textarea");
	          });
	        }
	
	        updateColumnCaches();
	        createColumnHeaders();
	        setupColumnSort();
	        createCssRules();
	        resizeCanvas();
	        bindAncestorScrollEvents();
	
	        $container
	            .bind("resize.slickgrid", resizeCanvas);
	        $viewport
	            //.bind("click", handleClick)
	            .bind("scroll", handleScroll);
	        $headerScroller
	            .bind("contextmenu", handleHeaderContextMenu)
	            .bind("click", handleHeaderClick)
	            .delegate(".slick-header-column", "mouseenter", handleHeaderMouseEnter)
	            .delegate(".slick-header-column", "mouseleave", handleHeaderMouseLeave);
	        $headerRowScroller
	            .bind("scroll", handleHeaderRowScroll);
	        $focusSink.add($focusSink2)
	            .bind("keydown", handleKeyDown);
	        $canvas
	            .bind("keydown", handleKeyDown)
	            .bind("click", handleClick)
	            .bind("dblclick", handleDblClick)
	            .bind("contextmenu", handleContextMenu)
	            .bind("draginit", handleDragInit)
	            .bind("dragstart", {distance: 3}, handleDragStart)
	            .bind("drag", handleDrag)
	            .bind("dragend", handleDragEnd)
	            .delegate(".slick-cell", "mouseenter", handleMouseEnter)
	            .delegate(".slick-cell", "mouseleave", handleMouseLeave);
	
	        // Work around http://crbug.com/312427.
	        if (navigator.userAgent.toLowerCase().match(/webkit/) &&
	            navigator.userAgent.toLowerCase().match(/macintosh/)) {
	          $canvas.bind("mousewheel", handleMouseWheel);
	        }
	      }
	    }
	
	    function registerPlugin(plugin) {
	      plugins.unshift(plugin);
	      plugin.init(self);
	    }
	
	    function unregisterPlugin(plugin) {
	      for (var i = plugins.length; i >= 0; i--) {
	        if (plugins[i] === plugin) {
	          if (plugins[i].destroy) {
	            plugins[i].destroy();
	          }
	          plugins.splice(i, 1);
	          break;
	        }
	      }
	    }
	
	    function setSelectionModel(model) {
	      if (selectionModel) {
	        selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);
	        if (selectionModel.destroy) {
	          selectionModel.destroy();
	        }
	      }
	
	      selectionModel = model;
	      if (selectionModel) {
	        selectionModel.init(self);
	        selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);
	      }
	    }
	
	    function getSelectionModel() {
	      return selectionModel;
	    }
	
	    function getCanvasNode() {
	      return $canvas[0];
	    }
	
	    function measureScrollbar() {
	      var $c = $("<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>")
	      $c.appendTo("body");
	      var dim = {
	        width: $c.width() - $c[0].clientWidth,
	        height: $c.height() - $c[0].clientHeight
	      };
	      $c.remove();
	      return dim;
	    }
	
	    function getHeadersWidth() {
	      var headersWidth = 0;
	      for (var i = 0, ii = columns.length; i < ii; i++) {
	        var width = columns[i].width;
	        headersWidth += width;
	      }
	      headersWidth += scrollbarDimensions.width;
	      return Math.max(headersWidth, viewportW) + 1000;
	    }
	
	    function getCanvasWidth() {
	      var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
	      var rowWidth = 0;
	      var i = columns.length;
	      while (i--) {
	        rowWidth += columns[i].width;
	      }
	      return options.fullWidthRows ? Math.max(rowWidth, availableWidth) : rowWidth;
	    }
	
	    function updateCanvasWidth(forceColumnWidthsUpdate) {
	      var oldCanvasWidth = canvasWidth;
	      canvasWidth = getCanvasWidth();
	
	      if (canvasWidth != oldCanvasWidth) {
	        $canvas.width(canvasWidth);
	        $headerRow.width(canvasWidth);
	        $headers.width(getHeadersWidth());
	        viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);
	      }
	
	      $headerRowSpacer.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));
	
	      if (canvasWidth != oldCanvasWidth || forceColumnWidthsUpdate) {
	        applyColumnWidths();
	      }
	    }
	
	    function disableSelection($target) {
	      if ($target && $target.jquery) {
	        $target
	            .attr("unselectable", "on")
	            .css("MozUserSelect", "none")
	            .bind("selectstart.ui", function () {
	              return false;
	            }); // from jquery:ui.core.js 1.7.2
	      }
	    }
	
	    function getMaxSupportedCssHeight() {
	      var supportedHeight = 1000000;
	      // FF reports the height back but still renders blank after ~6M px
	      var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;
	      var div = $("<div style='display:none' />").appendTo(document.body);
	
	      while (true) {
	        var test = supportedHeight * 2;
	        div.css("height", test);
	        if (test > testUpTo || div.height() !== test) {
	          break;
	        } else {
	          supportedHeight = test;
	        }
	      }
	
	      div.remove();
	      return supportedHeight;
	    }
	
	    // TODO:  this is static.  need to handle page mutation.
	    function bindAncestorScrollEvents() {
	      var elem = $canvas[0];
	      while ((elem = elem.parentNode) != document.body && elem != null) {
	        // bind to scroll containers only
	        if (elem == $viewport[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {
	          var $elem = $(elem);
	          if (!$boundAncestors) {
	            $boundAncestors = $elem;
	          } else {
	            $boundAncestors = $boundAncestors.add($elem);
	          }
	          $elem.bind("scroll." + uid, handleActiveCellPositionChange);
	        }
	      }
	    }
	
	    function unbindAncestorScrollEvents() {
	      if (!$boundAncestors) {
	        return;
	      }
	      $boundAncestors.unbind("scroll." + uid);
	      $boundAncestors = null;
	    }
	
	    function updateColumnHeader(columnId, title, toolTip) {
	      if (!initialized) { return; }
	      var idx = getColumnIndex(columnId);
	      if (idx == null) {
	        return;
	      }
	
	      var columnDef = columns[idx];
	      var $header = $headers.children().eq(idx);
	      if ($header) {
	        if (title !== undefined) {
	          columns[idx].name = title;
	        }
	        if (toolTip !== undefined) {
	          columns[idx].toolTip = toolTip;
	        }
	
	        trigger(self.onBeforeHeaderCellDestroy, {
	          "node": $header[0],
	          "column": columnDef
	        });
	
	        $header
	            .attr("title", toolTip || "")
	            .children().eq(0).html(title);
	
	        trigger(self.onHeaderCellRendered, {
	          "node": $header[0],
	          "column": columnDef
	        });
	      }
	    }
	
	    function getHeaderRow() {
	      return $headerRow[0];
	    }
	
	    function getHeaderRowColumn(columnId) {
	      var idx = getColumnIndex(columnId);
	      var $header = $headerRow.children().eq(idx);
	      return $header && $header[0];
	    }
	
	    function createColumnHeaders() {
	      function onMouseEnter() {
	        $(this).addClass("ui-state-hover");
	      }
	
	      function onMouseLeave() {
	        $(this).removeClass("ui-state-hover");
	      }
	
	      $headers.find(".slick-header-column")
	        .each(function() {
	          var columnDef = $(this).data("column");
	          if (columnDef) {
	            trigger(self.onBeforeHeaderCellDestroy, {
	              "node": this,
	              "column": columnDef
	            });
	          }
	        });
	      $headers.empty();
	      $headers.width(getHeadersWidth());
	
	      $headerRow.find(".slick-headerrow-column")
	        .each(function() {
	          var columnDef = $(this).data("column");
	          if (columnDef) {
	            trigger(self.onBeforeHeaderRowCellDestroy, {
	              "node": this,
	              "column": columnDef
	            });
	          }
	        });
	      $headerRow.empty();
	
	      for (var i = 0; i < columns.length; i++) {
	        var m = columns[i];
	
	        var header = $("<div class='ui-state-default slick-header-column' />")
	            .html("<span class='slick-column-name'>" + m.name + "</span>")
	            .width(m.width - headerColumnWidthDiff)
	            .attr("id", "" + uid + m.id)
	            .attr("title", m.toolTip || "")
	            .data("column", m)
	            .addClass(m.headerCssClass || "")
	            .appendTo($headers);
	
	        if (options.enableColumnReorder || m.sortable) {
	          header
	            .on('mouseenter', onMouseEnter)
	            .on('mouseleave', onMouseLeave);
	        }
	
	        if (m.sortable) {
	          header.addClass("slick-header-sortable");
	          header.append("<span class='slick-sort-indicator' />");
	        }
	
	        trigger(self.onHeaderCellRendered, {
	          "node": header[0],
	          "column": m
	        });
	
	        if (options.showHeaderRow) {
	          var headerRowCell = $("<div class='ui-state-default slick-headerrow-column l" + i + " r" + i + "'></div>")
	              .data("column", m)
	              .appendTo($headerRow);
	
	          trigger(self.onHeaderRowCellRendered, {
	            "node": headerRowCell[0],
	            "column": m
	          });
	        }
	      }
	
	      setSortColumns(sortColumns);
	      setupColumnResize();
	      if (options.enableColumnReorder) {
	        setupColumnReorder();
	      }
	    }
	
	    function setupColumnSort() {
	      $headers.click(function (e) {
	        // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)
	        e.metaKey = e.metaKey || e.ctrlKey;
	
	        if ($(e.target).hasClass("slick-resizable-handle")) {
	          return;
	        }
	
	        var $col = $(e.target).closest(".slick-header-column");
	        if (!$col.length) {
	          return;
	        }
	
	        var column = $col.data("column");
	        if (column.sortable) {
	          if (!getEditorLock().commitCurrentEdit()) {
	            return;
	          }
	
	          var sortOpts = null;
	          var i = 0;
	          for (; i < sortColumns.length; i++) {
	            if (sortColumns[i].columnId == column.id) {
	              sortOpts = sortColumns[i];
	              sortOpts.sortAsc = !sortOpts.sortAsc;
	              break;
	            }
	          }
	
	          if (e.metaKey && options.multiColumnSort) {
	            if (sortOpts) {
	              sortColumns.splice(i, 1);
	            }
	          }
	          else {
	            if ((!e.shiftKey && !e.metaKey) || !options.multiColumnSort) {
	              sortColumns = [];
	            }
	
	            if (!sortOpts) {
	              sortOpts = { columnId: column.id, sortAsc: column.defaultSortAsc };
	              sortColumns.push(sortOpts);
	            } else if (sortColumns.length == 0) {
	              sortColumns.push(sortOpts);
	            }
	          }
	
	          setSortColumns(sortColumns);
	
	          if (!options.multiColumnSort) {
	            trigger(self.onSort, {
	              multiColumnSort: false,
	              sortCol: column,
	              sortAsc: sortOpts.sortAsc}, e);
	          } else {
	            trigger(self.onSort, {
	              multiColumnSort: true,
	              sortCols: $.map(sortColumns, function(col) {
	                return {sortCol: columns[getColumnIndex(col.columnId)], sortAsc: col.sortAsc };
	              })}, e);
	          }
	        }
	      });
	    }
	
	    function setupColumnReorder() {
	      $headers.filter(":ui-sortable").sortable("destroy");
	      $headers.sortable({
	        containment: "parent",
	        distance: 3,
	        axis: "x",
	        cursor: "default",
	        tolerance: "intersection",
	        helper: "clone",
	        placeholder: "slick-sortable-placeholder ui-state-default slick-header-column",
	        start: function (e, ui) {
	          ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);
	          $(ui.helper).addClass("slick-header-column-active");
	        },
	        beforeStop: function (e, ui) {
	          $(ui.helper).removeClass("slick-header-column-active");
	        },
	        stop: function (e) {
	          if (!getEditorLock().commitCurrentEdit()) {
	            $(this).sortable("cancel");
	            return;
	          }
	
	          var reorderedIds = $headers.sortable("toArray");
	          var reorderedColumns = [];
	          for (var i = 0; i < reorderedIds.length; i++) {
	            reorderedColumns.push(columns[getColumnIndex(reorderedIds[i].replace(uid, ""))]);
	          }
	          setColumns(reorderedColumns);
	
	          trigger(self.onColumnsReordered, {});
	          e.stopPropagation();
	          setupColumnResize();
	        }
	      });
	    }
	
	    function setupColumnResize() {
	      var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;
	      columnElements = $headers.children();
	      columnElements.find(".slick-resizable-handle").remove();
	      columnElements.each(function (i, e) {
	        if (columns[i].resizable) {
	          if (firstResizable === undefined) {
	            firstResizable = i;
	          }
	          lastResizable = i;
	        }
	      });
	      if (firstResizable === undefined) {
	        return;
	      }
	      columnElements.each(function (i, e) {
	        if (i < firstResizable || (options.forceFitColumns && i >= lastResizable)) {
	          return;
	        }
	        $col = $(e);
	        $("<div class='slick-resizable-handle' />")
	            .appendTo(e)
	            .bind("dragstart", function (e, dd) {
	              if (!getEditorLock().commitCurrentEdit()) {
	                return false;
	              }
	              pageX = e.pageX;
	              $(this).parent().addClass("slick-header-column-active");
	              var shrinkLeewayOnRight = null, stretchLeewayOnRight = null;
	              // lock each column's width option to current width
	              columnElements.each(function (i, e) {
	                columns[i].previousWidth = $(e).outerWidth();
	              });
	              if (options.forceFitColumns) {
	                shrinkLeewayOnRight = 0;
	                stretchLeewayOnRight = 0;
	                // colums on right affect maxPageX/minPageX
	                for (j = i + 1; j < columnElements.length; j++) {
	                  c = columns[j];
	                  if (c.resizable) {
	                    if (stretchLeewayOnRight !== null) {
	                      if (c.maxWidth) {
	                        stretchLeewayOnRight += c.maxWidth - c.previousWidth;
	                      } else {
	                        stretchLeewayOnRight = null;
	                      }
	                    }
	                    shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
	                  }
	                }
	              }
	              var shrinkLeewayOnLeft = 0, stretchLeewayOnLeft = 0;
	              for (j = 0; j <= i; j++) {
	                // columns on left only affect minPageX
	                c = columns[j];
	                if (c.resizable) {
	                  if (stretchLeewayOnLeft !== null) {
	                    if (c.maxWidth) {
	                      stretchLeewayOnLeft += c.maxWidth - c.previousWidth;
	                    } else {
	                      stretchLeewayOnLeft = null;
	                    }
	                  }
	                  shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
	                }
	              }
	              if (shrinkLeewayOnRight === null) {
	                shrinkLeewayOnRight = 100000;
	              }
	              if (shrinkLeewayOnLeft === null) {
	                shrinkLeewayOnLeft = 100000;
	              }
	              if (stretchLeewayOnRight === null) {
	                stretchLeewayOnRight = 100000;
	              }
	              if (stretchLeewayOnLeft === null) {
	                stretchLeewayOnLeft = 100000;
	              }
	              maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);
	              minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);
	            })
	            .bind("drag", function (e, dd) {
	              var actualMinWidth, d = Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX, x;
	              if (d < 0) { // shrink column
	                x = d;
	                for (j = i; j >= 0; j--) {
	                  c = columns[j];
	                  if (c.resizable) {
	                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
	                    if (x && c.previousWidth + x < actualMinWidth) {
	                      x += c.previousWidth - actualMinWidth;
	                      c.width = actualMinWidth;
	                    } else {
	                      c.width = c.previousWidth + x;
	                      x = 0;
	                    }
	                  }
	                }
	
	                if (options.forceFitColumns) {
	                  x = -d;
	                  for (j = i + 1; j < columnElements.length; j++) {
	                    c = columns[j];
	                    if (c.resizable) {
	                      if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {
	                        x -= c.maxWidth - c.previousWidth;
	                        c.width = c.maxWidth;
	                      } else {
	                        c.width = c.previousWidth + x;
	                        x = 0;
	                      }
	                    }
	                  }
	                }
	              } else { // stretch column
	                x = d;
	                for (j = i; j >= 0; j--) {
	                  c = columns[j];
	                  if (c.resizable) {
	                    if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {
	                      x -= c.maxWidth - c.previousWidth;
	                      c.width = c.maxWidth;
	                    } else {
	                      c.width = c.previousWidth + x;
	                      x = 0;
	                    }
	                  }
	                }
	
	                if (options.forceFitColumns) {
	                  x = -d;
	                  for (j = i + 1; j < columnElements.length; j++) {
	                    c = columns[j];
	                    if (c.resizable) {
	                      actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
	                      if (x && c.previousWidth + x < actualMinWidth) {
	                        x += c.previousWidth - actualMinWidth;
	                        c.width = actualMinWidth;
	                      } else {
	                        c.width = c.previousWidth + x;
	                        x = 0;
	                      }
	                    }
	                  }
	                }
	              }
	              applyColumnHeaderWidths();
	              if (options.syncColumnCellResize) {
	                applyColumnWidths();
	              }
	            })
	            .bind("dragend", function (e, dd) {
	              var newWidth;
	              $(this).parent().removeClass("slick-header-column-active");
	              for (j = 0; j < columnElements.length; j++) {
	                c = columns[j];
	                newWidth = $(columnElements[j]).outerWidth();
	
	                if (c.previousWidth !== newWidth && c.rerenderOnResize) {
	                  invalidateAllRows();
	                }
	              }
	              updateCanvasWidth(true);
	              render();
	              trigger(self.onColumnsResized, {});
	            });
	      });
	    }
	
	    function getVBoxDelta($el) {
	      var p = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
	      var delta = 0;
	      $.each(p, function (n, val) {
	        delta += parseFloat($el.css(val)) || 0;
	      });
	      return delta;
	    }
	
	    function measureCellPaddingAndBorder() {
	      var el;
	      var h = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"];
	      var v = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
	
	      el = $("<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>").appendTo($headers);
	      headerColumnWidthDiff = headerColumnHeightDiff = 0;
	      if (el.css("box-sizing") != "border-box" && el.css("-moz-box-sizing") != "border-box" && el.css("-webkit-box-sizing") != "border-box") {
	        $.each(h, function (n, val) {
	          headerColumnWidthDiff += parseFloat(el.css(val)) || 0;
	        });
	        $.each(v, function (n, val) {
	          headerColumnHeightDiff += parseFloat(el.css(val)) || 0;
	        });
	      }
	      el.remove();
	
	      var r = $("<div class='slick-row' />").appendTo($canvas);
	      el = $("<div class='slick-cell' id='' style='visibility:hidden'>-</div>").appendTo(r);
	      cellWidthDiff = cellHeightDiff = 0;
	      if (el.css("box-sizing") != "border-box" && el.css("-moz-box-sizing") != "border-box" && el.css("-webkit-box-sizing") != "border-box") {
	        $.each(h, function (n, val) {
	          cellWidthDiff += parseFloat(el.css(val)) || 0;
	        });
	        $.each(v, function (n, val) {
	          cellHeightDiff += parseFloat(el.css(val)) || 0;
	        });
	      }
	      r.remove();
	
	      absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);
	    }
	
	    function createCssRules() {
	      $style = $("<style type='text/css' rel='stylesheet' />").appendTo($("head"));
	      var rowHeight = (options.rowHeight - cellHeightDiff);
	      var rules = [
	        "." + uid + " .slick-header-column { left: 1000px; }",
	        "." + uid + " .slick-top-panel { height:" + options.topPanelHeight + "px; }",
	        "." + uid + " .slick-headerrow-columns { height:" + options.headerRowHeight + "px; }",
	        "." + uid + " .slick-cell { height:" + rowHeight + "px; }",
	        "." + uid + " .slick-row { height:" + options.rowHeight + "px; }"
	      ];
	
	      for (var i = 0; i < columns.length; i++) {
	        rules.push("." + uid + " .l" + i + " { }");
	        rules.push("." + uid + " .r" + i + " { }");
	      }
	
	      if ($style[0].styleSheet) { // IE
	        $style[0].styleSheet.cssText = rules.join(" ");
	      } else {
	        $style[0].appendChild(document.createTextNode(rules.join(" ")));
	      }
	    }
	
	    function getColumnCssRules(idx) {
	      if (!stylesheet) {
	        var sheets = document.styleSheets;
	        for (var i = 0; i < sheets.length; i++) {
	          if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {
	            stylesheet = sheets[i];
	            break;
	          }
	        }
	
	        if (!stylesheet) {
	          throw new Error("Cannot find stylesheet.");
	        }
	
	        // find and cache column CSS rules
	        columnCssRulesL = [];
	        columnCssRulesR = [];
	        var cssRules = (stylesheet.cssRules || stylesheet.rules);
	        var matches, columnIdx;
	        for (var i = 0; i < cssRules.length; i++) {
	          var selector = cssRules[i].selectorText;
	          if (matches = /\.l\d+/.exec(selector)) {
	            columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
	            columnCssRulesL[columnIdx] = cssRules[i];
	          } else if (matches = /\.r\d+/.exec(selector)) {
	            columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
	            columnCssRulesR[columnIdx] = cssRules[i];
	          }
	        }
	      }
	
	      return {
	        "left": columnCssRulesL[idx],
	        "right": columnCssRulesR[idx]
	      };
	    }
	
	    function removeCssRules() {
	      $style.remove();
	      stylesheet = null;
	    }
	
	    function destroy() {
	      getEditorLock().cancelCurrentEdit();
	
	      trigger(self.onBeforeDestroy, {});
	
	      var i = plugins.length;
	      while(i--) {
	        unregisterPlugin(plugins[i]);
	      }
	
	      if (options.enableColumnReorder) {
	          $headers.filter(":ui-sortable").sortable("destroy");
	      }
	
	      unbindAncestorScrollEvents();
	      $container.unbind(".slickgrid");
	      removeCssRules();
	
	      $canvas.unbind("draginit dragstart dragend drag");
	      $container.empty().removeClass(uid);
	    }
	
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // General
	
	    function trigger(evt, args, e) {
	      e = e || new Slick.EventData();
	      args = args || {};
	      args.grid = self;
	      return evt.notify(args, e, self);
	    }
	
	    function getEditorLock() {
	      return options.editorLock;
	    }
	
	    function getEditController() {
	      return editController;
	    }
	
	    function getColumnIndex(id) {
	      return columnsById[id];
	    }
	
	    function autosizeColumns() {
	      var i, c,
	          widths = [],
	          shrinkLeeway = 0,
	          total = 0,
	          prevTotal,
	          availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
	
	      for (i = 0; i < columns.length; i++) {
	        c = columns[i];
	        widths.push(c.width);
	        total += c.width;
	        if (c.resizable) {
	          shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);
	        }
	      }
	
	      // shrink
	      prevTotal = total;
	      while (total > availWidth && shrinkLeeway) {
	        var shrinkProportion = (total - availWidth) / shrinkLeeway;
	        for (i = 0; i < columns.length && total > availWidth; i++) {
	          c = columns[i];
	          var width = widths[i];
	          if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {
	            continue;
	          }
	          var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);
	          var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;
	          shrinkSize = Math.min(shrinkSize, width - absMinWidth);
	          total -= shrinkSize;
	          shrinkLeeway -= shrinkSize;
	          widths[i] -= shrinkSize;
	        }
	        if (prevTotal <= total) {  // avoid infinite loop
	          break;
	        }
	        prevTotal = total;
	      }
	
	      // grow
	      prevTotal = total;
	      while (total < availWidth) {
	        var growProportion = availWidth / total;
	        for (i = 0; i < columns.length && total < availWidth; i++) {
	          c = columns[i];
	          var currentWidth = widths[i];
	          var growSize;
	
	          if (!c.resizable || c.maxWidth <= currentWidth) {
	            growSize = 0;
	          } else {
	            growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, (c.maxWidth - currentWidth) || 1000000) || 1;
	          }
	          total += growSize;
	          widths[i] += growSize;
	        }
	        if (prevTotal >= total) {  // avoid infinite loop
	          break;
	        }
	        prevTotal = total;
	      }
	
	      var reRender = false;
	      for (i = 0; i < columns.length; i++) {
	        if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {
	          reRender = true;
	        }
	        columns[i].width = widths[i];
	      }
	
	      applyColumnHeaderWidths();
	      updateCanvasWidth(true);
	      if (reRender) {
	        invalidateAllRows();
	        render();
	      }
	    }
	
	    function applyColumnHeaderWidths() {
	      if (!initialized) { return; }
	      var h;
	      for (var i = 0, headers = $headers.children(), ii = headers.length; i < ii; i++) {
	        h = $(headers[i]);
	        if (h.width() !== columns[i].width - headerColumnWidthDiff) {
	          h.width(columns[i].width - headerColumnWidthDiff);
	        }
	      }
	
	      updateColumnCaches();
	    }
	
	    function applyColumnWidths() {
	      var x = 0, w, rule;
	      for (var i = 0; i < columns.length; i++) {
	        w = columns[i].width;
	
	        rule = getColumnCssRules(i);
	        rule.left.style.left = x + "px";
	        rule.right.style.right = (canvasWidth - x - w) + "px";
	
	        x += columns[i].width;
	      }
	    }
	
	    function setSortColumn(columnId, ascending) {
	      setSortColumns([{ columnId: columnId, sortAsc: ascending}]);
	    }
	
	    function setSortColumns(cols) {
	      sortColumns = cols;
	
	      var headerColumnEls = $headers.children();
	      headerColumnEls
	          .removeClass("slick-header-column-sorted")
	          .find(".slick-sort-indicator")
	              .removeClass("slick-sort-indicator-asc slick-sort-indicator-desc");
	
	      $.each(sortColumns, function(i, col) {
	        if (col.sortAsc == null) {
	          col.sortAsc = true;
	        }
	        var columnIndex = getColumnIndex(col.columnId);
	        if (columnIndex != null) {
	          headerColumnEls.eq(columnIndex)
	              .addClass("slick-header-column-sorted")
	              .find(".slick-sort-indicator")
	                  .addClass(col.sortAsc ? "slick-sort-indicator-asc" : "slick-sort-indicator-desc");
	        }
	      });
	    }
	
	    function getSortColumns() {
	      return sortColumns;
	    }
	
	    function handleSelectedRangesChanged(e, ranges) {
	      selectedRows = [];
	      var hash = {};
	      for (var i = 0; i < ranges.length; i++) {
	        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {
	          if (!hash[j]) {  // prevent duplicates
	            selectedRows.push(j);
	            hash[j] = {};
	          }
	          for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {
	            if (canCellBeSelected(j, k)) {
	              hash[j][columns[k].id] = options.selectedCellCssClass;
	            }
	          }
	        }
	      }
	
	      setCellCssStyles(options.selectedCellCssClass, hash);
	
	      trigger(self.onSelectedRowsChanged, {rows: getSelectedRows()}, e);
	    }
	
	    function getColumns() {
	      return columns;
	    }
	
	    function updateColumnCaches() {
	      // Pre-calculate cell boundaries.
	      columnPosLeft = [];
	      columnPosRight = [];
	      var x = 0;
	      for (var i = 0, ii = columns.length; i < ii; i++) {
	        columnPosLeft[i] = x;
	        columnPosRight[i] = x + columns[i].width;
	        x += columns[i].width;
	      }
	    }
	
	    function setColumns(columnDefinitions) {
	      columns = columnDefinitions;
	
	      columnsById = {};
	      for (var i = 0; i < columns.length; i++) {
	        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);
	        columnsById[m.id] = i;
	        if (m.minWidth && m.width < m.minWidth) {
	          m.width = m.minWidth;
	        }
	        if (m.maxWidth && m.width > m.maxWidth) {
	          m.width = m.maxWidth;
	        }
	      }
	
	      updateColumnCaches();
	
	      if (initialized) {
	        invalidateAllRows();
	        createColumnHeaders();
	        removeCssRules();
	        createCssRules();
	        resizeCanvas();
	        applyColumnWidths();
	        handleScroll();
	      }
	    }
	
	    function getOptions() {
	      return options;
	    }
	
	    function setOptions(args) {
	      if (!getEditorLock().commitCurrentEdit()) {
	        return;
	      }
	
	      makeActiveCellNormal();
	
	      if (options.enableAddRow !== args.enableAddRow) {
	        invalidateRow(getDataLength());
	      }
	
	      options = $.extend(options, args);
	      validateAndEnforceOptions();
	
	      $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto");
	      render();
	    }
	
	    function validateAndEnforceOptions() {
	      if (options.autoHeight) {
	        options.leaveSpaceForNewRows = false;
	      }
	    }
	
	    function setData(newData, scrollToTop) {
	      data = newData;
	      invalidateAllRows();
	      updateRowCount();
	      if (scrollToTop) {
	        scrollTo(0);
	      }
	    }
	
	    function getData() {
	      return data;
	    }
	
	    function getDataLength() {
	      if (data.getLength) {
	        return data.getLength();
	      } else {
	        return data.length;
	      }
	    }
	
	    function getDataLengthIncludingAddNew() {
	      return getDataLength() + (options.enableAddRow ? 1 : 0);
	    }
	
	    function getDataItem(i) {
	      if (data.getItem) {
	        return data.getItem(i);
	      } else {
	        return data[i];
	      }
	    }
	
	    function getTopPanel() {
	      return $topPanel[0];
	    }
	
	    function setTopPanelVisibility(visible) {
	      if (options.showTopPanel != visible) {
	        options.showTopPanel = visible;
	        if (visible) {
	          $topPanelScroller.slideDown("fast", resizeCanvas);
	        } else {
	          $topPanelScroller.slideUp("fast", resizeCanvas);
	        }
	      }
	    }
	
	    function setHeaderRowVisibility(visible) {
	      if (options.showHeaderRow != visible) {
	        options.showHeaderRow = visible;
	        if (visible) {
	          $headerRowScroller.slideDown("fast", resizeCanvas);
	        } else {
	          $headerRowScroller.slideUp("fast", resizeCanvas);
	        }
	      }
	    }
	
	    function getContainerNode() {
	      return $container.get(0);
	    }
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Rendering / Scrolling
	
	    function getRowTop(row) {
	      return options.rowHeight * row - offset;
	    }
	
	    function getRowFromPosition(y) {
	      return Math.floor((y + offset) / options.rowHeight);
	    }
	
	    function scrollTo(y) {
	      y = Math.max(y, 0);
	      y = Math.min(y, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0));
	
	      var oldOffset = offset;
	
	      page = Math.min(n - 1, Math.floor(y / ph));
	      offset = Math.round(page * cj);
	      var newScrollTop = y - offset;
	
	      if (offset != oldOffset) {
	        var range = getVisibleRange(newScrollTop);
	        cleanupRows(range);
	        updateRowPositions();
	      }
	
	      if (prevScrollTop != newScrollTop) {
	        vScrollDir = (prevScrollTop + oldOffset < newScrollTop + offset) ? 1 : -1;
	        $viewport[0].scrollTop = (lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop);
	
	        trigger(self.onViewportChanged, {});
	      }
	    }
	
	    function defaultFormatter(row, cell, value, columnDef, dataContext) {
	      if (value == null) {
	        return "";
	      } else {
	        return (value + "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
	      }
	    }
	
	    function getFormatter(row, column) {
	      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
	
	      // look up by id, then index
	      var columnOverrides = rowMetadata &&
	          rowMetadata.columns &&
	          (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);
	
	      return (columnOverrides && columnOverrides.formatter) ||
	          (rowMetadata && rowMetadata.formatter) ||
	          column.formatter ||
	          (options.formatterFactory && options.formatterFactory.getFormatter(column)) ||
	          options.defaultFormatter;
	    }
	
	    function getEditor(row, cell) {
	      var column = columns[cell];
	      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
	      var columnMetadata = rowMetadata && rowMetadata.columns;
	
	      if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {
	        return columnMetadata[column.id].editor;
	      }
	      if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {
	        return columnMetadata[cell].editor;
	      }
	
	      return column.editor || (options.editorFactory && options.editorFactory.getEditor(column));
	    }
	
	    function getDataItemValueForColumn(item, columnDef) {
	      if (options.dataItemColumnValueExtractor) {
	        return options.dataItemColumnValueExtractor(item, columnDef);
	      }
	      return item[columnDef.field];
	    }
	
	    function appendRowHtml(stringArray, row, range, dataLength) {
	      var d = getDataItem(row);
	      var dataLoading = row < dataLength && !d;
	      var rowCss = "slick-row" +
	          (dataLoading ? " loading" : "") +
	          (row === activeRow ? " active" : "") +
	          (row % 2 == 1 ? " odd" : " even");
	
	      if (!d) {
	        rowCss += " " + options.addNewRowCssClass;
	      }
	
	      var metadata = data.getItemMetadata && data.getItemMetadata(row);
	
	      if (metadata && metadata.cssClasses) {
	        rowCss += " " + metadata.cssClasses;
	      }
	
	      stringArray.push("<div class='ui-widget-content " + rowCss + "' style='top:" + getRowTop(row) + "px'>");
	
	      var colspan, m;
	      for (var i = 0, ii = columns.length; i < ii; i++) {
	        m = columns[i];
	        colspan = 1;
	        if (metadata && metadata.columns) {
	          var columnData = metadata.columns[m.id] || metadata.columns[i];
	          colspan = (columnData && columnData.colspan) || 1;
	          if (colspan === "*") {
	            colspan = ii - i;
	          }
	        }
	
	        // Do not render cells outside of the viewport.
	        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {
	          if (columnPosLeft[i] > range.rightPx) {
	            // All columns to the right are outside the range.
	            break;
	          }
	
	          appendCellHtml(stringArray, row, i, colspan, d);
	        }
	
	        if (colspan > 1) {
	          i += (colspan - 1);
	        }
	      }
	
	      stringArray.push("</div>");
	    }
	
	    function appendCellHtml(stringArray, row, cell, colspan, item) {
	      var m = columns[cell];
	      var cellCss = "slick-cell l" + cell + " r" + Math.min(columns.length - 1, cell + colspan - 1) +
	          (m.cssClass ? " " + m.cssClass : "");
	      if (row === activeRow && cell === activeCell) {
	        cellCss += (" active");
	      }
	
	      // TODO:  merge them together in the setter
	      for (var key in cellCssClasses) {
	        if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {
	          cellCss += (" " + cellCssClasses[key][row][m.id]);
	        }
	      }
	
	      stringArray.push("<div class='" + cellCss + "'>");
	
	      // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)
	      if (item) {
	        var value = getDataItemValueForColumn(item, m);
	        stringArray.push(getFormatter(row, m)(row, cell, value, m, item));
	      }
	
	      stringArray.push("</div>");
	
	      rowsCache[row].cellRenderQueue.push(cell);
	      rowsCache[row].cellColSpans[cell] = colspan;
	    }
	
	
	    function cleanupRows(rangeToKeep) {
	      for (var i in rowsCache) {
	        if (((i = parseInt(i, 10)) !== activeRow) && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {
	          removeRowFromCache(i);
	        }
	      }
	    }
	
	    function invalidate() {
	      updateRowCount();
	      invalidateAllRows();
	      render();
	    }
	
	    function invalidateAllRows() {
	      if (currentEditor) {
	        makeActiveCellNormal();
	      }
	      for (var row in rowsCache) {
	        removeRowFromCache(row);
	      }
	    }
	
	    function scrollToLastRendered() {
	      if (lastRenderedScrollTop) {
	        prevScrollTop = 0;
	        scrollTo(lastRenderedScrollTop);
	      }
	    }
	
	    function removeRowFromCache(row) {
	      var cacheEntry = rowsCache[row];
	      if (!cacheEntry) {
	        return;
	      }
	
	      if (rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode) {
	        cacheEntry.rowNode.style.display = 'none';
	        zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent;
	      } else {
	        $canvas[0].removeChild(cacheEntry.rowNode);
	      }
	
	      delete rowsCache[row];
	      delete postProcessedRows[row];
	      renderedRows--;
	      counter_rows_removed++;
	    }
	
	    function invalidateRows(rows) {
	      var i, rl;
	      if (!rows || !rows.length) {
	        return;
	      }
	      vScrollDir = 0;
	      for (i = 0, rl = rows.length; i < rl; i++) {
	        if (currentEditor && activeRow === rows[i]) {
	          makeActiveCellNormal();
	        }
	        if (rowsCache[rows[i]]) {
	          removeRowFromCache(rows[i]);
	        }
	      }
	    }
	
	    function invalidateRow(row) {
	      invalidateRows([row]);
	    }
	
	    function updateCell(row, cell) {
	      var cellNode = getCellNode(row, cell);
	      if (!cellNode) {
	        return;
	      }
	
	      var m = columns[cell], d = getDataItem(row);
	      if (currentEditor && activeRow === row && activeCell === cell) {
	        currentEditor.loadValue(d);
	      } else {
	        cellNode.innerHTML = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d) : "";
	        invalidatePostProcessingResults(row);
	      }
	    }
	
	    function updateRow(row) {
	      var cacheEntry = rowsCache[row];
	      if (!cacheEntry) {
	        return;
	      }
	
	      ensureCellNodesInRowsCache(row);
	
	      var d = getDataItem(row);
	
	      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
	        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {
	          continue;
	        }
	
	        columnIdx = columnIdx | 0;
	        var m = columns[columnIdx],
	            node = cacheEntry.cellNodesByColumnIdx[columnIdx];
	
	        if (row === activeRow && columnIdx === activeCell && currentEditor) {
	          currentEditor.loadValue(d);
	        } else if (d) {
	          node.innerHTML = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d);
	        } else {
	          node.innerHTML = "";
	        }
	      }
	
	      invalidatePostProcessingResults(row);
	    }
	
	    function getViewportHeight() {
	      return parseFloat($.css($container[0], "height", true)) -
	          parseFloat($.css($container[0], "paddingTop", true)) -
	          parseFloat($.css($container[0], "paddingBottom", true)) -
	          parseFloat($.css($headerScroller[0], "height")) - getVBoxDelta($headerScroller) -
	          (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) -
	          (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0);
	    }
	
	    function resizeCanvas() {
	      if (!initialized) { return; }
	      if (options.autoHeight) {
	        viewportH = options.rowHeight * getDataLengthIncludingAddNew();
	      } else {
	        viewportH = getViewportHeight();
	      }
	
	      numVisibleRows = Math.ceil(viewportH / options.rowHeight);
	      viewportW = parseFloat($.css($container[0], "width", true));
	      if (!options.autoHeight) {
	        $viewport.height(viewportH);
	      }
	
	      if (options.forceFitColumns) {
	        autosizeColumns();
	      }
	
	      updateRowCount();
	      handleScroll();
	      // Since the width has changed, force the render() to reevaluate virtually rendered cells.
	      lastRenderedScrollLeft = -1;
	      render();
	    }
	
	    function updateRowCount() {
	      if (!initialized) { return; }
	
	      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
	      var numberOfRows = dataLengthIncludingAddNew +
	          (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);
	
	      var oldViewportHasVScroll = viewportHasVScroll;
	      // with autoHeight, we do not need to accommodate the vertical scroll bar
	      viewportHasVScroll = !options.autoHeight && (numberOfRows * options.rowHeight > viewportH);
	
	      makeActiveCellNormal();
	
	      // remove the rows that are now outside of the data range
	      // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows
	      var l = dataLengthIncludingAddNew - 1;
	      for (var i in rowsCache) {
	        if (i >= l) {
	          removeRowFromCache(i);
	        }
	      }
	
	      if (activeCellNode && activeRow > l) {
	        resetActiveCell();
	      }
	
	      var oldH = h;
	      th = Math.max(options.rowHeight * numberOfRows, viewportH - scrollbarDimensions.height);
	      if (th < maxSupportedCssHeight) {
	        // just one page
	        h = ph = th;
	        n = 1;
	        cj = 0;
	      } else {
	        // break into pages
	        h = maxSupportedCssHeight;
	        ph = h / 100;
	        n = Math.floor(th / ph);
	        cj = (th - h) / (n - 1);
	      }
	
	      if (h !== oldH) {
	        $canvas.css("height", h);
	        scrollTop = $viewport[0].scrollTop;
	      }
	
	      var oldScrollTopInRange = (scrollTop + offset <= th - viewportH);
	
	      if (th == 0 || scrollTop == 0) {
	        page = offset = 0;
	      } else if (oldScrollTopInRange) {
	        // maintain virtual position
	        scrollTo(scrollTop + offset);
	      } else {
	        // scroll to bottom
	        scrollTo(th - viewportH);
	      }
	
	      if (h != oldH && options.autoHeight) {
	        resizeCanvas();
	      }
	
	      if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {
	        autosizeColumns();
	      }
	      updateCanvasWidth(false);
	    }
	
	    function getVisibleRange(viewportTop, viewportLeft) {
	      if (viewportTop == null) {
	        viewportTop = scrollTop;
	      }
	      if (viewportLeft == null) {
	        viewportLeft = scrollLeft;
	      }
	
	      return {
	        top: getRowFromPosition(viewportTop),
	        bottom: getRowFromPosition(viewportTop + viewportH) + 1,
	        leftPx: viewportLeft,
	        rightPx: viewportLeft + viewportW
	      };
	    }
	
	    function getRenderedRange(viewportTop, viewportLeft) {
	      var range = getVisibleRange(viewportTop, viewportLeft);
	      var buffer = Math.round(viewportH / options.rowHeight);
	      var minBuffer = 3;
	
	      if (vScrollDir == -1) {
	        range.top -= buffer;
	        range.bottom += minBuffer;
	      } else if (vScrollDir == 1) {
	        range.top -= minBuffer;
	        range.bottom += buffer;
	      } else {
	        range.top -= minBuffer;
	        range.bottom += minBuffer;
	      }
	
	      range.top = Math.max(0, range.top);
	      range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);
	
	      range.leftPx -= viewportW;
	      range.rightPx += viewportW;
	
	      range.leftPx = Math.max(0, range.leftPx);
	      range.rightPx = Math.min(canvasWidth, range.rightPx);
	
	      return range;
	    }
	
	    function ensureCellNodesInRowsCache(row) {
	      var cacheEntry = rowsCache[row];
	      if (cacheEntry) {
	        if (cacheEntry.cellRenderQueue.length) {
	          var lastChild = cacheEntry.rowNode.lastChild;
	          while (cacheEntry.cellRenderQueue.length) {
	            var columnIdx = cacheEntry.cellRenderQueue.pop();
	            cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild;
	            lastChild = lastChild.previousSibling;
	          }
	        }
	      }
	    }
	
	    function cleanUpCells(range, row) {
	      var totalCellsRemoved = 0;
	      var cacheEntry = rowsCache[row];
	
	      // Remove cells outside the range.
	      var cellsToRemove = [];
	      for (var i in cacheEntry.cellNodesByColumnIdx) {
	        // I really hate it when people mess with Array.prototype.
	        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {
	          continue;
	        }
	
	        // This is a string, so it needs to be cast back to a number.
	        i = i | 0;
	
	        var colspan = cacheEntry.cellColSpans[i];
	        if (columnPosLeft[i] > range.rightPx ||
	          columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {
	          if (!(row == activeRow && i == activeCell)) {
	            cellsToRemove.push(i);
	          }
	        }
	      }
	
	      var cellToRemove;
	      while ((cellToRemove = cellsToRemove.pop()) != null) {
	        cacheEntry.rowNode.removeChild(cacheEntry.cellNodesByColumnIdx[cellToRemove]);
	        delete cacheEntry.cellColSpans[cellToRemove];
	        delete cacheEntry.cellNodesByColumnIdx[cellToRemove];
	        if (postProcessedRows[row]) {
	          delete postProcessedRows[row][cellToRemove];
	        }
	        totalCellsRemoved++;
	      }
	    }
	
	    function cleanUpAndRenderCells(range) {
	      var cacheEntry;
	      var stringArray = [];
	      var processedRows = [];
	      var cellsAdded;
	      var totalCellsAdded = 0;
	      var colspan;
	
	      for (var row = range.top, btm = range.bottom; row <= btm; row++) {
	        cacheEntry = rowsCache[row];
	        if (!cacheEntry) {
	          continue;
	        }
	
	        // cellRenderQueue populated in renderRows() needs to be cleared first
	        ensureCellNodesInRowsCache(row);
	
	        cleanUpCells(range, row);
	
	        // Render missing cells.
	        cellsAdded = 0;
	
	        var metadata = data.getItemMetadata && data.getItemMetadata(row);
	        metadata = metadata && metadata.columns;
	
	        var d = getDataItem(row);
	
	        // TODO:  shorten this loop (index? heuristics? binary search?)
	        for (var i = 0, ii = columns.length; i < ii; i++) {
	          // Cells to the right are outside the range.
	          if (columnPosLeft[i] > range.rightPx) {
	            break;
	          }
	
	          // Already rendered.
	          if ((colspan = cacheEntry.cellColSpans[i]) != null) {
	            i += (colspan > 1 ? colspan - 1 : 0);
	            continue;
	          }
	
	          colspan = 1;
	          if (metadata) {
	            var columnData = metadata[columns[i].id] || metadata[i];
	            colspan = (columnData && columnData.colspan) || 1;
	            if (colspan === "*") {
	              colspan = ii - i;
	            }
	          }
	
	          if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {
	            appendCellHtml(stringArray, row, i, colspan, d);
	            cellsAdded++;
	          }
	
	          i += (colspan > 1 ? colspan - 1 : 0);
	        }
	
	        if (cellsAdded) {
	          totalCellsAdded += cellsAdded;
	          processedRows.push(row);
	        }
	      }
	
	      if (!stringArray.length) {
	        return;
	      }
	
	      var x = document.createElement("div");
	      x.innerHTML = stringArray.join("");
	
	      var processedRow;
	      var node;
	      while ((processedRow = processedRows.pop()) != null) {
	        cacheEntry = rowsCache[processedRow];
	        var columnIdx;
	        while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {
	          node = x.lastChild;
	          cacheEntry.rowNode.appendChild(node);
	          cacheEntry.cellNodesByColumnIdx[columnIdx] = node;
	        }
	      }
	    }
	
	    function renderRows(range) {
	      var parentNode = $canvas[0],
	          stringArray = [],
	          rows = [],
	          needToReselectCell = false,
	          dataLength = getDataLength();
	
	      for (var i = range.top, ii = range.bottom; i <= ii; i++) {
	        if (rowsCache[i]) {
	          continue;
	        }
	        renderedRows++;
	        rows.push(i);
	
	        // Create an entry right away so that appendRowHtml() can
	        // start populatating it.
	        rowsCache[i] = {
	          "rowNode": null,
	
	          // ColSpans of rendered cells (by column idx).
	          // Can also be used for checking whether a cell has been rendered.
	          "cellColSpans": [],
	
	          // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().
	          "cellNodesByColumnIdx": [],
	
	          // Column indices of cell nodes that have been rendered, but not yet indexed in
	          // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the
	          // end of the row.
	          "cellRenderQueue": []
	        };
	
	        appendRowHtml(stringArray, i, range, dataLength);
	        if (activeCellNode && activeRow === i) {
	          needToReselectCell = true;
	        }
	        counter_rows_rendered++;
	      }
	
	      if (!rows.length) { return; }
	
	      var x = document.createElement("div");
	      x.innerHTML = stringArray.join("");
	
	      for (var i = 0, ii = rows.length; i < ii; i++) {
	        rowsCache[rows[i]].rowNode = parentNode.appendChild(x.firstChild);
	      }
	
	      if (needToReselectCell) {
	        activeCellNode = getCellNode(activeRow, activeCell);
	      }
	    }
	
	    function startPostProcessing() {
	      if (!options.enableAsyncPostRender) {
	        return;
	      }
	      clearTimeout(h_postrender);
	      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
	    }
	
	    function invalidatePostProcessingResults(row) {
	      delete postProcessedRows[row];
	      postProcessFromRow = Math.min(postProcessFromRow, row);
	      postProcessToRow = Math.max(postProcessToRow, row);
	      startPostProcessing();
	    }
	
	    function updateRowPositions() {
	      for (var row in rowsCache) {
	        rowsCache[row].rowNode.style.top = getRowTop(row) + "px";
	      }
	    }
	
	    function render() {
	      if (!initialized) { return; }
	      var visible = getVisibleRange();
	      var rendered = getRenderedRange();
	
	      // remove rows no longer in the viewport
	      cleanupRows(rendered);
	
	      // add new rows & missing cells in existing rows
	      if (lastRenderedScrollLeft != scrollLeft) {
	        cleanUpAndRenderCells(rendered);
	      }
	
	      // render missing rows
	      renderRows(rendered);
	
	      postProcessFromRow = visible.top;
	      postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);
	      startPostProcessing();
	
	      lastRenderedScrollTop = scrollTop;
	      lastRenderedScrollLeft = scrollLeft;
	      h_render = null;
	    }
	
	    function handleHeaderRowScroll() {
	      var scrollLeft = $headerRowScroller[0].scrollLeft;
	      if (scrollLeft != $viewport[0].scrollLeft) {
	        $viewport[0].scrollLeft = scrollLeft;
	      }
	    }
	
	    function handleScroll() {
	      scrollTop = $viewport[0].scrollTop;
	      scrollLeft = $viewport[0].scrollLeft;
	      var vScrollDist = Math.abs(scrollTop - prevScrollTop);
	      var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);
	
	      if (hScrollDist) {
	        prevScrollLeft = scrollLeft;
	        $headerScroller[0].scrollLeft = scrollLeft;
	        $topPanelScroller[0].scrollLeft = scrollLeft;
	        $headerRowScroller[0].scrollLeft = scrollLeft;
	      }
	
	      if (vScrollDist) {
	        vScrollDir = prevScrollTop < scrollTop ? 1 : -1;
	        prevScrollTop = scrollTop;
	
	        // switch virtual pages if needed
	        if (vScrollDist < viewportH) {
	          scrollTo(scrollTop + offset);
	        } else {
	          var oldOffset = offset;
	          if (h == viewportH) {
	            page = 0;
	          } else {
	            page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));
	          }
	          offset = Math.round(page * cj);
	          if (oldOffset != offset) {
	            invalidateAllRows();
	          }
	        }
	      }
	
	      if (hScrollDist || vScrollDist) {
	        if (h_render) {
	          clearTimeout(h_render);
	        }
	
	        if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 ||
	            Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {
	          if (options.forceSyncScrolling || (
	              Math.abs(lastRenderedScrollTop - scrollTop) < viewportH &&
	              Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW)) {
	            render();
	          } else {
	            h_render = setTimeout(render, 50);
	          }
	
	          trigger(self.onViewportChanged, {});
	        }
	      }
	
	      trigger(self.onScroll, {scrollLeft: scrollLeft, scrollTop: scrollTop});
	    }
	
	    function asyncPostProcessRows() {
	      var dataLength = getDataLength();
	      while (postProcessFromRow <= postProcessToRow) {
	        var row = (vScrollDir >= 0) ? postProcessFromRow++ : postProcessToRow--;
	        var cacheEntry = rowsCache[row];
	        if (!cacheEntry || row >= dataLength) {
	          continue;
	        }
	
	        if (!postProcessedRows[row]) {
	          postProcessedRows[row] = {};
	        }
	
	        ensureCellNodesInRowsCache(row);
	        for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
	          if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {
	            continue;
	          }
	
	          columnIdx = columnIdx | 0;
	
	          var m = columns[columnIdx];
	          if (m.asyncPostRender && !postProcessedRows[row][columnIdx]) {
	            var node = cacheEntry.cellNodesByColumnIdx[columnIdx];
	            if (node) {
	              m.asyncPostRender(node, row, getDataItem(row), m);
	            }
	            postProcessedRows[row][columnIdx] = true;
	          }
	        }
	
	        h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
	        return;
	      }
	    }
	
	    function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {
	      var node, columnId, addedRowHash, removedRowHash;
	      for (var row in rowsCache) {
	        removedRowHash = removedHash && removedHash[row];
	        addedRowHash = addedHash && addedHash[row];
	
	        if (removedRowHash) {
	          for (columnId in removedRowHash) {
	            if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
	              node = getCellNode(row, getColumnIndex(columnId));
	              if (node) {
	                $(node).removeClass(removedRowHash[columnId]);
	              }
	            }
	          }
	        }
	
	        if (addedRowHash) {
	          for (columnId in addedRowHash) {
	            if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
	              node = getCellNode(row, getColumnIndex(columnId));
	              if (node) {
	                $(node).addClass(addedRowHash[columnId]);
	              }
	            }
	          }
	        }
	      }
	    }
	
	    function addCellCssStyles(key, hash) {
	      if (cellCssClasses[key]) {
	        throw "addCellCssStyles: cell CSS hash with key '" + key + "' already exists.";
	      }
	
	      cellCssClasses[key] = hash;
	      updateCellCssStylesOnRenderedRows(hash, null);
	
	      trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash });
	    }
	
	    function removeCellCssStyles(key) {
	      if (!cellCssClasses[key]) {
	        return;
	      }
	
	      updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);
	      delete cellCssClasses[key];
	
	      trigger(self.onCellCssStylesChanged, { "key": key, "hash": null });
	    }
	
	    function setCellCssStyles(key, hash) {
	      var prevHash = cellCssClasses[key];
	
	      cellCssClasses[key] = hash;
	      updateCellCssStylesOnRenderedRows(hash, prevHash);
	
	      trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash });
	    }
	
	    function getCellCssStyles(key) {
	      return cellCssClasses[key];
	    }
	
	    function flashCell(row, cell, speed) {
	      speed = speed || 100;
	      if (rowsCache[row]) {
	        var $cell = $(getCellNode(row, cell));
	
	        function toggleCellClass(times) {
	          if (!times) {
	            return;
	          }
	          setTimeout(function () {
	                $cell.queue(function () {
	                  $cell.toggleClass(options.cellFlashingCssClass).dequeue();
	                  toggleCellClass(times - 1);
	                });
	              },
	              speed);
	        }
	
	        toggleCellClass(4);
	      }
	    }
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Interactivity
	
	    function handleMouseWheel(e) {
	      var rowNode = $(e.target).closest(".slick-row")[0];
	      if (rowNode != rowNodeFromLastMouseWheelEvent) {
	        if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != rowNode) {
	          $canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent);
	          zombieRowNodeFromLastMouseWheelEvent = null;
	        }
	        rowNodeFromLastMouseWheelEvent = rowNode;
	      }
	    }
	
	    function handleDragInit(e, dd) {
	      var cell = getCellFromEvent(e);
	      if (!cell || !cellExists(cell.row, cell.cell)) {
	        return false;
	      }
	
	      var retval = trigger(self.onDragInit, dd, e);
	      if (e.isImmediatePropagationStopped()) {
	        return retval;
	      }
	
	      // if nobody claims to be handling drag'n'drop by stopping immediate propagation,
	      // cancel out of it
	      return false;
	    }
	
	    function handleDragStart(e, dd) {
	      var cell = getCellFromEvent(e);
	      if (!cell || !cellExists(cell.row, cell.cell)) {
	        return false;
	      }
	
	      var retval = trigger(self.onDragStart, dd, e);
	      if (e.isImmediatePropagationStopped()) {
	        return retval;
	      }
	
	      return false;
	    }
	
	    function handleDrag(e, dd) {
	      return trigger(self.onDrag, dd, e);
	    }
	
	    function handleDragEnd(e, dd) {
	      trigger(self.onDragEnd, dd, e);
	    }
	
	    function handleKeyDown(e) {
	      trigger(self.onKeyDown, {row: activeRow, cell: activeCell}, e);
	      var handled = e.isImmediatePropagationStopped();
	
	      if (!handled) {
	        if (!e.shiftKey && !e.altKey && !e.ctrlKey) {
	          if (e.which == 27) {
	            if (!getEditorLock().isActive()) {
	              return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)
	            }
	            cancelEditAndSetFocus();
	          } else if (e.which == 34) {
	            navigatePageDown();
	            handled = true;
	          } else if (e.which == 33) {
	            navigatePageUp();
	            handled = true;
	          } else if (e.which == 37) {
	            handled = navigateLeft();
	          } else if (e.which == 39) {
	            handled = navigateRight();
	          } else if (e.which == 38) {
	            handled = navigateUp();
	          } else if (e.which == 40) {
	            handled = navigateDown();
	          } else if (e.which == 9) {
	            handled = navigateNext();
	          } else if (e.which == 13) {
	            if (options.editable) {
	              if (currentEditor) {
	                // adding new row
	                if (activeRow === getDataLength()) {
	                  navigateDown();
	                } else {
	                  commitEditAndSetFocus();
	                }
	              } else {
	                if (getEditorLock().commitCurrentEdit()) {
	                  makeActiveCellEditable();
	                }
	              }
	            }
	            handled = true;
	          }
	        } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey) {
	          handled = navigatePrev();
	        }
	      }
	
	      if (handled) {
	        // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it
	        e.stopPropagation();
	        e.preventDefault();
	        try {
	          e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)
	        }
	        // ignore exceptions - setting the original event's keycode throws access denied exception for "Ctrl"
	        // (hitting control key only, nothing else), "Shift" (maybe others)
	        catch (error) {
	        }
	      }
	    }
	
	    function handleClick(e) {
	      if (!currentEditor) {
	        // if this click resulted in some cell child node getting focus,
	        // don't steal it back - keyboard events will still bubble up
	        // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.
	        if (e.target != document.activeElement || $(e.target).hasClass("slick-cell")) {
	          setFocus();
	        }
	      }
	
	      var cell = getCellFromEvent(e);
	      if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {
	        return;
	      }
	
	      trigger(self.onClick, {row: cell.row, cell: cell.cell}, e);
	      if (e.isImmediatePropagationStopped()) {
	        return;
	      }
	
	      if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {
	        if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {
	          scrollRowIntoView(cell.row, false);
	          setActiveCellInternal(getCellNode(cell.row, cell.cell));
	        }
	      }
	    }
	
	    function handleContextMenu(e) {
	      var $cell = $(e.target).closest(".slick-cell", $canvas);
	      if ($cell.length === 0) {
	        return;
	      }
	
	      // are we editing this cell?
	      if (activeCellNode === $cell[0] && currentEditor !== null) {
	        return;
	      }
	
	      trigger(self.onContextMenu, {}, e);
	    }
	
	    function handleDblClick(e) {
	      var cell = getCellFromEvent(e);
	      if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {
	        return;
	      }
	
	      trigger(self.onDblClick, {row: cell.row, cell: cell.cell}, e);
	      if (e.isImmediatePropagationStopped()) {
	        return;
	      }
	
	      if (options.editable) {
	        gotoCell(cell.row, cell.cell, true);
	      }
	    }
	
	    function handleHeaderMouseEnter(e) {
	      trigger(self.onHeaderMouseEnter, {
	        "column": $(this).data("column")
	      }, e);
	    }
	
	    function handleHeaderMouseLeave(e) {
	      trigger(self.onHeaderMouseLeave, {
	        "column": $(this).data("column")
	      }, e);
	    }
	
	    function handleHeaderContextMenu(e) {
	      var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
	      var column = $header && $header.data("column");
	      trigger(self.onHeaderContextMenu, {column: column}, e);
	    }
	
	    function handleHeaderClick(e) {
	      var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
	      var column = $header && $header.data("column");
	      if (column) {
	        trigger(self.onHeaderClick, {column: column}, e);
	      }
	    }
	
	    function handleMouseEnter(e) {
	      trigger(self.onMouseEnter, {}, e);
	    }
	
	    function handleMouseLeave(e) {
	      trigger(self.onMouseLeave, {}, e);
	    }
	
	    function cellExists(row, cell) {
	      return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);
	    }
	
	    function getCellFromPoint(x, y) {
	      var row = getRowFromPosition(y);
	      var cell = 0;
	
	      var w = 0;
	      for (var i = 0; i < columns.length && w < x; i++) {
	        w += columns[i].width;
	        cell++;
	      }
	
	      if (cell < 0) {
	        cell = 0;
	      }
	
	      return {row: row, cell: cell - 1};
	    }
	
	    function getCellFromNode(cellNode) {
	      // read column number from .l<columnNumber> CSS class
	      var cls = /l\d+/.exec(cellNode.className);
	      if (!cls) {
	        throw "getCellFromNode: cannot get cell - " + cellNode.className;
	      }
	      return parseInt(cls[0].substr(1, cls[0].length - 1), 10);
	    }
	
	    function getRowFromNode(rowNode) {
	      for (var row in rowsCache) {
	        if (rowsCache[row].rowNode === rowNode) {
	          return row | 0;
	        }
	      }
	
	      return null;
	    }
	
	    function getCellFromEvent(e) {
	      var $cell = $(e.target).closest(".slick-cell", $canvas);
	      if (!$cell.length) {
	        return null;
	      }
	
	      var row = getRowFromNode($cell[0].parentNode);
	      var cell = getCellFromNode($cell[0]);
	
	      if (row == null || cell == null) {
	        return null;
	      } else {
	        return {
	          "row": row,
	          "cell": cell
	        };
	      }
	    }
	
	    function getCellNodeBox(row, cell) {
	      if (!cellExists(row, cell)) {
	        return null;
	      }
	
	      var y1 = getRowTop(row);
	      var y2 = y1 + options.rowHeight - 1;
	      var x1 = 0;
	      for (var i = 0; i < cell; i++) {
	        x1 += columns[i].width;
	      }
	      var x2 = x1 + columns[cell].width;
	
	      return {
	        top: y1,
	        left: x1,
	        bottom: y2,
	        right: x2
	      };
	    }
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Cell switching
	
	    function resetActiveCell() {
	      setActiveCellInternal(null, false);
	    }
	
	    function setFocus() {
	      if (tabbingDirection == -1) {
	        $focusSink[0].focus();
	      } else {
	        $focusSink2[0].focus();
	      }
	    }
	
	    function scrollCellIntoView(row, cell, doPaging) {
	      scrollRowIntoView(row, doPaging);
	
	      var colspan = getColspan(row, cell);
	      var left = columnPosLeft[cell],
	        right = columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)],
	        scrollRight = scrollLeft + viewportW;
	
	      if (left < scrollLeft) {
	        $viewport.scrollLeft(left);
	        handleScroll();
	        render();
	      } else if (right > scrollRight) {
	        $viewport.scrollLeft(Math.min(left, right - $viewport[0].clientWidth));
	        handleScroll();
	        render();
	      }
	    }
	
	    function setActiveCellInternal(newCell, opt_editMode) {
	      if (activeCellNode !== null) {
	        makeActiveCellNormal();
	        $(activeCellNode).removeClass("active");
	        if (rowsCache[activeRow]) {
	          $(rowsCache[activeRow].rowNode).removeClass("active");
	        }
	      }
	
	      var activeCellChanged = (activeCellNode !== newCell);
	      activeCellNode = newCell;
	
	      if (activeCellNode != null) {
	        activeRow = getRowFromNode(activeCellNode.parentNode);
	        activeCell = activePosX = getCellFromNode(activeCellNode);
	
	        if (opt_editMode == null) {
	          opt_editMode = (activeRow == getDataLength()) || options.autoEdit;
	        }
	
	        $(activeCellNode).addClass("active");
	        $(rowsCache[activeRow].rowNode).addClass("active");
	
	        if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {
	          clearTimeout(h_editorLoader);
	
	          if (options.asyncEditorLoading) {
	            h_editorLoader = setTimeout(function () {
	              makeActiveCellEditable();
	            }, options.asyncEditorLoadDelay);
	          } else {
	            makeActiveCellEditable();
	          }
	        }
	      } else {
	        activeRow = activeCell = null;
	      }
	
	      if (activeCellChanged) {
	        trigger(self.onActiveCellChanged, getActiveCell());
	      }
	    }
	
	    function clearTextSelection() {
	      if (document.selection && document.selection.empty) {
	        try {
	          //IE fails here if selected element is not in dom
	          document.selection.empty();
	        } catch (e) { }
	      } else if (window.getSelection) {
	        var sel = window.getSelection();
	        if (sel && sel.removeAllRanges) {
	          sel.removeAllRanges();
	        }
	      }
	    }
	
	    function isCellPotentiallyEditable(row, cell) {
	      var dataLength = getDataLength();
	      // is the data for this row loaded?
	      if (row < dataLength && !getDataItem(row)) {
	        return false;
	      }
	
	      // are we in the Add New row?  can we create new from this cell?
	      if (columns[cell].cannotTriggerInsert && row >= dataLength) {
	        return false;
	      }
	
	      // does this cell have an editor?
	      if (!getEditor(row, cell)) {
	        return false;
	      }
	
	      return true;
	    }
	
	    function makeActiveCellNormal() {
	      if (!currentEditor) {
	        return;
	      }
	      trigger(self.onBeforeCellEditorDestroy, {editor: currentEditor});
	      currentEditor.destroy();
	      currentEditor = null;
	
	      if (activeCellNode) {
	        var d = getDataItem(activeRow);
	        $(activeCellNode).removeClass("editable invalid");
	        if (d) {
	          var column = columns[activeCell];
	          var formatter = getFormatter(activeRow, column);
	          activeCellNode.innerHTML = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d);
	          invalidatePostProcessingResults(activeRow);
	        }
	      }
	
	      // if there previously was text selected on a page (such as selected text in the edit cell just removed),
	      // IE can't set focus to anything else correctly
	      if (navigator.userAgent.toLowerCase().match(/msie/)) {
	        clearTextSelection();
	      }
	
	      getEditorLock().deactivate(editController);
	    }
	
	    function makeActiveCellEditable(editor) {
	      if (!activeCellNode) {
	        return;
	      }
	      if (!options.editable) {
	        throw "Grid : makeActiveCellEditable : should never get called when options.editable is false";
	      }
	
	      // cancel pending async call if there is one
	      clearTimeout(h_editorLoader);
	
	      if (!isCellPotentiallyEditable(activeRow, activeCell)) {
	        return;
	      }
	
	      var columnDef = columns[activeCell];
	      var item = getDataItem(activeRow);
	
	      if (trigger(self.onBeforeEditCell, {row: activeRow, cell: activeCell, item: item, column: columnDef}) === false) {
	        setFocus();
	        return;
	      }
	
	      getEditorLock().activate(editController);
	      $(activeCellNode).addClass("editable");
	
	      // don't clear the cell if a custom editor is passed through
	      if (!editor) {
	        activeCellNode.innerHTML = "";
	      }
	
	      currentEditor = new (editor || getEditor(activeRow, activeCell))({
	        grid: self,
	        gridPosition: absBox($container[0]),
	        position: absBox(activeCellNode),
	        container: activeCellNode,
	        column: columnDef,
	        item: item || {},
	        commitChanges: commitEditAndSetFocus,
	        cancelChanges: cancelEditAndSetFocus
	      });
	
	      if (item) {
	        currentEditor.loadValue(item);
	      }
	
	      serializedEditorValue = currentEditor.serializeValue();
	
	      if (currentEditor.position) {
	        handleActiveCellPositionChange();
	      }
	    }
	
	    function commitEditAndSetFocus() {
	      // if the commit fails, it would do so due to a validation error
	      // if so, do not steal the focus from the editor
	      if (getEditorLock().commitCurrentEdit()) {
	        setFocus();
	        if (options.autoEdit) {
	          navigateDown();
	        }
	      }
	    }
	
	    function cancelEditAndSetFocus() {
	      if (getEditorLock().cancelCurrentEdit()) {
	        setFocus();
	      }
	    }
	
	    function absBox(elem) {
	      var box = {
	        top: elem.offsetTop,
	        left: elem.offsetLeft,
	        bottom: 0,
	        right: 0,
	        width: $(elem).outerWidth(),
	        height: $(elem).outerHeight(),
	        visible: true};
	      box.bottom = box.top + box.height;
	      box.right = box.left + box.width;
	
	      // walk up the tree
	      var offsetParent = elem.offsetParent;
	      while ((elem = elem.parentNode) != document.body) {
	        if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css("overflowY") != "visible") {
	          box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;
	        }
	
	        if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css("overflowX") != "visible") {
	          box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;
	        }
	
	        box.left -= elem.scrollLeft;
	        box.top -= elem.scrollTop;
	
	        if (elem === offsetParent) {
	          box.left += elem.offsetLeft;
	          box.top += elem.offsetTop;
	          offsetParent = elem.offsetParent;
	        }
	
	        box.bottom = box.top + box.height;
	        box.right = box.left + box.width;
	      }
	
	      return box;
	    }
	
	    function getActiveCellPosition() {
	      return absBox(activeCellNode);
	    }
	
	    function getGridPosition() {
	      return absBox($container[0])
	    }
	
	    function handleActiveCellPositionChange() {
	      if (!activeCellNode) {
	        return;
	      }
	
	      trigger(self.onActiveCellPositionChanged, {});
	
	      if (currentEditor) {
	        var cellBox = getActiveCellPosition();
	        if (currentEditor.show && currentEditor.hide) {
	          if (!cellBox.visible) {
	            currentEditor.hide();
	          } else {
	            currentEditor.show();
	          }
	        }
	
	        if (currentEditor.position) {
	          currentEditor.position(cellBox);
	        }
	      }
	    }
	
	    function getCellEditor() {
	      return currentEditor;
	    }
	
	    function getActiveCell() {
	      if (!activeCellNode) {
	        return null;
	      } else {
	        return {row: activeRow, cell: activeCell};
	      }
	    }
	
	    function getActiveCellNode() {
	      return activeCellNode;
	    }
	
	    function scrollRowIntoView(row, doPaging) {
	      var rowAtTop = row * options.rowHeight;
	      var rowAtBottom = (row + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0);
	
	      // need to page down?
	      if ((row + 1) * options.rowHeight > scrollTop + viewportH + offset) {
	        scrollTo(doPaging ? rowAtTop : rowAtBottom);
	        render();
	      }
	      // or page up?
	      else if (row * options.rowHeight < scrollTop + offset) {
	        scrollTo(doPaging ? rowAtBottom : rowAtTop);
	        render();
	      }
	    }
	
	    function scrollRowToTop(row) {
	      scrollTo(row * options.rowHeight);
	      render();
	    }
	
	    function scrollPage(dir) {
	      var deltaRows = dir * numVisibleRows;
	      scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);
	      render();
	
	      if (options.enableCellNavigation && activeRow != null) {
	        var row = activeRow + deltaRows;
	        var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
	        if (row >= dataLengthIncludingAddNew) {
	          row = dataLengthIncludingAddNew - 1;
	        }
	        if (row < 0) {
	          row = 0;
	        }
	
	        var cell = 0, prevCell = null;
	        var prevActivePosX = activePosX;
	        while (cell <= activePosX) {
	          if (canCellBeActive(row, cell)) {
	            prevCell = cell;
	          }
	          cell += getColspan(row, cell);
	        }
	
	        if (prevCell !== null) {
	          setActiveCellInternal(getCellNode(row, prevCell));
	          activePosX = prevActivePosX;
	        } else {
	          resetActiveCell();
	        }
	      }
	    }
	
	    function navigatePageDown() {
	      scrollPage(1);
	    }
	
	    function navigatePageUp() {
	      scrollPage(-1);
	    }
	
	    function getColspan(row, cell) {
	      var metadata = data.getItemMetadata && data.getItemMetadata(row);
	      if (!metadata || !metadata.columns) {
	        return 1;
	      }
	
	      var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];
	      var colspan = (columnData && columnData.colspan);
	      if (colspan === "*") {
	        colspan = columns.length - cell;
	      } else {
	        colspan = colspan || 1;
	      }
	
	      return colspan;
	    }
	
	    function findFirstFocusableCell(row) {
	      var cell = 0;
	      while (cell < columns.length) {
	        if (canCellBeActive(row, cell)) {
	          return cell;
	        }
	        cell += getColspan(row, cell);
	      }
	      return null;
	    }
	
	    function findLastFocusableCell(row) {
	      var cell = 0;
	      var lastFocusableCell = null;
	      while (cell < columns.length) {
	        if (canCellBeActive(row, cell)) {
	          lastFocusableCell = cell;
	        }
	        cell += getColspan(row, cell);
	      }
	      return lastFocusableCell;
	    }
	
	    function gotoRight(row, cell, posX) {
	      if (cell >= columns.length) {
	        return null;
	      }
	
	      do {
	        cell += getColspan(row, cell);
	      }
	      while (cell < columns.length && !canCellBeActive(row, cell));
	
	      if (cell < columns.length) {
	        return {
	          "row": row,
	          "cell": cell,
	          "posX": cell
	        };
	      }
	      return null;
	    }
	
	    function gotoLeft(row, cell, posX) {
	      if (cell <= 0) {
	        return null;
	      }
	
	      var firstFocusableCell = findFirstFocusableCell(row);
	      if (firstFocusableCell === null || firstFocusableCell >= cell) {
	        return null;
	      }
	
	      var prev = {
	        "row": row,
	        "cell": firstFocusableCell,
	        "posX": firstFocusableCell
	      };
	      var pos;
	      while (true) {
	        pos = gotoRight(prev.row, prev.cell, prev.posX);
	        if (!pos) {
	          return null;
	        }
	        if (pos.cell >= cell) {
	          return prev;
	        }
	        prev = pos;
	      }
	    }
	
	    function gotoDown(row, cell, posX) {
	      var prevCell;
	      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
	      while (true) {
	        if (++row >= dataLengthIncludingAddNew) {
	          return null;
	        }
	
	        prevCell = cell = 0;
	        while (cell <= posX) {
	          prevCell = cell;
	          cell += getColspan(row, cell);
	        }
	
	        if (canCellBeActive(row, prevCell)) {
	          return {
	            "row": row,
	            "cell": prevCell,
	            "posX": posX
	          };
	        }
	      }
	    }
	
	    function gotoUp(row, cell, posX) {
	      var prevCell;
	      while (true) {
	        if (--row < 0) {
	          return null;
	        }
	
	        prevCell = cell = 0;
	        while (cell <= posX) {
	          prevCell = cell;
	          cell += getColspan(row, cell);
	        }
	
	        if (canCellBeActive(row, prevCell)) {
	          return {
	            "row": row,
	            "cell": prevCell,
	            "posX": posX
	          };
	        }
	      }
	    }
	
	    function gotoNext(row, cell, posX) {
	      if (row == null && cell == null) {
	        row = cell = posX = 0;
	        if (canCellBeActive(row, cell)) {
	          return {
	            "row": row,
	            "cell": cell,
	            "posX": cell
	          };
	        }
	      }
	
	      var pos = gotoRight(row, cell, posX);
	      if (pos) {
	        return pos;
	      }
	
	      var firstFocusableCell = null;
	      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
	      while (++row < dataLengthIncludingAddNew) {
	        firstFocusableCell = findFirstFocusableCell(row);
	        if (firstFocusableCell !== null) {
	          return {
	            "row": row,
	            "cell": firstFocusableCell,
	            "posX": firstFocusableCell
	          };
	        }
	      }
	      return null;
	    }
	
	    function gotoPrev(row, cell, posX) {
	      if (row == null && cell == null) {
	        row = getDataLengthIncludingAddNew() - 1;
	        cell = posX = columns.length - 1;
	        if (canCellBeActive(row, cell)) {
	          return {
	            "row": row,
	            "cell": cell,
	            "posX": cell
	          };
	        }
	      }
	
	      var pos;
	      var lastSelectableCell;
	      while (!pos) {
	        pos = gotoLeft(row, cell, posX);
	        if (pos) {
	          break;
	        }
	        if (--row < 0) {
	          return null;
	        }
	
	        cell = 0;
	        lastSelectableCell = findLastFocusableCell(row);
	        if (lastSelectableCell !== null) {
	          pos = {
	            "row": row,
	            "cell": lastSelectableCell,
	            "posX": lastSelectableCell
	          };
	        }
	      }
	      return pos;
	    }
	
	    function navigateRight() {
	      return navigate("right");
	    }
	
	    function navigateLeft() {
	      return navigate("left");
	    }
	
	    function navigateDown() {
	      return navigate("down");
	    }
	
	    function navigateUp() {
	      return navigate("up");
	    }
	
	    function navigateNext() {
	      return navigate("next");
	    }
	
	    function navigatePrev() {
	      return navigate("prev");
	    }
	
	    /**
	     * @param {string} dir Navigation direction.
	     * @return {boolean} Whether navigation resulted in a change of active cell.
	     */
	    function navigate(dir) {
	      if (!options.enableCellNavigation) {
	        return false;
	      }
	
	      if (!activeCellNode && dir != "prev" && dir != "next") {
	        return false;
	      }
	
	      if (!getEditorLock().commitCurrentEdit()) {
	        return true;
	      }
	      setFocus();
	
	      var tabbingDirections = {
	        "up": -1,
	        "down": 1,
	        "left": -1,
	        "right": 1,
	        "prev": -1,
	        "next": 1
	      };
	      tabbingDirection = tabbingDirections[dir];
	
	      var stepFunctions = {
	        "up": gotoUp,
	        "down": gotoDown,
	        "left": gotoLeft,
	        "right": gotoRight,
	        "prev": gotoPrev,
	        "next": gotoNext
	      };
	      var stepFn = stepFunctions[dir];
	      var pos = stepFn(activeRow, activeCell, activePosX);
	      if (pos) {
	        var isAddNewRow = (pos.row == getDataLength());
	        scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);
	        setActiveCellInternal(getCellNode(pos.row, pos.cell));
	        activePosX = pos.posX;
	        return true;
	      } else {
	        setActiveCellInternal(getCellNode(activeRow, activeCell));
	        return false;
	      }
	    }
	
	    function getCellNode(row, cell) {
	      if (rowsCache[row]) {
	        ensureCellNodesInRowsCache(row);
	        return rowsCache[row].cellNodesByColumnIdx[cell];
	      }
	      return null;
	    }
	
	    function setActiveCell(row, cell) {
	      if (!initialized) { return; }
	      if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {
	        return;
	      }
	
	      if (!options.enableCellNavigation) {
	        return;
	      }
	
	      scrollCellIntoView(row, cell, false);
	      setActiveCellInternal(getCellNode(row, cell), false);
	    }
	
	    function canCellBeActive(row, cell) {
	      if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() ||
	          row < 0 || cell >= columns.length || cell < 0) {
	        return false;
	      }
	
	      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
	      if (rowMetadata && typeof rowMetadata.focusable === "boolean") {
	        return rowMetadata.focusable;
	      }
	
	      var columnMetadata = rowMetadata && rowMetadata.columns;
	      if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === "boolean") {
	        return columnMetadata[columns[cell].id].focusable;
	      }
	      if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === "boolean") {
	        return columnMetadata[cell].focusable;
	      }
	
	      return columns[cell].focusable;
	    }
	
	    function canCellBeSelected(row, cell) {
	      if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {
	        return false;
	      }
	
	      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
	      if (rowMetadata && typeof rowMetadata.selectable === "boolean") {
	        return rowMetadata.selectable;
	      }
	
	      var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);
	      if (columnMetadata && typeof columnMetadata.selectable === "boolean") {
	        return columnMetadata.selectable;
	      }
	
	      return columns[cell].selectable;
	    }
	
	    function gotoCell(row, cell, forceEdit) {
	      if (!initialized) { return; }
	      if (!canCellBeActive(row, cell)) {
	        return;
	      }
	
	      if (!getEditorLock().commitCurrentEdit()) {
	        return;
	      }
	
	      scrollCellIntoView(row, cell, false);
	
	      var newCell = getCellNode(row, cell);
	
	      // if selecting the 'add new' row, start editing right away
	      setActiveCellInternal(newCell, forceEdit || (row === getDataLength()) || options.autoEdit);
	
	      // if no editor was created, set the focus back on the grid
	      if (!currentEditor) {
	        setFocus();
	      }
	    }
	
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // IEditor implementation for the editor lock
	
	    function commitCurrentEdit() {
	      var item = getDataItem(activeRow);
	      var column = columns[activeCell];
	
	      if (currentEditor) {
	        if (currentEditor.isValueChanged()) {
	          var validationResults = currentEditor.validate();
	
	          if (validationResults.valid) {
	            if (activeRow < getDataLength()) {
	              var editCommand = {
	                row: activeRow,
	                cell: activeCell,
	                editor: currentEditor,
	                serializedValue: currentEditor.serializeValue(),
	                prevSerializedValue: serializedEditorValue,
	                execute: function () {
	                  this.editor.applyValue(item, this.serializedValue);
	                  updateRow(this.row);
	                  trigger(self.onCellChange, {
	                    row: activeRow,
	                    cell: activeCell,
	                    item: item
	                  });
	                },
	                undo: function () {
	                  this.editor.applyValue(item, this.prevSerializedValue);
	                  updateRow(this.row);
	                  trigger(self.onCellChange, {
	                    row: activeRow,
	                    cell: activeCell,
	                    item: item
	                  });
	                }
	              };
	
	              if (options.editCommandHandler) {
	                makeActiveCellNormal();
	                options.editCommandHandler(item, column, editCommand);
	              } else {
	                editCommand.execute();
	                makeActiveCellNormal();
	              }
	
	            } else {
	              var newItem = {};
	              currentEditor.applyValue(newItem, currentEditor.serializeValue());
	              makeActiveCellNormal();
	              trigger(self.onAddNewRow, {item: newItem, column: column});
	            }
	
	            // check whether the lock has been re-acquired by event handlers
	            return !getEditorLock().isActive();
	          } else {
	            // Re-add the CSS class to trigger transitions, if any.
	            $(activeCellNode).removeClass("invalid");
	            $(activeCellNode).width();  // force layout
	            $(activeCellNode).addClass("invalid");
	
	            trigger(self.onValidationError, {
	              editor: currentEditor,
	              cellNode: activeCellNode,
	              validationResults: validationResults,
	              row: activeRow,
	              cell: activeCell,
	              column: column
	            });
	
	            currentEditor.focus();
	            return false;
	          }
	        }
	
	        makeActiveCellNormal();
	      }
	      return true;
	    }
	
	    function cancelCurrentEdit() {
	      makeActiveCellNormal();
	      return true;
	    }
	
	    function rowsToRanges(rows) {
	      var ranges = [];
	      var lastCell = columns.length - 1;
	      for (var i = 0; i < rows.length; i++) {
	        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));
	      }
	      return ranges;
	    }
	
	    function getSelectedRows() {
	      if (!selectionModel) {
	        throw "Selection model is not set";
	      }
	      return selectedRows;
	    }
	
	    function setSelectedRows(rows) {
	      if (!selectionModel) {
	        throw "Selection model is not set";
	      }
	      selectionModel.setSelectedRanges(rowsToRanges(rows));
	    }
	
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Debug
	
	    this.debug = function () {
	      var s = "";
	
	      s += ("\n" + "counter_rows_rendered:  " + counter_rows_rendered);
	      s += ("\n" + "counter_rows_removed:  " + counter_rows_removed);
	      s += ("\n" + "renderedRows:  " + renderedRows);
	      s += ("\n" + "numVisibleRows:  " + numVisibleRows);
	      s += ("\n" + "maxSupportedCssHeight:  " + maxSupportedCssHeight);
	      s += ("\n" + "n(umber of pages):  " + n);
	      s += ("\n" + "(current) page:  " + page);
	      s += ("\n" + "page height (ph):  " + ph);
	      s += ("\n" + "vScrollDir:  " + vScrollDir);
	
	      alert(s);
	    };
	
	    // a debug helper to be able to access private members
	    this.eval = function (expr) {
	      return eval(expr);
	    };
	
	    //////////////////////////////////////////////////////////////////////////////////////////////
	    // Public API
	
	    $.extend(this, {
	      "slickGridVersion": "2.1",
	
	      // Events
	      "onScroll": new Slick.Event(),
	      "onSort": new Slick.Event(),
	      "onHeaderMouseEnter": new Slick.Event(),
	      "onHeaderMouseLeave": new Slick.Event(),
	      "onHeaderContextMenu": new Slick.Event(),
	      "onHeaderClick": new Slick.Event(),
	      "onHeaderCellRendered": new Slick.Event(),
	      "onBeforeHeaderCellDestroy": new Slick.Event(),
	      "onHeaderRowCellRendered": new Slick.Event(),
	      "onBeforeHeaderRowCellDestroy": new Slick.Event(),
	      "onMouseEnter": new Slick.Event(),
	      "onMouseLeave": new Slick.Event(),
	      "onClick": new Slick.Event(),
	      "onDblClick": new Slick.Event(),
	      "onContextMenu": new Slick.Event(),
	      "onKeyDown": new Slick.Event(),
	      "onAddNewRow": new Slick.Event(),
	      "onValidationError": new Slick.Event(),
	      "onViewportChanged": new Slick.Event(),
	      "onColumnsReordered": new Slick.Event(),
	      "onColumnsResized": new Slick.Event(),
	      "onCellChange": new Slick.Event(),
	      "onBeforeEditCell": new Slick.Event(),
	      "onBeforeCellEditorDestroy": new Slick.Event(),
	      "onBeforeDestroy": new Slick.Event(),
	      "onActiveCellChanged": new Slick.Event(),
	      "onActiveCellPositionChanged": new Slick.Event(),
	      "onDragInit": new Slick.Event(),
	      "onDragStart": new Slick.Event(),
	      "onDrag": new Slick.Event(),
	      "onDragEnd": new Slick.Event(),
	      "onSelectedRowsChanged": new Slick.Event(),
	      "onCellCssStylesChanged": new Slick.Event(),
	
	      // Methods
	      "registerPlugin": registerPlugin,
	      "unregisterPlugin": unregisterPlugin,
	      "getColumns": getColumns,
	      "setColumns": setColumns,
	      "getColumnIndex": getColumnIndex,
	      "updateColumnHeader": updateColumnHeader,
	      "setSortColumn": setSortColumn,
	      "setSortColumns": setSortColumns,
	      "getSortColumns": getSortColumns,
	      "autosizeColumns": autosizeColumns,
	      "getOptions": getOptions,
	      "setOptions": setOptions,
	      "getData": getData,
	      "getDataLength": getDataLength,
	      "getDataItem": getDataItem,
	      "setData": setData,
	      "getSelectionModel": getSelectionModel,
	      "setSelectionModel": setSelectionModel,
	      "getSelectedRows": getSelectedRows,
	      "setSelectedRows": setSelectedRows,
	      "getContainerNode": getContainerNode,
	
	      "render": render,
	      "invalidate": invalidate,
	      "invalidateRow": invalidateRow,
	      "invalidateRows": invalidateRows,
	      "invalidateAllRows": invalidateAllRows,
	      "updateCell": updateCell,
	      "updateRow": updateRow,
	      "getViewport": getVisibleRange,
	      "getRenderedRange": getRenderedRange,
	      "resizeCanvas": resizeCanvas,
	      "updateRowCount": updateRowCount,
	      "scrollRowIntoView": scrollRowIntoView,
	      "scrollRowToTop": scrollRowToTop,
	      "scrollCellIntoView": scrollCellIntoView,
	      "getCanvasNode": getCanvasNode,
	      "focus": setFocus,
	      "scrollToLastRendered": scrollToLastRendered,
	
	      "getCellFromPoint": getCellFromPoint,
	      "getCellFromEvent": getCellFromEvent,
	      "getActiveCell": getActiveCell,
	      "setActiveCell": setActiveCell,
	      "getActiveCellNode": getActiveCellNode,
	      "getActiveCellPosition": getActiveCellPosition,
	      "resetActiveCell": resetActiveCell,
	      "editActiveCell": makeActiveCellEditable,
	      "getCellEditor": getCellEditor,
	      "getCellNode": getCellNode,
	      "getCellNodeBox": getCellNodeBox,
	      "canCellBeSelected": canCellBeSelected,
	      "canCellBeActive": canCellBeActive,
	      "navigatePrev": navigatePrev,
	      "navigateNext": navigateNext,
	      "navigateUp": navigateUp,
	      "navigateDown": navigateDown,
	      "navigateLeft": navigateLeft,
	      "navigateRight": navigateRight,
	      "navigatePageUp": navigatePageUp,
	      "navigatePageDown": navigatePageDown,
	      "gotoCell": gotoCell,
	      "getTopPanel": getTopPanel,
	      "setTopPanelVisibility": setTopPanelVisibility,
	      "setHeaderRowVisibility": setHeaderRowVisibility,
	      "getHeaderRow": getHeaderRow,
	      "getHeaderRowColumn": getHeaderRowColumn,
	      "getGridPosition": getGridPosition,
	      "flashCell": flashCell,
	      "addCellCssStyles": addCellCssStyles,
	      "setCellCssStyles": setCellCssStyles,
	      "removeCellCssStyles": removeCellCssStyles,
	      "getCellCssStyles": getCellCssStyles,
	
	      "init": finishInitialization,
	      "destroy": destroy,
	
	      // IEditor implementation
	      "getEditorLock": getEditorLock,
	      "getEditController": getEditController
	    });
	
	    init();
	  }
	}(jQuery));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
	  // register namespace
	  $.extend(true, window, {
	    "Slick": {
	      "RowSelectionModel": RowSelectionModel
	    }
	  });
	
	  function RowSelectionModel(options) {
	    var _grid;
	    var _ranges = [];
	    var _self = this;
	    var _handler = new Slick.EventHandler();
	    var _inHandler;
	    var _options;
	    var _defaults = {
	      selectActiveRow: true
	    };
	
	    function init(grid) {
	      _options = $.extend(true, {}, _defaults, options);
	      _grid = grid;
	      _handler.subscribe(_grid.onActiveCellChanged,
	          wrapHandler(handleActiveCellChange));
	      _handler.subscribe(_grid.onKeyDown,
	          wrapHandler(handleKeyDown));
	      _handler.subscribe(_grid.onClick,
	          wrapHandler(handleClick));
	    }
	
	    function destroy() {
	      _handler.unsubscribeAll();
	    }
	
	    function wrapHandler(handler) {
	      return function () {
	        if (!_inHandler) {
	          _inHandler = true;
	          handler.apply(this, arguments);
	          _inHandler = false;
	        }
	      };
	    }
	
	    function rangesToRows(ranges) {
	      var rows = [];
	      for (var i = 0; i < ranges.length; i++) {
	        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {
	          rows.push(j);
	        }
	      }
	      return rows;
	    }
	
	    function rowsToRanges(rows) {
	      var ranges = [];
	      var lastCell = _grid.getColumns().length - 1;
	      for (var i = 0; i < rows.length; i++) {
	        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));
	      }
	      return ranges;
	    }
	
	    function getRowsRange(from, to) {
	      var i, rows = [];
	      for (i = from; i <= to; i++) {
	        rows.push(i);
	      }
	      for (i = to; i < from; i++) {
	        rows.push(i);
	      }
	      return rows;
	    }
	
	    function getSelectedRows() {
	      return rangesToRows(_ranges);
	    }
	
	    function setSelectedRows(rows) {
	      setSelectedRanges(rowsToRanges(rows));
	    }
	
	    function setSelectedRanges(ranges) {
	      _ranges = ranges;
	      _self.onSelectedRangesChanged.notify(_ranges);
	    }
	
	    function getSelectedRanges() {
	      return _ranges;
	    }
	
	    function handleActiveCellChange(e, data) {
	      if (_options.selectActiveRow && data.row != null) {
	        setSelectedRanges([new Slick.Range(data.row, 0, data.row, _grid.getColumns().length - 1)]);
	      }
	    }
	
	    function handleKeyDown(e) {
	      var activeRow = _grid.getActiveCell();
	      if (activeRow && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (e.which == 38 || e.which == 40)) {
	        var selectedRows = getSelectedRows();
	        selectedRows.sort(function (x, y) {
	          return x - y
	        });
	
	        if (!selectedRows.length) {
	          selectedRows = [activeRow.row];
	        }
	
	        var top = selectedRows[0];
	        var bottom = selectedRows[selectedRows.length - 1];
	        var active;
	
	        if (e.which == 40) {
	          active = activeRow.row < bottom || top == bottom ? ++bottom : ++top;
	        } else {
	          active = activeRow.row < bottom ? --bottom : --top;
	        }
	
	        if (active >= 0 && active < _grid.getDataLength()) {
	          _grid.scrollRowIntoView(active);
	          _ranges = rowsToRanges(getRowsRange(top, bottom));
	          setSelectedRanges(_ranges);
	        }
	
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    }
	
	    function handleClick(e) {
	      var cell = _grid.getCellFromEvent(e);
	      if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {
	        return false;
	      }
	
	      if (!_grid.getOptions().multiSelect || (
	          !e.ctrlKey && !e.shiftKey && !e.metaKey)) {
	        return false;
	      }
	
	      var selection = rangesToRows(_ranges);
	      var idx = $.inArray(cell.row, selection);
	
	      if (idx === -1 && (e.ctrlKey || e.metaKey)) {
	        selection.push(cell.row);
	        _grid.setActiveCell(cell.row, cell.cell);
	      } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {
	        selection = $.grep(selection, function (o, i) {
	          return (o !== cell.row);
	        });
	        _grid.setActiveCell(cell.row, cell.cell);
	      } else if (selection.length && e.shiftKey) {
	        var last = selection.pop();
	        var from = Math.min(cell.row, last);
	        var to = Math.max(cell.row, last);
	        selection = [];
	        for (var i = from; i <= to; i++) {
	          if (i !== last) {
	            selection.push(i);
	          }
	        }
	        selection.push(last);
	        _grid.setActiveCell(cell.row, cell.cell);
	      }
	
	      _ranges = rowsToRanges(selection);
	      setSelectedRanges(_ranges);
	      e.stopImmediatePropagation();
	
	      return true;
	    }
	
	    $.extend(this, {
	      "getSelectedRows": getSelectedRows,
	      "setSelectedRows": setSelectedRows,
	
	      "getSelectedRanges": getSelectedRanges,
	      "setSelectedRanges": setSelectedRanges,
	
	      "init": init,
	      "destroy": destroy,
	
	      "onSelectedRangesChanged": new Slick.Event()
	    });
	  }
	})(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
	  function SlickColumnPicker(columns, grid, options) {
	    var $menu;
	    var columnCheckboxes;
	
	    var defaults = {
	      fadeSpeed:250
	    };
	
	    function init() {
	      grid.onHeaderContextMenu.subscribe(handleHeaderContextMenu);
	      grid.onColumnsReordered.subscribe(updateColumnOrder);
	      options = $.extend({}, defaults, options);
	
	      $menu = $("<span class='slick-columnpicker' style='display:none;position:absolute;z-index:20;' />").appendTo(document.body);
	
	      $menu.bind("mouseleave", function (e) {
	        $(this).fadeOut(options.fadeSpeed)
	      });
	      $menu.bind("click", updateColumn);
	
	    }
	
	    function destroy() {
	      grid.onHeaderContextMenu.unsubscribe(handleHeaderContextMenu);
	      grid.onColumnsReordered.unsubscribe(updateColumnOrder);
	      $menu.remove();
	    }
	
	    function handleHeaderContextMenu(e, args) {
	      e.preventDefault();
	      $menu.empty();
	      updateColumnOrder();
	      columnCheckboxes = [];
	
	      var $li, $input;
	      for (var i = 0; i < columns.length; i++) {
	        $li = $("<li />").appendTo($menu);
	        $input = $("<input type='checkbox' />").data("column-id", columns[i].id);
	        columnCheckboxes.push($input);
	
	        if (grid.getColumnIndex(columns[i].id) != null) {
	          $input.attr("checked", "checked");
	        }
	
	        $("<label />")
	            .text(columns[i].name)
	            .prepend($input)
	            .appendTo($li);
	      }
	
	      $("<hr/>").appendTo($menu);
	      $li = $("<li />").appendTo($menu);
	      $input = $("<input type='checkbox' />").data("option", "autoresize");
	      $("<label />")
	          .text("Force fit columns")
	          .prepend($input)
	          .appendTo($li);
	      if (grid.getOptions().forceFitColumns) {
	        $input.attr("checked", "checked");
	      }
	
	      $li = $("<li />").appendTo($menu);
	      $input = $("<input type='checkbox' />").data("option", "syncresize");
	      $("<label />")
	          .text("Synchronous resize")
	          .prepend($input)
	          .appendTo($li);
	      if (grid.getOptions().syncColumnCellResize) {
	        $input.attr("checked", "checked");
	      }
	
	      $menu
	          .css("top", e.pageY - 10)
	          .css("left", e.pageX - 10)
	          .fadeIn(options.fadeSpeed);
	    }
	
	    function updateColumnOrder() {
	      // Because columns can be reordered, we have to update the `columns`
	      // to reflect the new order, however we can't just take `grid.getColumns()`,
	      // as it does not include columns currently hidden by the picker.
	      // We create a new `columns` structure by leaving currently-hidden
	      // columns in their original ordinal position and interleaving the results
	      // of the current column sort.
	      var current = grid.getColumns().slice(0);
	      var ordered = new Array(columns.length);
	      for (var i = 0; i < ordered.length; i++) {
	        if ( grid.getColumnIndex(columns[i].id) === undefined ) {
	          // If the column doesn't return a value from getColumnIndex,
	          // it is hidden. Leave it in this position.
	          ordered[i] = columns[i];
	        } else {
	          // Otherwise, grab the next visible column.
	          ordered[i] = current.shift();
	        }
	      }
	      columns = ordered;
	    }
	
	    function updateColumn(e) {
	      if ($(e.target).data("option") == "autoresize") {
	        if (e.target.checked) {
	          grid.setOptions({forceFitColumns:true});
	          grid.autosizeColumns();
	        } else {
	          grid.setOptions({forceFitColumns:false});
	        }
	        return;
	      }
	
	      if ($(e.target).data("option") == "syncresize") {
	        if (e.target.checked) {
	          grid.setOptions({syncColumnCellResize:true});
	        } else {
	          grid.setOptions({syncColumnCellResize:false});
	        }
	        return;
	      }
	
	      if ($(e.target).is(":checkbox")) {
	        var visibleColumns = [];
	        $.each(columnCheckboxes, function (i, e) {
	          if ($(this).is(":checked")) {
	            visibleColumns.push(columns[i]);
	          }
	        });
	
	        if (!visibleColumns.length) {
	          $(e.target).attr("checked", "checked");
	          return;
	        }
	
	        grid.setColumns(visibleColumns);
	      }
	    }
	
	    function getAllColumns() {
	      return columns;
	    }
	
	    init();
	
	    return {
	      "getAllColumns": getAllColumns,
	      "destroy": destroy
	    };
	  }
	
	  // Slick.Controls.ColumnPicker
	  $.extend(true, window, { Slick:{ Controls:{ ColumnPicker:SlickColumnPicker }}});
	})(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(116),
	  __webpack_require__(119)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Plumage, Collection, User) {
	
	  return Plumage.collection.UserCollection = Collection.extend({
	    model: User
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(101)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, requestManager) {
	
	  /**
	   * Controller base class.
	   *
	   * Provides common logic for controllers including showing views (see [showView]{@link Plumage.controller.BaseController#showView}),
	   * and loading models (see [loadModel]{@link Plumage.controller.BaseController#loadModel})
	   * @constructs Plumage.controller.BaseController
	   */
	  var BaseController = function () {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(BaseController.prototype,
	  /** @lends Plumage.controller.BaseController.prototype */
	  {
	
	    requests: [],
	
	    initialize: function(app) {
	      this.app = app;
	    },
	
	    /** CSS selector for where to render top level views. See [showView]{@link Plumage.controller.BaseController#showView}. */
	    contentSelector: '#page',
	
	    /** The top level view currently shown by this controller */
	    currentView: undefined,
	
	    /** Hook for wrapping handlers */
	    runHandler: function(handlerName, params) {
	      this[handlerName].apply(this, params);
	    },
	
	    getCurrentView: function() {
	      return this.app.views.current;
	    },
	
	    /**
	     * Renders and shows a view in the el specified by [contentSelector]{@link Plumage.controller.BaseController#contentSelector}.
	     * This hides and triggers onHide on the current view, cancels outstanding requests, then
	     * shows and triggers onShow on the specified view.
	     *
	     * For more specific css styling, showView also adds the view's [bodyCls]{@link Plumage.view.View#bodyCls}))
	     * attribute to the DOM body element.
	     *
	     * @param {Plumage.view.View} view View to show.
	     */
	    showView: function(view) {
	      var currentView = this.getCurrentView();
	      if (currentView) {
	        if (currentView === view) {
	          return;
	        }
	        if (currentView.onHide) {
	          currentView.onHide();
	        }
	        if (currentView.bodyCls) {
	          $('body').removeClass(currentView.bodyCls);
	        }
	      }
	      this.app.views.current = view;
	
	      requestManager.abortOutstandingRequests();
	
	      $(this.contentSelector).html(view.el);
	      if (!view.isRendered) {
	        view.render();
	      }
	      if (view.bodyCls) {
	        $('body').addClass(view.bodyCls);
	      }
	      if (view.onShow) {
	        view.onShow();
	      }
	    },
	
	    /**
	     * Load the specified model. Default implementation delegates to requestManager.
	     * @param {Plumage.model.Model} model Model to load.
	     */
	    loadModel: function(model, options) {
	      return requestManager.loadModel(model, options);
	    }
	  });
	
	  BaseController.extend = Backbone.Model.extend;
	
	  return Plumage.controller.BaseController = BaseController;
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(137),
	  __webpack_require__(95)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, BaseController, ModelUtil) {
	
	  return Plumage.controller.ModelController = BaseController.extend(
	  /** @lends Plumage.controller.ModelController.prototype */
	  {
	
	    /** Model Class for detail view. Override this */
	    modelCls: undefined,
	
	    /** Collection Class for index view. Override this */
	    indexModelCls: undefined,
	
	    /** Options to pass into index model constructor */
	    indexModelOptions: {},
	
	    /** View class for index. Override this */
	    indexViewCls: undefined,
	
	    /** View class for detail. Override this */
	    detailViewCls: undefined,
	
	    /** View class for editing. Override this */
	    editViewCls: undefined,
	
	    notFoundMessage: '404 Not Found',
	
	    /**
	     * Controller with general index and detail handlers.
	     *
	     * Handles creating index and detail models from url params, creating index and detail views,
	     * binding models to said views, showing the view, and loading the model.
	     * @constructs
	     * @extends Plumage.controller.BaseController
	     */
	    initialize : function(app, options) {
	      BaseController.prototype.initialize.apply(this, arguments);
	      options = options || {};
	      this.modelCls = options.modelCls ? options.modelCls : this.modelCls;
	
	      this.indexModelCls = options.indexModelCls ? options.indexModelCls : this.indexModelCls;
	      this.indexModelOptions = options.indexModelOptions ? options.indexModelOptions : this.indexModelOptions;
	      this.indexViewCls = options.indexViewCls ? options.indexViewCls : this.indexViewCls;
	      this.detailViewCls = options.detailViewCls ? options.detailViewCls : this.detailViewCls;
	      this.editViewCls = options.editViewCls ? options.editViewCls : this.editViewCls;
	    },
	
	    /** override to set activeModel*/
	    runHandler: function(handlerName, params) {
	      this.setActiveModel(undefined);
	      var promise = this[handlerName].apply(this, params);
	      if (promise) {
	        return promise.done(function (model, resp) {
	          if (model) {
	            this.setActiveModel(model);
	          }
	        }.bind(this));
	      }
	    },
	
	    /** Get the most recently used index model */
	    getIndexCollection: function() {
	      return this.indexModel;
	    },
	
	    /** Get the most recently used detail model */
	    getDetailModel: function() {
	      return this.detailModel;
	    },
	
	    /** handler for showing the index view. Override this to accept more url params */
	    showIndex: function(params) {
	      params = params || {};
	      if (params && params.filters && typeof(params.filters) === 'string') {
	        params.filters = JSON.parse(params.filters);
	      }
	      var model = this.createIndexModel({}, params);
	      return this.showIndexModel(model);
	    },
	
	    /** handler for showing the detail view. Override this to accept more url params*/
	    showDetail: function(urlId, params){
	
	      var model = this.createDetailModel(urlId, {}, params);
	      return this.showDetailModel(model);
	    },
	
	    /** handler for showing the new view. Override this to accept more url params*/
	    showNew: function(fragment, params){
	      var model = this.createEditModel();
	      return this.showEditModel(model);
	    },
	
	    showEdit: function(urlId, params){
	      var model = this.createEditModel(urlId, {}, params);
	      return this.showEditModel(model);
	    },
	
	    /** Logic for binding a model to, and then showing the index view */
	    showIndexModel: function(model) {
	      this.indexModel = model;
	      var view = this.getIndexView();
	      view.setModel(this.indexModel);
	      this.showView(view);
	
	      this.indexModel.on('change', this.onIndexChange.bind(this));
	      return this.loadModel(this.indexModel, {reset: true}).done(function() {
	        view.setModel(model);
	      });
	
	    },
	
	    /**
	     * Logic for binding a model to, and then showing the detail view
	     * Override to add extra event handlers.
	     *
	     *
	     */
	    showDetailModel: function(model) {
	
	      var view = this.getDetailView();
	
	      var result;
	      if (this.getCurrentView() !== view || model !== this.detailModel) {
	        if (this.detailModel) {
	          this.detailModel.off('error', this.onModelError, this);
	        }
	
	        this.detailModel = model;
	        this.detailModel.on('error', this.onModelError, this);
	        view.setModel(model);
	        result = this.loadModel(model).done(function () {
	          // call setModel again, so subviews can get newly loaded related models
	          if (model.related) {
	            view.setModel(model);
	          }
	        });
	      } else {
	        result = $.Deferred().resolve(model).promise().done();
	      }
	
	      this.showView(view);
	      return result;
	    },
	
	    showEditModel: function(model) {
	      var view = this.getEditView();
	
	      view.setModel(model);
	      this.showView(view);
	
	      this.loadModel(model).done(function() {
	        // call setModel again, so subviews can get newly loaded related models
	        if (model.related) {
	          view.setModel(model);
	        }
	      });
	    },
	
	    //
	    // View getters
	    //
	
	    /** Get and lazy create the index view */
	    getIndexView: function() {
	      if (!this.indexView) {
	        var index = this.indexView = this.createIndexView();
	      }
	
	      return this.indexView;
	    },
	
	    /** Get and lazy create the detail view */
	    getDetailView: function() {
	      if (!this.detailView) {
	        this.detailView = this.createDetailView();
	      }
	      return this.detailView;
	    },
	
	    getEditView: function() {
	      if (!this.editView) {
	        this.editView = this.createEditView();
	      }
	      return this.editView;
	    },
	
	    // Hooks
	
	    /** Create the index model from specified data. */
	    createIndexModel: function(options, meta) {
	      return this.createCollection(this.indexModelCls, options, meta);
	    },
	
	    /**
	     * Create the detail model from specified attributes.
	     * Override to add default attributes, eg empty relationships.
	     */
	    createDetailModel: function(urlId, attributes, viewState) {
	      var result = this.createModel(this.modelCls, urlId, attributes, viewState);
	      if (this.detailModel && result.url() === this.detailModel.url()) {
	        this.detailModel.set(attributes);
	        if (viewState) {
	          this.detailModel.setViewState(viewState);
	        }
	        result = this.detailModel;
	      }
	      return result;
	    },
	
	    /**
	     * Create the edit model from specified attributes.
	     * Override to add default attributes, eg empty relationships.
	     */
	    createEditModel: function(urlId, attributes, viewState) {
	      return this.createModel(this.modelCls, urlId, attributes, viewState);
	    },
	
	    /** Helper for creating the detail model. */
	    createModel: function(modelCls, urlId, attributes, viewState) {
	      attributes = attributes || {};
	      var options = {};
	      if (urlId) {
	        attributes = _.clone(attributes);
	        attributes[modelCls.prototype.urlIdAttribute] = urlId;
	      }
	      options.viewState = viewState;
	      return new modelCls(attributes, options);
	    },
	
	    createCollection: function(modelCls, options, meta) {
	      options = _.clone(options || {});
	      meta = _.clone(meta || {});
	      var filters = meta.filters;
	      if (filters) {
	        if (filters && typeof(filters) === 'string') {
	          meta.filters = JSON.parse(meta.filters);
	        }
	      }
	      options = _.extend(_.clone(this.indexModelOptions || {}), options);
	      options.meta = meta;
	      return new modelCls(null, options);
	    },
	
	    /** Create the index view. Feel free to override */
	    createIndexView: function () {
	      var index =  new this.indexViewCls();
	      index.on('itemSelected', this.onIndexItemSelected, this);
	      return index;
	    },
	
	    /** Create the detail view. Feel free to override */
	    createDetailView: function () {
	      return new this.detailViewCls();
	    },
	
	    /** Create the detail view. Feel free to override */
	    createEditView: function () {
	      return new this.editViewCls();
	    },
	
	    setActiveModel: function(model) {
	      if (this.activeModel) {
	        this.activeModel.off('change', this.onActiveModelChange, this);
	      }
	      this.activeModel = model;
	      if (this.activeModel) {
	        this.activeModel.on('change', this.onActiveModelChange, this);
	      }
	    },
	
	    // Event Handlers
	
	    onActiveModelChange: function() {
	      this.activeModel.updateUrl();
	    },
	
	    /** Show detail view on index item select */
	    onIndexItemSelected: function(selection) {
	      if(selection) {
	        var model = this.createDetailModel(null, selection.attributes);
	        model.navigate();
	      }
	    },
	
	    /** Reload the index model on change. eg sort field or filter change */
	    onIndexChange: function(collection) {
	      this.reloadIndex(collection);
	    },
	
	    onModelError: function(model, response, options) {
	      if (response.status === 404) {
	
	        this.createIndexModel().navigate({replace: true});
	        setTimeout(function() {
	          theApp.dispatch.trigger('message', this.notFoundMessage, 'bad');
	        }.bind(this), 500);
	      }
	    },
	
	    /**
	     * Debounced helper for reloading the index model
	     * @param {Plumage.model.Collection} collection Collection to reload
	     * @param {Boolean} updateUrl should update url? default to true
	     */
	    reloadIndex: _.debounce(function(collection) {
	      collection.load({reset: true});
	    }, 200)
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88), __webpack_require__(140), __webpack_require__(95)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, History, ModelUtil) {
	  return Plumage.Router = Backbone.Router.extend(
	  /** @lends Plumage.Router.prototype */
	  {
	    /** Routes config. Array of pairs [pattern, options]. Options must include controller and method */
	    controllerRoutes: undefined,
	
	    /** Root url of the application. Passed on to History */
	    rootUrl: '/',
	
	    /** If a route is not recognized, redirect to defaultUrl */
	    defaultUrl: '/',
	
	    /** use html5 push state? If false, falls back to using # for deep urls. */
	    pushState: true,
	
	    /**
	     * Routes requests to Controller handler methods.
	     *
	     * @extends external:Backbone.Router
	     * @constructs
	     */
	    initialize: function(options) {
	      options = options || {};
	      if (options.app !== undefined) {
	        this.app = options.app;
	      }
	
	      if (options.controllers !== undefined) {
	        this.controllers = options.controllers;
	      }
	      if (options.defaultUrl !== undefined) {
	        this.defaultUrl = options.defaultUrl;
	      }
	      if (options.rootUrl !== undefined) {
	        this.rootUrl = options.rootUrl;
	      }
	      if (options.pushState !== undefined) {
	        this.pushState = options.pushState;
	      }
	      if (options.history !== undefined) {
	        this.history = options.history;
	      } else {
	        this.history = new Plumage.History();
	      }
	
	
	      this.route('*path', 'defaultRoute', function(path){
	        if (window.location.pathname !== this.defaultUrl) {
	          window.location.pathname = this.defaultUrl;
	        }
	      });
	
	      if (this.controllerRoutes) {
	        for (var i = 0; i < this.controllerRoutes.length; i++) {
	          var route = this.controllerRoutes[i];
	          var routeOptions = route[1],
	            name = routeOptions.controller + '.' + routeOptions.method,
	            handler = _.bind(this.routeToController, this, routeOptions);
	          this.route(route[0], name, handler);
	        }
	      }
	    },
	
	    start: function() {
	      this.history.start({pushState: this.pushState, root: this.rootUrl});
	    },
	
	    /** Route handler that forwards to method 'options.method'
	     * in Controller 'options.controller'
	     *
	     * @params {Object} options Static options set when creating route
	     * @params {...} queryParams Remaining params used as query params
	     */
	    routeToController: function(options){
	      if (this.app.navView) {
	        this.app.navView.select(options.nav);
	      }
	      var controller = this.controllers[options.controller];
	      controller.runHandler(options.method, Array.prototype.slice.call(arguments, 1));
	    },
	
	    /**
	     * Override to switch to this.history
	     */
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) {
	        route = this._routeToRegExp(route);
	      }
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) {
	        callback = this[name];
	      }
	      var router = this;
	      this.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        router.execute(callback, args);
	        router.trigger.apply(router, ['route:' + name].concat(args));
	        router.trigger('route', name, args);
	        router.history.trigger('route', router, name, args);
	        router.logNavigationAction(window.location.href, window.location.pathname);
	      });
	
	      return this;
	    },
	
	    navigate: function(url, options) {
	      if (url === null || url === undefined) {
	        throw new Error('A "url" must be specified');
	      }
	
	      //remove host and protocol if it's local
	      if (url.indexOf(window.location.origin) === 0) {
	        url = url.slice(window.location.origin.length);
	      }
	
	      //remove url prefix
	      if (url.indexOf(this.rootUrl) === 0) {
	        url = url.slice(this.rootUrl.length);
	      }
	      this.history.navigate(url, options);
	    },
	
	    /** Special navigate method for working around Backbone's ignoring of query params. */
	    navigateWithQueryParams: function(url, options) {
	      this.navigate(url, options);
	    },
	
	    /**
	     * Template method hook for logging, eg post to google analytics
	     */
	    logNavigationAction: function(url, pageName) {
	      // do nothing
	    },
	
	    /**
	     * Override to parse query string
	     */
	    execute: function(callback, args) {
	      var queryParams = ModelUtil.parseQueryString(args.pop());
	      if (queryParams) {
	        args.push(queryParams);
	      }
	      if (callback) {
	        callback.apply(this, args);
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(2), __webpack_require__(88)], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	  Plumage.History = Backbone.History.extend(
	  /** @lends Plumage.History.prototype */
	  {
	    /**
	     * Need to override Backbone.History to stop it from
	      * doing nothing if only query params have changed, which started in 1.1
	     *
	     * @constructs
	     */
	    constructor: function() {
	      Backbone.History.apply(this, arguments);
	    },
	
	    /**
	     * Overridden to stop it from doing nothing if only query params have changed.
	     */
	    navigate: function(fragment, options) {
	      if (!Backbone.History.started) {
	        return false;
	      }
	      if (!options || options === true) {
	        options = {trigger: !!options};
	      }
	
	      var url = this.root + (fragment = this.getFragment(fragment || ''));
	
	      // Strip the fragment of the query and hash for matching.
	
	      //CHANGE
	      //fragment = fragment.replace(pathStripper, '');
	      ////////////
	
	      if (this.fragment === fragment) {
	        return;
	      }
	      this.fragment = fragment;
	
	      // Don't include a trailing slash on the root.
	      if (fragment === '' && url !== '/') {
	        url = url.slice(0, -1);
	      }
	
	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._hasPushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
	
	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if(!options.replace) {
	            this.iframe.document.open().close();
	          }
	          this._updateHash(this.iframe.location, fragment, options.replace);
	        }
	
	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) {
	        return this.loadUrl(fragment);
	      }
	    },
	
	  });
	  return Plumage.History;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(7),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, moment, Plumage) {
	  return Plumage.util.ArrayUtil = {
	    /**
	     * Similar to _.sortedIndex, but doesn't apply iterator to target value
	     */
	    findClosestIndexToValue: function(array, value, getValue, context) {
	      var low = 0, high = array.length;
	      while (low < high) {
	        var mid = Math.floor((low + high)/2);
	        if (getValue.call(context, array[mid]) < value) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return low;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(7),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, moment, Plumage) {
	  return Plumage.util.D3Util = {
	    /**
	     * Similar to _.sortedIndex, but doesn't apply iterator to target value
	     */
	    applyConfig: function(d3El, config, context) {
	      for (var key in config) {
	        if (!config.hasOwnProperty(key)) { return; }
	        d3El.attr(key, Plumage.util.D3Util.getAccessor(config[key], context));
	      }
	    },
	
	    /**
	     * Wrap accessor to add context as 3rd param.
	     * @param attr existing accessor function or value
	     * @returns wrapped accessor
	     */
	    getAccessor: function(attr, context) {
	      if (typeof(attr) === 'function') {
	        return function (d, i) {
	          return attr(d, i, context);
	        };
	      }
	      return attr;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	
	  /**
	   * Logger that posts log calls to the server.
	   *
	   * Stores logs in local storage on POST so they can be retried if the request fails.
	   *
	   * @constructs Plumage.util.Logger
	   */
	  var Logger = function(options) {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(Logger.prototype,
	  /** @lends Plumage.util.Logger.prototype */
	  {
	
	    /** Server url to post to. */
	    url: undefined,
	
	    /** Local storage key to store unsent logs in. */
	    localStorageKey: 'Plumage.util.Logger.failedLogs',
	
	    /** initialization logic. */
	    initialize: function(options) {
	      _.extend(this, options);
	      this.retryLogs();
	    },
	
	    /** Logs an error. Should add other log levels at some point. */
	    error: function(type, message) {
	      this.sendLog({level: 'error', type: type, message: message});
	    },
	
	    /** Send a log to the server. */
	    sendLog: function(data) {
	      if(data.time === undefined) { data.time = new Date().getTime(); }
	      this.storeLog(data);
	
	      Backbone.ajax({
	        type: 'POST',
	        url: this.url,
	        data: data,
	        success: this.getSuccessHandler(data).bind(this)
	      });
	    },
	
	    /**
	     * Gets logs from local storage.
	     * @returns {Array} List of unsent log Objects
	     */
	    getStoredLogs: function() {
	      var storedLogs = localStorage.getItem(this.localStorageKey);
	      if (storedLogs) {
	        try {
	          return JSON.parse(storedLogs);
	        } catch(e) {}
	      }
	      return [];
	    },
	
	    /** Try resending unsent logs. */
	    retryLogs: function() {
	      var storedLogs = this.getStoredLogs();
	      for (var i = 0; i < storedLogs.length; i++) {
	        this.sendLog(storedLogs[i]);
	      }
	    },
	
	    /** Store a log in local storage. */
	    storeLog: function(data) {
	      var storedLogs = this.getStoredLogs();
	      for ( var i = 0; i < storedLogs.length; i++) {
	        if (storedLogs[i].time === data.time && storedLogs[i].type === data.type) {
	          return;
	        }
	      }
	      storedLogs.push(data);
	      localStorage.setItem(this.localStorageKey, JSON.stringify(storedLogs));
	    },
	
	    /** Remove a log from local storage. */
	    removeLog: function(data) {
	      var logs = this.getStoredLogs();
	      if (logs) {
	        localStorage.setItem(this.localStorageKey, JSON.stringify(_.filter(logs, function(log){
	          return log.time !== data.time && log.type !== data.type;
	        })));
	      }
	    },
	
	    /** Delete all stored logs. */
	    clearLogs: function() {
	      localStorage.removeItem(this.localStorageKey);
	    },
	
	    //
	    // Event Handlers
	    //
	
	    /**
	     * Creates event handler that removes a stored log on success.
	     * @param {Object} data The log being sent. Stored in closure.
	     * @returns {function} The event handler
	     * @private
	     *
	     */
	    getSuccessHandler: function(data) {
	      return function(response, status, xhr) {
	        this.removeLog(data);
	      };
	    }
	  });
	
	  return Plumage.util.Logger = Logger;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModelView) {
	
	
	  return Plumage.view.CollectionView = ModelView.extend(
	  /** @lends Plumage.view.CollectionView.prototype */
	  {
	
	    className: 'collection-view',
	
	    /** Class of ModelView to render for each Model in the Collection. */
	    itemViewCls: undefined,
	
	    /** Map of options to pass into constructor of sub ModelViews. */
	    itemOptions: {},
	
	    template: '<ul class="items"></ul>{{#moreUrl}}<a class="more-link" href="{{.}}">more</a>{{/moreUrl}}',
	
	    /** Template to render when there are no items. */
	    emptyTemplate: 'No items',
	
	    /**
	     * url string or function(model) that returns url to go to for more pages of this view
	     */
	    moreUrl: undefined,
	
	    renderOnChange: false,
	
	    /**
	     * A ModelView that renders a sub ModelView for each item in its bound [Collection]{@link Plumage.collection.Collection}
	     *
	     * CAUTION: Item ModelViews must have a different [modelCls]{@link Plumage.view.ModelView#modelCls} than the CollectionView
	     * so they don't get the Collection bound to it.
	     *
	     * Item Views are kept in itemViews instead of subViews to prevent them from getting hit with containerView composite methods
	     * (not sure if this is really necessary).
	     *
	     * @constructs
	     * @extends Plumage.view.ModelView
	     */
	    initialize:function (options) {
	      ModelView.prototype.initialize.apply(this, arguments);
	      options = options || {};
	
	      if (typeof(this.emptyTemplate) === 'string') {
	        this.emptyTemplate = Handlebars.compile(this.emptyTemplate);
	      }
	      this.itemViews = [];
	    },
	
	    //
	    // overrides
	    //
	
	    getTemplateData: function() {
	      var moreUrl;
	      if (this.moreUrl && this.model && this.model.hasMore()) {
	        moreUrl = $.isFunction(this.moreUrl) ? this.moreUrl(this.model) : this.moreUrl;
	      }
	      var data = {
	        size: this.model && this.model.fetched ? this.model.size() : '',
	        moreUrl: moreUrl
	      };
	      return data;
	    },
	
	    /** Get the el to render subViews into. */
	    getItemsEl: function() {
	      return this.template ? this.$('.items') : this.$el;
	    },
	
	    onRender:function () {
	      if (this.template) {
	        this.$el.html(this.template(this.getTemplateData()));
	      }
	      var itemsEl = this.getItemsEl();
	      itemsEl.empty();
	
	      //keep for reuse
	      var oldItemViews = this.itemViews || [];
	      this.itemViews = [];
	
	      if (this.model && this.model.size()) {
	        this.model.forEach(function(model, i) {
	          var itemView = oldItemViews.pop() || this.renderItem();
	          itemView.setModel(model);
	          itemView.index = i;
	          //TODO could be optimized to not render if reusing view
	          itemView.render();
	
	          itemsEl.append(itemView.el);
	          if (this.shown) {
	            itemView.onShow();
	          }
	          this.itemViews.push(itemView);
	        }, this);
	      }
	
	      this.updateEmpty();
	
	      //remove extra views
	      _.each(oldItemViews, function(itemView){
	        itemView.remove();
	      }, this);
	      this.hideLoadingAnimation();
	    },
	
	    update: function() {
	      ModelView.prototype.update.apply(this, arguments);
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      ModelView.prototype.updateModel.apply(this, arguments);
	      var collection = this.getModelFromRoot(this.relationship, rootModel, parentModel);
	      if (collection) {
	        collection.each(function(model, index) {
	          if (index < this.itemViews.length) {
	            this.itemViews[index].updateModel(model);
	          }
	        }.bind(this));
	      }
	    },
	
	    //
	    // Helpers
	    //
	
	    /**
	     * Render a subView
	     * @private
	     */
	    renderItem: function() {
	      var view = new this.itemViewCls(this.itemOptions);
	      view.on('afterRender', this.onItemRender.bind(this));
	      return view;
	    },
	
	    /**
	     * Show/hide [emptyTemplate]{@link Plumage.view.CollectionView#emptyTemplate} if necessary.
	     * @private
	     */
	    updateEmpty: function() {
	      if ((!this.model || (this.model.fetched && this.model.size() === 0)) &&
	          this.emptyTemplate !== undefined) {
	
	        this.getItemsEl().html(this.emptyTemplate());
	      }
	    },
	
	    //
	    // Methods
	    //
	
	    /**
	     * Get the subView with bound model with the given id.
	     * @param {Object} itemId Id of bound model.
	     */
	    getItemView: function(itemId) {
	      for (var i=0;i<this.itemViews.length;i++) {
	        var itemView = this.itemViews[i];
	        if (itemView.model.id === itemId) {
	          return itemView;
	        }
	      }
	    },
	
	    /**
	     * Event Handlers
	     */
	
	    onModelAdd: function(model) {
	      if (this.isRendered) {
	        //TODO only render view for added model
	        this.update(true);
	      }
	    },
	
	    onModelRemove: function(model) {
	      if (this.isRendered) {
	        //TODO only remove view for removed model
	        this.update(true);
	      }
	    },
	
	    onModelLoad: function() {
	      ModelView.prototype.onModelLoad.apply(this, arguments);
	    },
	
	    onModelDestroy: function(model) {
	      for (var i=0;i<this.itemViews.length;i++) {
	        var itemView = this.itemViews[i];
	        if (itemView.model.id === model.id) {
	          itemView.remove();
	          break;
	        }
	      }
	      this.updateEmpty();
	    },
	
	    onShow: function() {
	      ModelView.prototype.onShow.apply(this, arguments);
	      this.eachItemView(function(itemView){
	        itemView.onShow();
	      });
	    },
	
	    onHide: function() {
	      ModelView.prototype.onHide.apply(this, arguments);
	      this.eachItemView(function(itemView){
	        itemView.onHide();
	      });
	    },
	
	    /**
	     * Helper method for calling a callback with ecah itemView
	     */
	    eachItemView: function(callback, scope) {
	      if (this.itemViews) {
	        _.each(this.itemViews, function(itemView) {
	          if (scope) {
	            callback.call(scope, itemView);
	          } else {
	            callback(itemView);
	          }
	        }, this);
	      }
	    },
	
	    onDoneLoad: function(){
	      this.hideLoadingAnimation();
	    },
	
	    onModelBeginLoad: function () {
	      this.showLoadingAnimation();
	    },
	
	    onItemRender: function(itemView) {
	      this.trigger('itemRender', this, itemView);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(146),
	  __webpack_require__(147),
	  __webpack_require__(121)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Form, TextArea, Comment) {
	
	  return Plumage.view.comment.CommentForm = Form.extend({
	
	    modelCls: Comment,
	
	    actionLabel: 'Comment',
	
	    initialize: function(options) {
	      Form.prototype.initialize.apply(this, arguments);
	      options = options || {};
	      this.subViews = [
	        new TextArea({
	          selector: '.fields',
	          valueAttr: 'body'
	        })
	      ];
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(3),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(95)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, _, Plumage, ModelView, ModelUtil) {
	
	  /**
	   * Container for a field subviews.
	   *
	   * Uses dom form events to detect changes and submits in fields.
	   */
	
	  return Plumage.view.form.Form = ModelView.extend({
	
	    tagName: 'form',
	
	    template: '<div class="fields"></div><input type="submit" value="{{actionLabel}}"/>',
	
	    actionLabel: 'Submit',
	
	    updateModelOnChange: false,
	
	    events: {
	      'submit': 'onSubmit',
	      'change': 'onChange'
	    },
	
	    initialize: function(options) {
	      ModelView.prototype.initialize.apply(this, arguments);
	    },
	
	    getTemplateData: function() {
	      var data = ModelView.prototype.getTemplateData.apply(this, arguments);
	      return _.extend(data, {
	        actionLabel: this.getActionLabel()
	      });
	    },
	
	    getActionLabel: function() {
	      return this.actionLabel ? this.actionLabel : 'Submit';
	    },
	
	    setMessage: function(message, messageCls) {
	      var messageView = this.getSubView('message');
	      if (messageView) {
	        messageView.setMessage(message, messageCls);
	      }
	    },
	
	    //
	    // actions
	    //
	
	    submit: function() {
	      if (!this.model) {
	        this.model = new this.modelCls();
	      }
	      if(this.isValid()) {
	        this.updateModel(this.rootModel);
	        var error;
	        if (this.model.validate) {
	          error = this.model.validate(this.model.attributes);
	        }
	        if(!error) {
	          this.model.save(null, {success: this.onSaveSuccess.bind(this)});
	        }
	      }
	    },
	
	    //
	    // Events
	    //
	
	    onChange: function(e) {
	      if (this.updateModelOnChange) {
	        this.onSubmit(e);
	      }
	      this.trigger('change', this, e);
	    },
	
	    onSubmit: function(e) {
	      e.preventDefault();
	      this.submit();
	    },
	
	    onSaveSuccess: function(model, resp, xhr) {
	      if (resp.meta.success) {
	        this.trigger('save', this, model);
	      } else {
	        if (resp.meta.message) {
	          this.setMessage(resp.meta.message, resp.meta.message_class);
	        }
	      }
	    },
	
	    onModelInvalid: function(model, validationError, message, messageCls) {
	      if (message) {
	        this.setMessage(message, messageCls);
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Field) {
	  return Plumage.view.form.fields.TextArea = Field.extend({
	    template: Handlebars.compile('<textarea {{#fieldName}}name="{{fieldName}}"{{/fieldName}}>{{value}}</textarea>'),
	
	    update: function(isLoad) {
	      return this.$('textarea').val(this.getValue());
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(145),
	  __webpack_require__(121),
	  __webpack_require__(144),
	  __webpack_require__(149),
	  __webpack_require__(152)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, ModelView, CommentForm, Comment, CollectionView, CommentView, template) {
	
	  return Plumage.view.comment.CommentsSection = ModelView.extend({
	
	    expandable: false,
	
	    expanded: false,
	
	    template: Handlebars.compile(template),
	
	    title: 'Comments',
	
	    events: {
	      'click .comments-toggle': 'onClickToggle'
	    },
	
	    getTemplateData: function() {
	      var label = 'No Comments';
	      if (this.model) {
	        var comments = this.model.getRelated('comments');
	        var count = comments ? comments.size() : 0;
	        if (count === 1) {
	          label = '1 Comment';
	        } else if (count > 1){
	          label = count + ' Comments';
	        }
	      }
	      return {
	        title: this.title,
	        expandable: this.expandable,
	        expanded: this.expandable ? this.expanded : true,
	        label: label
	      };
	    },
	
	    initialize: function(options) {
	      ModelView.prototype.initialize.apply(this, arguments);
	      options = options || {};
	      var emptyTemplate;
	      if (!this.expandable) {
	        emptyTemplate = '<div class="comment no-comments">No comments yet. Leave the first one.</div>';
	      }
	
	      //lazy init subviews
	      if (!this.expandable || this.expanded) {
	        this.initSubViews();
	      }
	    },
	
	    initSubViews: function() {
	      var emptyTemplate;
	      if (!this.expandable) {
	        emptyTemplate = '<div class="comment no-comments">No comments yet. Leave the first one.</div>';
	      }
	      this.subViews = [
	        this.commentsView = new CollectionView({
	          selector: '.comments',
	          itemViewCls: CommentView,
	          relationship: 'comments',
	          emptyTemplate: emptyTemplate
	        }),
	        this.commentForm = new CommentForm({selector: '.comment-form'})
	      ];
	      this.commentForm.on('save', this.onCommentFormSave.bind(this));
	      if (this.model) {
	        this.commentsView.setModel(this.model);
	        this.resetCommentForm();
	      }
	    },
	
	    setModel: function(rootModel, parentModel) {
	      ModelView.prototype.setModel.apply(this, arguments);
	      this.resetCommentForm();
	    },
	
	    getCommentableId: function(model) {
	      return model ? model.id : undefined;
	    },
	
	    getSubject: function(model) {
	      return undefined;
	    },
	
	    /**
	     * Event Handlers
	     */
	
	    onModelLoad: function() {
	      this.resetCommentForm();
	    },
	
	    onCommentFormSave: function(form, model) {
	      if (this.getSubject) {
	        model.set('subject', this.getSubject(model));
	      }
	      this.resetCommentForm();
	      this.model.getRelated('comments').add(model);
	      this.render();
	    },
	
	    onClickToggle: function(e) {
	      e.preventDefault();
	      if(!this.commentsView) {
	        this.initSubViews();
	        //let event propagation finish before re-rendering
	        setTimeout(function() {
	          this.render();
	          this.toggleComments();
	        }.bind(this), 0);
	      } else {
	        this.toggleComments();
	      }
	    },
	
	
	    /**
	     * Helpers
	     */
	
	    toggleComments: function() {
	      this.$('.comments-wrap').animate({'height': 'toggle'}, 200);
	      this.expanded = !this.expanded;
	    },
	
	    resetCommentForm: function() {
	      if (this.commentForm) {
	        this.commentForm.setModel(new Comment({
	          commentable_type: this.model.commentableType,
	          commentable_url: this.model.url(),
	          body: '',
	          subject: this.getSubject(this.model)
	        }));
	      }
	    }
	
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(121),
	  __webpack_require__(93),
	  __webpack_require__(150),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, moment, Plumage, Comment, ModelView, template) {
	
	  return Plumage.view.comment.CommentView = ModelView.extend({
	    className: 'comment',
	
	    modelCls: Comment,
	
	    template: Handlebars.compile(template),
	
	    events: {
	      'click .delete': 'onDeleteClick'
	    },
	
	    getTemplateData: function() {
	      if (this.model) {
	        var result = this.model.toViewJSON();
	        result.body = result.body.replace(/\n/g, '<br/>');
	        result.created_at = moment(result.created_at).fromNow();
	        result.can_delete = result.user.account === window.currentUser;
	        return result;
	      }
	      return {};
	    },
	
	    onRender: function() {
	      ModelView.prototype.onRender.apply(this, arguments);
	      var body = this.$('.comment-body');
	      body.linkify();
	      $('a', body).addClass('outlink').attr('target', '_');
	    },
	
	    onDeleteClick: function(e) {
	      e.preventDefault();
	      var collection = this.model.collection;
	      this.model.destroy();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "<h5 class=\"item-author-header\">\n  <img class=\"avatar\" src=\"{{ user.image_thumb }}\" />\n  <span class=\"name\">{{user.first_name}} {{user.last_name}}</span>\n  <span class=\"screenname muted\"> @{{user.screenname}}</span>\n  <span class=\"timestamp\">&mdash; {{created_at}}</span>\n</h5>\n<div class=\"comment-text\">\n  {{#can_delete}}\n    <a class='btn btn-mini btn-danger pull-right delete'>Delete</a>\n  {{/can_delete}}\n  <p class=\"comment-body\">\n  {{{body}}}\n  </p>\n</div>\n"

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, jQuery) {function recursiveLinkify(element, match, replacer) {
	
	    // For each content node in the given element,
	    $.each(
	        element.contents(),
	        function(index, element) {
	            element = $(element);
	
	            // Replace it's content if it's a text node
	            if (element.get(0).nodeType == document.TEXT_NODE) {
	                element.after($("<div />").text(element.text()).html().replace(match, replacer)).remove();
	            }
	
	            // Or recurse down into it if it's not an anchor or a button
	            else if (element.prop("tagName") != "A" && element.prop("tagName") != "BUTTON") {
	                recursiveLinkify(element, match, replacer);
	            }
	        }
	    );
	}
	
	(function($) {
	    $.fn.linkify = function(opts) {
	        return this.each(function() {
	
	            // Regex from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
	            var matchURLs = /\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/;
	            var replaceURLs = function(str) {
	                return "<a href='"+(str.indexOf("://") === -1 ? "http://" : "")+str+"'>"+str+"</a>";
	            }
	            recursiveLinkify($(this), matchURLs, replaceURLs);
	
	            // Regex from http://www.regular-expressions.info/email.html
	            var matchEmails = /\b[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/ig;
	            var replaceEmails = function(str) {
	                return "<a href='mailto:"+str+"'>"+str+"</a>";
	            }
	            recursiveLinkify($(this), matchEmails, replaceEmails);
	        });
	    }
	})(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "{{#expandable}}\n<a href=\"#\" class=\"comments-toggle\">{{label}}</a>\n{{/expandable}}\n{{^expandable}}\n{{#title}}\n<h4>{{.}}</h4>\n{{/title}}\n{{/expandable}}\n\n<div class=\"comments-wrap{{^expanded}} hidden{{/expanded}}\">\n  <div class=\"comments\">\n  </div>\n\n  <div class=\"comment-form\">\n  </div>\n  <div class=\"clear\"></div>\n</div>"

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(149),
	  __webpack_require__(154)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, ModelView, CommentView, template) {
	
	  return Plumage.view.comment.ExpandableComments = ModelView.extend({
	
	    template: Handlebars.compile(template),
	
	    itemViewCls: CommentView,
	
	    events: {
	      'click .comments-action': 'onActionClick'
	    },
	
	    getTemplateData: function() {
	      return {
	        comments: ModelView.prototype.getTemplateData.apply(this, arguments),
	        actionLabel: this.getActionLabel()
	      };
	    },
	
	    getActionLabel: function() {
	      var size = this.model.size();
	      if (size === 0) {
	        return 'comment';
	      } else if (size === 1) {
	        return '1 comment';
	      } else {
	        return this.model.size() + ' comments';
	      }
	    },
	
	    onActionClick: function() {
	      var el = this.$('.comment-wrapper');
	      if (el.hasClass('hidden')) {
	        el.removeClass('hidden');
	        el.find('.comment-text').focus();
	        window.setTimeout(function() { el.addClass('open'); }, 50);
	      } else {
	        el.removeClass('open');
	        window.setTimeout(function() { el.addClass('hidden'); }, 200);
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = "<a class=\"comments-action\" href=\"#\">{{actionLabel}}</a>\n<div class=\"floater-wrapper comment-wrapper hidden\">\n  <a href=\"#\" class=\"close comment-close\">&times;</a>\n  <div class=\"comments\">\n    {{#each comments}}\n    <div class=\"comment\">\n\t    <h5 class=\"item-author-header\">\n\t\t    <img class=\"avatar\" src=\"{{user.image_thumb}}\" />\n\t\t    <span class=\"name\">{{user.first_name}} {{user.last_name}}</span>\n\t\t    <span class=\"screenname muted\"> @{{user.screenname}}</span>\n\t\t    <span class=\"timestamp\">{{created_at}}</span>\n\t\t  </h5>\n\t\t\t<p class=\"comment-text\">\n\t\t\t  {{body}}\n\t\t\t</p>\n    </div>\n    {{/each}}\n  </div>\n\n  <form accept-charset=\"UTF-8\" action=\"/create_question\" method=\"post\">\n    <input id=\"id\" name=\"id\" type=\"hidden\" value=\"649\">\n    <textarea class=\"comment-text\" id=\"comment_649\" name=\"content\"></textarea>\n    <input class=\"btn comment_submit_button\" name=\"commit\" type=\"submit\" value=\"Comment\">\n  </form>\n</div>\n"

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(156)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ModelView, MessageView) {
	
	  return Plumage.view.controller.IndexView = ModelView.extend({
	
	    className: 'content container-fluid index-view',
	
	    template: '<div class="filter-view"></div><div class="grid-view"></div>',
	
	    gridViewCls: undefined,
	
	    filterViewCls: undefined,
	
	    gridOptions: undefined,
	
	    subViews: [{
	      viewCls: MessageView,
	      selector: '.message',
	      updateOnMessage: true,
	      replaceEl: true
	    }],
	
	    initialize:function (options) {
	      ModelView.prototype.initialize.apply(this, arguments);
	
	      this.subViews = this.subViews || [];
	
	      var gridView = this.getGridView();
	      if (gridView) {
	        this.subViews.push(gridView);
	        gridView.on('itemSelected', function(model) {
	          this.trigger('itemSelected', model);
	        }.bind(this));
	      }
	
	      var filterView = this.getFilterView();
	      if (filterView) { this.subViews.push(filterView); }
	    },
	
	    getGridView: function() {
	      if (!this.gridView && this.gridViewCls) {
	        this.gridView = new this.gridViewCls(
	          _.extend({selector: '.grid-view', filterView: this.getFilterView()}, this.gridOptions || {}));
	      }
	      return this.gridView;
	    },
	
	    getFilterView: function() {
	      if (!this.filterView && this.filterViewCls) {
	        this.filterView = new this.filterViewCls({selector: '.filter-view'});
	      }
	      return this.filterView;
	    },
	
	    onRender: function() {
	      $(this.el).html(this.template());
	    },
	
	    update: function(isLoad) {
	      //do nothing
	    },
	
	    onModelChange: function() {
	      //do nothing
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(157)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, ModelView, template) {
	
	  /**
	   * lists with selections need two models:
	   *  - one for list contents
	   *  - one for list selection
	   *
	   * The selection model, populated by the model hierarchy. The list model needs to be populated manually.
	   */
	  return Plumage.view.MessageView = ModelView.extend({
	
	    className: 'message',
	
	    template: template,
	
	    updateOnMessage: true,
	
	    fadeOutTime: 2500,
	
	    events: {
	      'click a': 'onLinkClick'
	    },
	
	    initialize: function() {
	      ModelView.prototype.initialize.apply(this, arguments);
	      if (this.updateOnMessage && typeof theApp !== 'undefined') {
	        theApp.dispatch.on('message', this.setMessage.bind(this));
	      }
	    },
	
	    onRender: function() {
	      ModelView.prototype.onRender.apply(this, arguments);
	      this.updateClass();
	    },
	
	    getTemplateData: function() {
	      var data = {
	        body: this.messageBody,
	        cls: this.messageCls
	      };
	      return data;
	    },
	
	    updateClass: function() {
	      var show = Boolean(this.messageBody);
	      this.$el.toggleClass('show', show);
	      if (this.fadeOutTime && show) {
	        setTimeout(function() {
	          this.$el.removeClass('show');
	          this.messageBody = undefined;
	        }.bind(this), this.fadeOutTime);
	      }
	    },
	    setMessage: function(messageBody, messageCls) {
	      this.messageBody = messageBody;
	      this.messageCls = messageCls;
	      if (this.shown) {
	        this.render();
	      }
	    },
	
	    onShow: function() {
	      ModelView.prototype.onShow.apply(this, arguments);
	      this.render();
	    },
	
	    setModel: function() {
	      this.messageBody = undefined;
	      this.messageCls = undefined;
	      ModelView.prototype.setModel.apply(this, arguments);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 157 */
/***/ function(module, exports) {

	module.exports = "\n{{#body}}\n<div class=\"message-body {{../cls}}\">\n{{{.}}}\n</div>\n{{/body}}\n"

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(159),
	  __webpack_require__(161)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, CategorySelect, template) {
	
	  return Plumage.view.form.fields.ButtonGroupSelect = CategorySelect.extend({
	
	    className: 'button-group-select',
	
	    template: Handlebars.compile(template),
	
	    events:{
	      'click li': 'onItemClick'
	    },
	
	    initialize: function() {
	      CategorySelect.prototype.initialize.apply(this, arguments);
	      this.$el.data('toggle', 'buttons-radio');
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(107),
	  __webpack_require__(160)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Select, template) {
	
	  return Plumage.view.form.fields.CategorySelect = Select.extend({
	
	    className: 'category-select field',
	
	    template: Handlebars.compile(template),
	
	    listValueAttr: 'name',
	    listLabelAttr: 'label',
	    modelAttr: 'filter',
	
	    noSelectionText: 'All',
	
	    noSelectionValue: '',
	
	    events:{
	      'click a': 'onItemClick'
	    },
	
	    initialize: function() {
	      Select.prototype.initialize.apply(this, arguments);
	    },
	
	    setModel: function() {
	      Select.prototype.setModel.apply(this, arguments);
	    },
	
	    /**
	     * Overrides
	     */
	    onListModelLoad: function(model, options) {
	      this.render();
	    },
	
	    onItemClick: function(e) {
	      e.preventDefault();
	      var li = $(e.target).closest('li'),
	        value = li && li.data('value');
	
	      this.setValue(value);
	    },
	
	    getItemData: function(item) {
	      return Select.prototype.getItemData.apply(this, arguments);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<input type=\"hidden\" {{#fieldName}}name=\"{{fieldName}}\"{{/fieldName}} value=\"{{value}}\">\n<ul class=\"nav nav-pills\">\n{{#if noSelectionText}}\n<li data-category=\"\" {{^hasSelection}}class=\"active\"{{/hasSelection}}>\n  <a href=\"{{noSelectionValue}}\">\n    {{noSelectionText}}\n  </a>\n</li>\n{{/if}}\n\n{{#listValues}}\n  <li data-value=\"{{value}}\" class=\"{{value}}{{#selected}} active{{/selected}}\"><a href=\"{{url}}\">{{label}}</a></li>\n{{/listValues}}\n</ul>"

/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports = "<input type=\"hidden\" {{#fieldName}}name=\"{{fieldName}}\"{{/fieldName}} value=\"{{value}}\"/>\n<ul class=\"btn-group\">\n{{#listValues}}\n  <li data-value=\"{{value}}\" class=\"btn {{value}}{{#selected}} active{{/selected}}\">{{label}}</li>\n{{/listValues}}\n</ul>\n"

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(163)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Field, template) {
	  return Plumage.view.form.fields.Checkbox = Field.extend(
	  /** @lends Plumage.view.form.fields.Checkbox.prototype */
	  {
	
	    fieldTemplate: template,
	
	    /** Label next to the checkbox. Optional */
	    checkboxLabel: '',
	
	    /** Model value to interpret as checked */
	    checkedValue: true,
	
	    /** Model value to interpret as unchecked */
	    uncheckedValue: false,
	
	    getTemplateData: function() {
	      var data = Field.prototype.getTemplateData.apply(this, arguments);
	      data.checkboxLabel = this.checkboxLabel;
	      if (this.getValue() === this.checkedValue) {
	        data.selected = true;
	      }
	      return data;
	    },
	
	    //override to ignore other non-relevant events
	    delegateEvents: function(events) {
	      events = events || _.result(this, 'events');
	      var selector = this.getInputSelector();
	      if (selector) {
	        events = _.clone(events || {});
	        events['change ' +selector] = 'onChange';
	      }
	      Backbone.View.prototype.delegateEvents.apply(this, [events]);
	    },
	
	    getValueFromDom: function() {
	      return this.$('input:checked').val();
	    },
	
	    processDomValue: function(value) {
	      return value === 'true' ? this.checkedValue : this.uncheckedValue;
	    },
	
	    update: function() {
	      if (this.isRendered) {
	        this.render();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports = "{{#if checkboxLabel}}\n<label class=\"{{cls}}\">\n{{/if}}\n  <input type=\"checkbox\" name=\"{{valueAttr}}\" {{#selected}}checked=\"true\"{{/selected}} value=\"true\">\n{{#if checkboxLabel}}\n  <span>{{checkboxLabel}}</span>\n</label>\n{{/if}}\n"

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(112),
	  __webpack_require__(90),
	  __webpack_require__(89),
	  __webpack_require__(111),
	  __webpack_require__(105)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, moment, Plumage, DateTimeUtil, Field, FieldWithPicker, Calendar, HourSelect) {
	
	  return Plumage.view.form.fields.DateField = FieldWithPicker.extend(
	  /** @lends Plumage.view.form.fields.DateField.prototype */
	  {
	
	    fieldTemplate: '<div class="input-prepend"><button class="btn" data-toggle="dropdown" data-target="#"><i class="icon-calendar"></i></button>'+FieldWithPicker.prototype.fieldTemplate+'</div>',
	
	    className: 'date-field',
	
	    /** format string for showing the selected date. See moment.js */
	    format: 'MMM D, YYYY',
	
	    events: {
	      'click input': 'onInputClick',
	      'click button': 'onButtonClick'
	    },
	
	    pickerOptions: {
	      applyOnChange: true,
	      subViews: [{
	        viewCls: Calendar,
	        name: 'calendar',
	        minDateAttr: 'minDate',
	        maxDateAttr: 'maxDate'
	      }]
	    },
	
	    subViews: [{
	      viewCls: HourSelect,
	      name: 'hourSelect',
	      selector: '.field',
	      opens: 'right',
	      tagName: 'span'
	    }],
	
	    utc: false,
	
	    keepTime: false,
	
	    minDate: undefined,
	    maxDate: undefined,
	
	    minDateAttr: undefined,
	    maxDateAttr: undefined,
	
	    showHourSelect: false,
	
	    /**
	     * Field with a popover calendar for selecting a date.
	     *
	     * The value can also be set by editing the text field directly, as long as it can be parsed back into a date.
	     *
	     * See a live demo in the [Kitchen Sink example]{@link /examples/kitchen_sink/form/FieldsAndForms}.
	     *
	     * @constructs
	     * @extends Plumage.view.form.fields.Field
	     */
	    initialize: function(options) {
	
	      FieldWithPicker.prototype.initialize.apply(this, arguments);
	      var calendar = this.getCalendar();
	      calendar.utc = this.utc;
	
	      var hourSelect = this.getSubView('hourSelect');
	      hourSelect.utc = this.utc;
	      hourSelect.valueAttr = this.valueAttr;
	      hourSelect.updateModelOnChange = this.updateModelOnChange;
	      hourSelect.relationship = this.relationship;
	      this.setShowHourSelect(this.showHourSelect);
	
	      if (this.minDate) {
	        this.setMinDate(this.minDate);
	      }
	      if (this.maxDate) {
	        this.setMaxDate(this.maxDate);
	      }
	    },
	
	    getCalendar: function() {
	      return this.getPicker().getSubView('calendar');
	    },
	
	    setMinDate: function(minDate) {
	      minDate = DateTimeUtil.parseRelativeDate(minDate);
	      this.getPicker().model.set('minDate', minDate);
	      this.getSubView('hourSelect').setMinDate(minDate);
	    },
	
	    setMaxDate: function(maxDate) {
	      maxDate = DateTimeUtil.parseRelativeDate(maxDate);
	      this.getPicker().model.set('maxDate', maxDate);
	      this.getSubView('hourSelect').setMaxDate(maxDate);
	    },
	
	    setShowHourSelect: function(showHourSelect) {
	      this.showHourSelect = showHourSelect;
	      this.$el.toggleClass('show-hour-select', this.showHourSelect);
	      if(this.isRendered) {
	        this.render();
	      }
	    },
	
	
	    //
	    // Overrides
	    //
	
	    onInput: function(e) {
	      //do nothing on typing. Wait for blur
	    },
	
	    processValueForDom: function(value) {
	      if (value) {
	        var m = this.utc ? moment.utc(value) : moment(value);
	        return m.format(this.format);
	      }
	      return '';
	    },
	
	    isDomValueValid: function(value) {
	      var m = this.utc ? moment.utc(value) : moment(value);
	      return !value || m.isValid && m.isValid() && this.getCalendar().isDateInMinMax(value);
	    },
	
	    processDomValue: function(value) {
	      if (value) {
	        var m = this.utc ? moment.utc(value) : moment(value);
	        var oldValue = this.getValue();
	        if (oldValue && (this.keepTime || this.showHourSelect)) {
	          var oldM = this.utc ? moment.utc(oldValue) : moment(oldValue);
	          m.hour(oldM.hour()).minute(oldM.minute()).second(oldM.second()).millisecond(oldM.millisecond());
	        }
	        return m.valueOf();
	      }
	      return null;
	    },
	
	    processPickerValue: function(value) {
	      return this.processDomValue(value);
	    },
	
	    onModelChange: function(e) {
	      FieldWithPicker.prototype.onModelChange.apply(this, arguments);
	      this.updateValueFromModel();
	    },
	
	
	    onKeyDown: function(e) {
	      if (e.keyCode === 13) { //on enter
	        e.preventDefault();
	        this.updateValueFromDom();
	      } else if(e.keyCode === 27) {
	        this.update();
	      }
	    },
	
	    updateValueFromModel: function() {
	      FieldWithPicker.prototype.updateValueFromModel.apply(this, arguments);
	      if (this.minDateAttr) {
	        this.setMinDate(this.model.get(this.minDateAttr));
	      }
	      if (this.maxDateAttr) {
	        this.setMaxDate(this.model.get(this.maxDateAttr));
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(143)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, Logger) {
	
	  /**
	   * Global object responsible for initializing your App as well as the Controllers and Nav etc.
	   *
	   * After creating it, pass your app to your Router.
	   *
	   * @constructs Plumage.App
	   */
	  var App = function(options) {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(App.prototype, Backbone.Events,
	  /** @lends Plumage.App.prototype */
	  {
	    /** Keeps track of the current top level view */
	    views: {current: null},
	
	    /** Should init cross-site request forgery token in $.ajax. See jQuery docs */
	    initCSRFToken: false,
	
	    /** Initialization logic. Feel free to extend */
	    initialize: function(options) {
	      _.extend(this, options);
	
	      this.registerHandlebarsHelpers();
	
	      if (this.initCSRFToken) {
	        $.ajaxSetup({
	          headers: {
	            'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
	          }
	        });
	      }
	      this.dispatch = _.extend({}, Backbone.Events);
	    },
	
	    registerHandlebarsHelpers: function() {
	      Handlebars.registerHelper('setIndex', function(value){
	        this.index = Number(value + 1); //I needed human readable index, not zero based
	      });
	    },
	
	    getViewState: function() {
	      var view = this.views.current;
	
	      if (view && view.model) {
	        return view.model.getQueryParams();
	      }
	      return {};
	    }
	  });
	
	  App.extend = Backbone.Model.extend;
	
	  return Plumage.App = App;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(167),
	  __webpack_require__(169)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, MultiSelect, template) {
	  /**
	   * Like a normal field, except value is an array of selected values.
	   */
	  return Plumage.view.form.fields.DropdownMultiSelect = MultiSelect.extend({
	
	    template: template,
	
	    showSelectOnly: true,
	
	    events:{
	      'click li a': 'onItemClick',
	      'click li input': 'onItemClick',
	      'click li.select-all a': 'onSelectAllClick',
	      'click li.select-all input': 'onSelectAllClick',
	      'click .dropdown-toggle': 'onToggleClick'
	    },
	
	    initialize: function() {
	      this.value = [];
	      MultiSelect.prototype.initialize.apply(this, arguments);
	    },
	
	    /** overrides **/
	
	    getTemplateData: function() {
	      var data = MultiSelect.prototype.getTemplateData.apply(this, arguments);
	      data.showSelectOnly = this.showSelectOnly;
	      return data;
	    },
	
	    onRender: function() {
	      MultiSelect.prototype.onRender.apply(this, arguments);
	    },
	
	    update: function(isLoad) {
	      var open = this.$('.dropdown').hasClass('open');
	      this.render();
	      if (open) {
	        this.$('.dropdown').addClass('open');
	      }
	    },
	
	    /** Event Handlers **/
	
	    onItemClick: function(e) {
	
	      var li = $(e.target).closest('li'),
	        value = li && li.data('value');
	
	      if (value !== undefined) {
	        e.preventDefault();
	        e.stopPropagation();
	        if ($(e.target).hasClass('only-link')) {
	          this.setValue(value);
	        } else {
	          this.toggleValue(value);
	        }
	      }
	    },
	
	    onSelectAllClick: function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.toggleSelectAll();
	    }
	  });
	
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(107),
	  __webpack_require__(168),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Select, template) {
	  /**
	   * Like a normal field, except value is an array of selected values.
	   */
	  return Plumage.view.form.fields.MultiSelect = Select.extend({
	
	    template: template,
	
	    showSelectAll: false,
	
	    allLabel: 'All',
	
	    initialize: function() {
	      this.value = [];
	      Select.prototype.initialize.apply(this, arguments);
	    },
	
	    /** overrides **/
	
	    getTemplateData: function() {
	      var data = Select.prototype.getTemplateData.apply(this, arguments);
	      data.showSelectAll = this.showSelectAll;
	      data.allSelected = _.all(data.listValues, function(x){ return x.selected;});
	      return data;
	    },
	
	    onRender: function() {
	      Select.prototype.onRender.apply(this, arguments);
	    },
	
	    getValue: function() {
	      var value = Select.prototype.getValue.apply(this, arguments);
	      if (value !== undefined) {
	        return $.isArray(value) ? _.clone(value) : [value];
	      }
	      return [];
	    },
	
	    getValueLabel: function(value) {
	      if (!this.listModel) {
	        return '';
	      }
	
	      var labels = [];
	      if (value && value.length) {
	        this.listModel.each(function(item) {
	          if (this.isValueSelected(this.getListItemValue(item))) {
	            labels.push(this.getListItemLabel(item));
	          }
	        }.bind(this));
	      }
	
	      if (labels.length === this.listModel.size()) {
	        return this.allLabel;
	      }
	      return labels.join(', ');
	    },
	
	    isValueSelected: function(value) {
	      return _.contains(this.getValue(), value);
	    },
	
	    hasSelection: function() {
	      var value = this.getValue();
	      return Boolean(value && (value.length > 1 || value.length === 1 && value[0] !== this.noSelectionValue));
	    },
	
	    /** methods **/
	
	    toggleValue: function(value, options) {
	      var me = this;
	      var currentValue = this.getValue();
	      var index = currentValue.indexOf(value);
	      if (index < 0) {
	        index = _.sortedIndex(currentValue, value, function(value) {
	          var item = me.listModel.find(function(x){
	            return me.getListItemValue(x) === value;
	          });
	          return me.listModel.indexOf(item);
	        });
	        currentValue.splice(index, 0, value);
	        this.setValue(currentValue, options);
	      } else {
	        currentValue.splice(index, 1);
	        this.setValue(currentValue, options);
	      }
	    },
	
	    setValueSelected: function(value, selected) {
	      if (selected === undefined) {
	        selected = true;
	      }
	      var currentValue = this.getValue();
	      if (this.isValueSelected(value) !== selected) {
	        this.toggleValue(value);
	      }
	    },
	
	    selectAll: function() {
	      var newValues = this.listModel.map(function(item){
	        return this.getListItemValue(item);
	      }.bind(this));
	      this.setValue(newValues);
	    },
	
	    selectNone: function() {
	      this.setValue([]);
	    },
	
	    toggleSelectAll: function() {
	      var value = this.getValue();
	      if (value && value.length === this.listModel.size()) {
	        this.selectNone();
	      } else {
	        this.selectAll();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<select {{#if fieldName}}name=\"{{fieldName}}{{/if}}\" multiple=\"multiple\">\n{{#if noSelectionText}}\n<option value=\"{{noSelectionValue}}\" {{^hasSelection}}selected=\"true\"{{/hasSelection}}>{{noSelectionText}}</option>\n{{/if}}\n\n{{#listValues}}\n<option value=\"{{value}}\" class=\"{{value}}\" {{#selected}}selected{{/selected}}>{{label}}</option>\n{{/listValues}}\n</select>"

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dropdown-multiselect dropdown\">\n<select {{#if fieldName}}name=\"{{fieldName}}\"{{/if}} style=\"display: none\">\n{{#if noSelectionText}}\n<option value=\"{{noSelectionValue}}\" {{^hasSelection}}selected=\"true\"{{/hasSelection}}>{{noSelectionText}}</option>\n{{/if}}\n{{#listValues}}\n<option value=\"{{value}}\" {{#selected}}selected{{/selected}}>{{label}}</option>\n{{/listValues}}\n</select>\n\n<a class=\"btn dropdown-toggle {{buttonCls}}\" data-toggle=\"dropdown\" href=\"#\">\n  {{#iconCls}}\n    <i class=\"{{.}} icon-white\"></i>\n  {{/iconCls}}\n  {{#if hasSelection}}\n    {{valueLabel}}\n  {{else}}\n    {{noSelectionText}}\n  {{/if}}\n  <span class=\"caret\"></span>\n</a>\n<ul class=\"dropdown-menu {{#if showSelectOnly}}show-select-only{{/if}}\">\n  {{#if showSelectAll}}\n  <li class=\"select-all {{#allSelected}}active{{/allSelected}}\">\n      <a><input type=\"checkbox\" {{#allSelected}} checked{{/allSelected}}/>Select All</a>\n  </li>\n  {{/if}}\n  {{#listValues}}\n  <li data-value=\"{{value}}\" class=\"{{value}}{{#selected}} active{{/selected}}\">\n      {{#if ../showSelectOnly}}\n        <a href=\"#\" class=\"only-link\">only</a>\n      {{/if}}\n      <a class=\"item\"><input type=\"checkbox\" {{#selected}} checked{{/selected}}/>{{label}}</a>\n  </li>\n  {{/listValues}}\n</ul>\n</div>"

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(171)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, Field, template) {
	  return Plumage.view.form.fields.DurationField = Field.extend({
	
	    className: 'duration-field control-group',
	
	    fieldTemplate: template,
	
	    units: [
	      {label: 'minutes', value: 60000},
	      {label: 'hours', value: 3600000},
	      {label: 'days', value: 86400000}
	    ],
	
	    validationRules: {number: true, minValue: 0},
	
	    events: {
	      'change select': 'onUnitChange'
	    },
	
	    /**
	     * View state. Value of selected unit.
	     */
	    selectedUnit: undefined,
	
	    initialize: function() {
	      Field.prototype.initialize.apply(this, arguments);
	      if (!this.selectedUnit) {
	        this.selectedUnit = this.units[0].value;
	      }
	    },
	
	    getTemplateData: function() {
	      var data = Field.prototype.getTemplateData.apply(this, arguments);
	
	      data.units = _.map(this.units, function (unit) {
	        var result =  _.clone(unit);
	        if (this.selectedUnit !== undefined && result.value === this.selectedUnit) {
	          result.selected = true;
	        }
	        return result;
	      }.bind(this));
	
	      return data;
	    },
	
	    processValueForDom: function(value) {
	      if (!isNaN(Number(value))) {
	        if (value && this.selectedUnit !== undefined) {
	          return value/this.selectedUnit;
	        }
	      }
	      return value;
	    },
	
	    getUnitForValue: function(value) {
	      var selectedIndex = 0;
	      for (var i = 0; i < this.units.length; i++) {
	        if (value % this.units[i].value === 0) {
	          selectedIndex = i;
	        }
	      }
	      return this.units[selectedIndex].value;
	    },
	
	    getValueFromDom: function() {
	      var value = Field.prototype.getValueFromDom.apply(this, arguments);
	      if ($.isNumeric(value)) {
	        return value * this.selectedUnit;
	      }
	      return value;
	    },
	
	    valueChanged: function(fromModel) {
	      if (fromModel) {
	        this.autoSelectUnit();
	      }
	    },
	
	    autoSelectUnit: function() {
	      this.selectedUnit = this.getUnitForValue(this.getValue());
	    },
	
	    update: function(isLoad) {
	      Plumage.view.form.fields.Field.prototype.update.apply(this, arguments);
	      if (this.isRendered) {
	        this.$('select').val(this.selectedUnit);
	      }
	    },
	
	    //
	    // Events
	    //
	
	    onUnitChange: function() {
	      this.selectedUnit = Number($(arguments[0].target).val());
	      this.update();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 171 */
/***/ function(module, exports) {

	module.exports = "<input type=\"text\" name=\"{{valueAttr}}\" {{#placeholder}}placeholder=\"{{.}}\"{{/placeholder}} value=\"{{value}}\" {{#readonly}}readonly=\"readonly\"{{/readonly}} {{#disabled}}disabled=\"true\"{{/disabled}}/>\n<select {{#readonly}}readonly=\"readonly\"{{/readonly}} {{#disabled}}disabled=\"true\"{{/disabled}}>\n{{#units}}\n    <option value=\"{{value}}\" class=\"{{value}}\" {{#selected}}selected{{/selected}}>{{label}}</option>\n{{/units}}\n</select>"

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(162)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Checkbox) {
	
	
	  return Plumage.view.form.fields.FilterCheckbox = Checkbox.extend({
	
	    filterKey: undefined,
	
	    filterValue: true,
	
	    invertMatch: false,
	
	    checkboxLabel: undefined,
	
	    comparison: 'equals',
	
	    updateModelOnChange: true,
	
	    processFilterValue: function(value) {
	      return ((value === this.filterValue) !== this.invertMatch) ? true : false;
	    },
	
	    processValueForFilter: function(value) {
	      return (value !== this.invertMatch) ? this.filterValue : undefined;
	    },
	
	    getValueFromModel: function() {
	      if (this.model) {
	        var filters = this.model.getFilters(this.filterKey),
	          value;
	        if (filters && filters.length) {
	          value = filters[0].get('value');
	        }
	        return this.processFilterValue(value);
	      }
	      return undefined;
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.processValueForFilter(this.getValue()),
	        filters = this.model.getFilters(this.filterKey);
	
	      if (model) {
	        if (filters && filters.length) {
	          if (value === undefined || String(value) === '') {
	            this.model.removeFilter(filters[0]);
	          } else {
	            filters[0].set('value', value);
	          }
	        } else {
	          if (value !== undefined && String(value) !== '') {
	            model.addFilter(new Plumage.model.Filter({key: this.filterKey, comparison: this.comparison, value: value}));
	          }
	        }
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(174),
	  __webpack_require__(117)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, TypeAhead, Filter) {
	
	
	  return Plumage.view.form.fields.FilterTypeAhead = TypeAhead.extend(
	  /** @lends Plumage.view.form.fields.FilterTypeAhead.prototype */
	  {
	
	    filterKey: undefined,
	
	    comparison: 'equals',
	
	    updateModelOnChange: true,
	
	    /**
	     * TypeAhead that uses this.model's filters on as its model.
	     *
	     * @constructs
	     * @extends Plumage.view.form.fields.TypeAhead
	     */
	    initialize: function() {
	      TypeAhead.prototype.initialize.apply(this, arguments);
	    },
	
	    //Currently copy-paste to-from FilterField. Move to mixin?
	    getValueFromModel: function() {
	      if (this.model) {
	        var filters = this.model.getFilters(this.filterKey);
	        if (filters && filters.length) {
	          return filters[0].get('value');
	        }
	      }
	      return undefined;
	    },
	
	    setModel: function() {
	      TypeAhead.prototype.setModel.apply(this, arguments);
	    },
	
	    //Currently copy-paste to-from FilterField. Move to mixin?
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.getValue(),
	        filters = this.model.getFilters(this.filterKey);
	
	      if (model) {
	        if (filters && filters.length) {
	          if (value === undefined || String(value) === '') {
	            this.model.removeFilter(filters[0]);
	          } else {
	            filters[0].set('value', value);
	          }
	        } else {
	          if (value !== undefined && String(value) !== '') {
	            model.addFilter(new Filter({key: this.filterKey, comparison: this.comparison, value: value}));
	          }
	        }
	      }
	      return true;
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(107),
	  __webpack_require__(101),
	  __webpack_require__(175),
	  __webpack_require__(176)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, Field, Select, requestManager, template, menuTemplate) {
	
	  return Plumage.view.form.fields.TypeAhead = Select.extend(
	  /** @lends Plumage.view.form.fields.TypeAhead.prototype */
	  {
	
	    template: template,
	
	    menuTemplate: menuTemplate,
	
	    tagName: 'span',
	
	    valueAttr: 'name',
	    labelAttr: 'name',
	
	    shown: false,
	
	    /**
	     * @constructs
	     * @extends Plumage.view.form.fields.Select
	     */
	    initialize:function() {
	      Select.prototype.initialize.apply(this, arguments);
	      this.menuTemplate = this.initTemplate(menuTemplate);
	    },
	
	    events: {
	      'keypress input': 'onKeyPress',
	      'click button': 'onClearClick'
	    },
	
	    getTemplateData: function() {
	      var data = Select.prototype.getTemplateData.apply(this, arguments),
	        listModel = this.listModel,
	        query = listModel ? listModel.get('query') : undefined;
	      if (query) {
	        data.value = query;
	      }
	      data.menuShown = this.menuShown;
	      data.loading = this.loading;
	      return data;
	    },
	
	    onRender:function () {
	      Select.prototype.onRender.apply(this, arguments);
	      this.renderMenu();
	      this.updateCancelButton();
	    },
	
	    setValue: function(value) {
	      Select.prototype.setValue.apply(this, arguments);
	      this.listModel.set('query', undefined);
	    },
	
	    /*
	     * SelectedId represents the current selection in the menu, not the current value
	     */
	    setSelectedId: function(newId) {
	      if (newId !== this.selectedId) {
	        this.selectedId = newId;
	        this.updateMenu();
	      }
	    },
	
	    update: function(isLoad) {
	      Select.prototype.update.apply(this, arguments);
	      if(this.listModel) {
	        this.updateCancelButton();
	      }
	    },
	
	    delegateEvents: function(events) {
	
	      events = events || _.result(this, 'events');
	      var selector = '.dropdown-menu';
	      events = _.clone(events || {});
	      events['mousedown ' +selector] = 'onMenuMouseDown';
	      events['click ' +selector] = 'onMenuClick';
	
	      Field.prototype.delegateEvents.apply(this, [events]);
	    },
	
	    undelegateEvents: function(events) {
	      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
	    },
	
	    /*
	     * Menu
	     *****************/
	
	    renderMenu: function() {
	      var data = this.getTemplateData();
	      this.$('.dropdown-menu').html(this.menuTemplate(data));
	    },
	
	    updateMenu: function() {
	      if (this.listModel) {
	        var liEls = this.$('.dropdown-menu').find('li');
	        liEls.removeClass('active');
	        if (this.selectedId) {
	          var index = this.listModel.indexOf(this.listModel.getById(this.selectedId));
	          if (index !== -1) {
	            $(liEls[index]).addClass('active');
	          } else {
	            this.selectedId = undefined;
	          }
	        }
	      }
	    },
	
	    showMenu: function() {
	      this.$('> span').addClass('open');
	      this.menuShown = true;
	    },
	
	    hideMenu: function() {
	      this.$('> span').removeClass('open');
	      this.menuShown = false;
	    },
	
	    getItemData: function(instance) {
	      return {
	        value: instance.id,
	        label: instance.get(this.labelAttr),
	        selected: instance.id === this.selectedId
	      };
	    },
	
	    next: function (event) {
	      var listModel = this.listModel,
	        index = 0;
	
	      if (listModel && listModel.size()) {
	        if (this.selectedId) {
	          index = listModel.indexOf(listModel.getById(this.selectedId));
	          index = (index+1) % listModel.size();
	        }
	        this.setSelectedId(listModel.at(index).get('name'));
	      }
	    },
	
	    prev: function (event) {
	      var listModel = this.listModel,
	        index = 0;
	
	      if (listModel && listModel.size()) {
	        if (this.selectedId) {
	          index = listModel.indexOf(listModel.getById(this.selectedId));
	          index -= 1;
	          index = index < 0 ? index + listModel.size() : index;
	        }
	        this.setSelectedId(listModel.at(index).get('name'));
	      }
	    },
	
	    select: function () {
	      this.setValue(this.selectedId);
	      this.listModel.set('query', undefined);
	      this.getInputEl().blur();
	      this.hideMenu();
	      this.triggerChange();
	    },
	
	    resetInput: function() {
	      this.$('input').val(this.getValue());
	    },
	
	    /*
	     * Event Handlers
	     *****************/
	
	    onModelLoad: function (collection, resp) {
	      Select.prototype.onModelLoad.apply(this, arguments);
	      this.update(true);
	    },
	
	    onKeyDown: function (e) {
	      this.suppressKeyPressRepeat = !$.inArray(e.keyCode, [40,38,9,13,27]);
	
	      if (!this.shown) { return; }
	
	      e.stopPropagation();
	      switch(e.keyCode)
	      {
	      case 9: // tab
	        e.preventDefault();
	        break;
	      case 13: // enter
	        if (this.shown || this.loading) {
	          e.preventDefault();
	          this.select();
	        }
	        break;
	      case 27: // escape
	        if (this.shown) {
	          e.preventDefault();
	          this.resetInput();
	          this.hideMenu();
	        }
	        break;
	      case 38: // up arrow
	        e.preventDefault();
	        this.prev();
	        break;
	      case 40: // down arrow
	        e.preventDefault();
	        this.next();
	        break;
	      }
	    },
	
	    onChange: function (e) {
	      //do nothing
	    },
	
	    onInput: function (e) {
	      this.listModel.set({query: this.getValueFromDom()});
	      this.updateQuery();
	      this.showMenu();
	    },
	
	    onFocus: function (e) {
	      this.updateQuery();
	      this.showMenu();
	    },
	
	    onBlur: function (e) {
	      this.hideMenu();
	      this.resetInput();
	    },
	
	    /**
	     * Prevent onBlur when clicking the menu.
	     */
	    onMenuMouseDown: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	    },
	
	    onMenuClick: function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var li = $(e.target).parent('li');
	      if (li.length) {
	        var value = li.data('value');
	        if (value) {
	          this.setSelectedId(value);
	          this.select();
	        }
	      }
	    },
	
	    updateQuery: function() {
	      if (!this.listModel) {
	        return;
	      }
	      requestManager.loadModel(this.listModel, {
	        data: {
	          limit: 10, //change this to actual value
	          offset: 0
	        }
	      });
	      this.loading = true;
	    },
	
	    updateCancelButton: function() {
	      if (!this.$input) {
	        return;
	      }
	      var value = this.$input.val();
	      if (value.length === 0) {
	        this.$('button').attr('disabled', 'disabled');
	      } else {
	        this.$('button').removeAttr('disabled');
	      }
	
	    },
	
	    onClearClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var value = this.getValue();
	      if (value && value.length > 0) {
	        this.setValue('');
	        this.updateQuery();
	        this.hideMenu();
	        this.blur();
	        this.update();
	        this.triggerChange();
	      }
	      this.updateCancelButton();
	    },
	
	    /**
	     * For override
	     */
	
	    setModel: function(rootModel, parentModel) {
	      Select.prototype.setModel.apply(this, arguments);
	    },
	
	    /*
	     * Override Select
	     ********************************/
	
	    onListModelChange: function(event, model) {
	      //don't update, just rerender the menu
	      this.renderMenu();
	    },
	
	    onListModelLoad: function(listModel, request) {
	      var query = listModel.get('query') ? listModel.get('query') : '';
	
	      //discard result if query has already changed
	      if (query !== this.$('input').val()) {
	        return;
	      }
	
	      if (this.listModel.size() && (!this.selectedId || this.listModel.getById(this.selectedId) === undefined) ) {
	        this.selectedId = this.listModel.at(0).id;
	        console.log('autoselecting: ' + this.selectedId);
	      }
	      this.loading = false;
	      this.renderMenu();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports = "<span class=\"typeahead-select {{#if menuShown}}open{{/if}}\">\n<span class=\"input-append\">\n  <input type=\"text\" placeholder=\"{{noSelectionText}}\" value=\"{{value}}\">\n  <button class=\"btn cancel-typeahead\"><i class=\"icon-remove\"></i></button>\n</span>\n\n<ul class=\"dropdown-menu\">\n</ul>\n</span>"

/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports = "\n{{#if loading}}\n<li class=\"loading\"></li>\n{{else}}\n{{#listValues}}\n  <li data-value=\"{{value}}\" class=\"{{value}}{{#selected}} active{{/selected}}\"><a href=\"#\">{{label}}</a></li>\n{{/listValues}}\n{{^listValues}}\n<li class=\"no-results\"><a>No Results</a></li>\n{{/listValues}}\n{{/if}}"

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(178)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Field, template) {
	  return Plumage.view.form.fields.InPlaceTextField = Field.extend({
	    template: template,
	
	    className: 'inplace-field',
	
	    events: {
	      'click .field-value': 'onFieldValueClick'
	    },
	
	    update: function() {
	      Field.prototype.update.apply(this, arguments);
	      if (!this.isEditing()) {
	        this.render();
	      }
	    },
	
	    //
	    // helpers
	    //
	
	    commit: function() {
	      this.updateValueFromDom();
	      this.hideField();
	      this.update();
	    },
	
	    cancel: function() {
	      this.hideField();
	      this.update();
	    },
	
	    isEditing: function() {
	      return this.$el.hasClass('editing');
	    },
	
	    showField: function() {
	      this.$el.addClass('editing');
	      this.getInputEl().focus();
	    },
	
	    hideField: function() {
	      this.$el.removeClass('editing');
	    },
	
	    //
	    // handlers
	    //
	
	    onChange: function(e) {
	      //do nothing. commit on hide instead of change.
	    },
	
	    onInput: function(e) {
	      //do nothing. commit on hide instead of change.
	    },
	
	    onFieldValueClick: function() {
	      this.showField();
	    },
	
	    onBlur: function() {
	      this.commit();
	    },
	
	    onKeyDown: function(e) {
	      if (e.keyCode === 13) { //on enter
	        e.preventDefault();
	        this.commit();
	      } else if (e.keyCode === 27) { //on escape
	        this.cancel();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = "<div class=\"control-group {{#if validationState}}{{validationState}}{{/if}}\">\n{{#if label}}\n  <label class=\"control-label\" for=\"{{valueAttr}}\">{{label}}</label>\n  <div class=\"controls\">\n{{/if}}\n    <div class=\"field-value {{#unless hasValue}}no-value{{/unless}}\">\n      <i class=\"icon-pencil\"></i>\n      <span>{{#if hasValue}}{{value}}{{else}}{{placeholder}}{{/if}}</span>\n\t  </div>\n    {{> field}}\n    <span class=\"help-inline\">{{#if message}}{{message}}{{/if}}</span>\n{{#if label}}\n  </div>\n{{/if}}\n</div>\n"

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(180)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, Field, template) {
	  return Plumage.view.form.fields.Radio = Field.extend({
	
	    template: Handlebars.compile(template),
	
	    //value, label, cls
	    items: [],
	
	    getTemplateData: function() {
	      var data = Field.prototype.getTemplateData.apply(this, arguments);
	      data.items = [];
	      for (var i=0; i < this.items.length; i++) {
	        var item = _.clone(this.items[i]);
	        data.items.push(item);
	        if (this.getValue() === item.value) {
	          item.selected = true;
	        }
	      }
	      return data;
	    },
	
	    updateValue: function() {
	      this.value = this.getValueFromModel();
	      if (this.isRendered) {
	        this.render();
	      }
	    },
	
	    getValueFromDom: function() {
	      return this.$('input:checked').val();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 180 */
/***/ function(module, exports) {

	module.exports = "{{#items}}\n<label class=\"radio {{cls}}\">\n  <input type=\"radio\" name=\"{{../fieldName}}\" {{#selected}}checked=\"true\"{{/selected}} value=\"{{value}}\">\n  <span>{{label}}</span>\n</label>\n{{/items}}\n"

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(179),
	  __webpack_require__(182)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Radio, template) {
	  return Plumage.view.form.fields.RadioButtonGroup = Radio.extend({
	
	    template: Handlebars.compile(template),
	
	    events: {
	      'click button': 'onChange'
	    },
	
	    onChange: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      var newValue = $(e.target).data('value');
	      if (!this.changing) {
	        this.setValue(newValue, {silent: true});
	      }
	      this.trigger('change', this, this.getValue());
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 182 */
/***/ function(module, exports) {

	module.exports = "<div class=\"btn-group\">\n{{#items}}\n  <button type=\"button\" class=\"btn {{#selected}}active{{/selected}}\" data-value=\"{{value}}\">{{label}}</button>\n{{/items}}\n</div>"

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(184)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Field, template) {
	
	  return Plumage.view.form.SearchField = Field.extend(
	  /** @lends Plumage.view.form.fields.SearchField.prototype */
	  {
	    template: template,
	
	    className: 'search-field',
	
	    //need to add bootstrap search-query class
	    fieldTemplate: '<input type="text" class="search-query" name="{{valueAttr}}" {{#placeholder}}placeholder="{{.}}"{{/placeholder}} value="{{value}}"/>',
	
	    valueAttr: 'query',
	
	    updateModelOnChange: true,
	
	    events: {
	      'click button': 'onSubmitClick'
	    },
	
	    onKeyDown: function(e) {
	      if (e.keyCode === 13) { //on enter
	        e.preventDefault();
	        this.trigger('submit', this, this.getValue());
	      }
	    },
	
	    onSubmitClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.trigger('submit', this, this.getValue());
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports = "{{> field}}\n<button><i class=\"icon-search\"></i></button>\n"

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(107),
	  __webpack_require__(186)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Select, template) {
	
	  return Plumage.view.form.SelectField = Select.extend({
	
	    tagName: 'select',
	
	    className: 'select-field',
	
	    template: Handlebars.compile(template),
	
	    // attribute of the list items used as the key of available selections
	    listValueAttr: undefined,
	
	    // attribute of the list items used as the label of available selections
	    listLabelAttr: undefined,
	
	    // attribute of the model representing the selection
	    modelAttr: undefined,
	
	    noSelectionText: '',
	
	    value: '',
	
	    events: {
	      'change': 'onChange'
	    },
	
	    initialize:function() {
	      Select.prototype.initialize.apply(this, arguments);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = "<option value=\"{{noSelectionValue}}\" {{^hasSelection}}selected=\"true\"{{/hasSelection}}>{{noSelectionText}}</option>\n{{#items}}\n<option {{#selected}}selected=\"true\"{{/selected}} value=\"{{value}}\">{{label}}</option>\n{{/items}}"

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(146),
	  __webpack_require__(93),
	  __webpack_require__(188),
	  __webpack_require__(183),
	  __webpack_require__(189),
	  __webpack_require__(95),
	  __webpack_require__(191)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, Form, ModelView, FilterField, SearchField,
	    DropdownMenu, ModelUtil, template) {
	
	  /**
	   * Contains special fields defined declaratively that collectively affect a collection's filter meta attribute.
	   *
	   * Currently each field must be customized to update the filter in updateModel. Maybe this aspect could me
	   * moved down into FilterView.
	   */
	  return Plumage.view.grid.FilterView = Form.extend({
	
	    className: 'form-inline filter-view',
	
	    template: Handlebars.compile(template),
	
	    showSearch: true,
	
	    searchEmptyText: 'Search',
	
	    filterConfigs: [],
	
	    defaultFieldCls: FilterField,
	
	    moreMenuItems: [{value: 'download', label: 'Download', icon: 'arrow-down'}],
	
	    initialize: function(options) {
	      var me = this;
	
	      Form.prototype.initialize.apply(this, arguments);
	      options = options || {};
	
	      this.filterFields = [];
	      this.subViews = _.clone(this.subViews) || [];
	
	          _.each(this.filterConfigs, function(config){
	            var filterConfig = _.extend({}, {
	              selector: '.filters',
	              className: 'filter-field',
	              relationship: this.relationship
	            }, config);
	            var fieldCls = config.fieldCls || this.defaultFieldCls;
	            var filter = new fieldCls(filterConfig);
	            this.subViews.push(filter);
	            this.filterFields.push(filter);
	      }, this);
	
	      if (this.showSearch) {
	        this.searchField = new SearchField({
	          selector: '.search',
	          noSelectionText: this.searchEmptyText,
	          modelAttr: 'query'
	        });
	        this.subViews.push(this.searchField);
	      }
	
	      this.subViews.push(this.moreMenu = new DropdownMenu({
	        selector: '.more-menu',
	        buttonStyle: true,
	        iconCls: 'icon-cog',
	        label: '',
	        menuItems: this.moreMenuItems,
	        opens: 'left',
	        replaceEl: true
	      }));
	
	      this.subViews.concat(options.subViews || []);
	
	      _.each(this.filterFields, function(filterField){
	        if (filterField.listModelCls) {
	          var listModelParams = filterField.listModelParams || {};
	          var model = this.createFilterListModel(filterField.listModelCls, listModelParams);
	          filterField.setListModel(model);
	        }
	      }, this);
	    },
	
	    getTemplateData: function() {
	      var data = Form.prototype.getTemplateData.apply(this, arguments);
	      data.hasFilters = this.filterConfigs.length > 0;
	      return data;
	    },
	
	    createFilterListModel: function(listModelCls, listModelParams) {
	      return new listModelCls(null, listModelParams);
	    },
	
	    onRender: function() {
	      $(this.el).html(this.template({
	        searchQuery: ''
	      }));
	    },
	
	    update: function(isLoad) {
	      //don't rerender nothing
	    },
	
	    setModel: function() {
	      Plumage.view.ModelView.prototype.setModel.apply(this, arguments);
	    },
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(90),
	  __webpack_require__(117)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, Field, Filter) {
	
	
	  return Plumage.view.form.fields.FilterField = Field.extend({
	
	    className: 'filter-text-field',
	
	    filterKey: undefined,
	
	    comparison: 'contains',
	
	    updateModelOnChange: true,
	
	    getValueFromModel: function() {
	      if (this.model) {
	        var filters = this.model.getFilters(this.filterKey);
	        if (filters && filters.length) {
	          return filters[0].get('value');
	        }
	      }
	      return undefined;
	    },
	
	    updateModel: function(rootModel, parentModel) {
	      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
	        value = this.getValue(),
	        filters = this.model.getFilters(this.filterKey);
	
	      if (model) {
	        if (filters && filters.length) {
	          if (value === undefined || String(value) === '') {
	            this.model.removeFilter(filters[0]);
	          } else {
	            filters[0].set('value', value);
	          }
	        } else {
	          if (value !== undefined && String(value) !== '') {
	            model.addFilter(new Filter({key: this.filterKey, comparison: this.comparison, value: value}));
	          }
	        }
	      }
	      return true;
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(190),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, Handlebars, Plumage, ModelView, template) {
	
	  return Plumage.view.menu.DropdownMenu = ModelView.extend({
	    template: template,
	
	    className: 'dropdown',
	
	    buttonStyle: false,
	
	    menuItems: [],
	
	    iconCls: undefined,
	
	    showCaret: true,
	
	    opens: 'right',
	
	    events: {
	      'click li a': 'onItemClick'
	    },
	
	    getTemplateData: function() {
	      return {
	        label: this.label,
	        iconCls: this.iconCls,
	        menuItems: this.getMenuItems(),
	        showCaret: this.showCaret,
	        buttonStyle: this.buttonStyle,
	        dropdownCls: this.opens === 'left' ? 'pull-right' : ''
	      };
	    },
	
	    setLabel: function(label) {
	      this.label = label;
	      this.render();
	    },
	
	    getMenuItems: function() {
	      return this.menuItems;
	    },
	
	    /** Methods **/
	
	    open: function() {
	      this.$el.addClass('open');
	    },
	
	    close: function() {
	      this.$el.removeClass('open');
	    },
	
	    /** Event Handlers **/
	
	    onItemClick: function(e) {
	      this.trigger('itemClick', this, $(e.target).data('value'));
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 190 */
/***/ function(module, exports) {

	module.exports = "\n<a class=\"dropdown-toggle {{#buttonStyle}}btn{{/buttonStyle}}\" data-toggle=\"dropdown\" href=\"#\">\n\t{{#iconCls}}<i class=\"{{.}}\"></i>{{/iconCls}}\n\t{{label}}\n  {{#showCaret}}<b class=\"caret\"/>{{/showCaret}}\n</a>\n<ul class=\"dropdown-menu {{dropdownCls}}\" role=\"menu\">\n  {{#menuItems}}\n  <li>\n    <a data-value=\"{{value}}\">{{#icon}}<i class=\"icon-{{.}}\"></i>{{/icon}}{{label}}</a>\n  </li>\n  {{/menuItems}}\n</ul>\n"

/***/ },
/* 191 */
/***/ function(module, exports) {

	module.exports = "\n{{#if hasFilters}}<span>Filter by:</span>{{/if}}\n\n<span class=\"filters\"></span>\n\n<span class=\"actions\"></span>\n\n\n<span class=\"more-menu\"></span>\n\n<span class=\"actions-right\"></span>\n\n<span class=\"search\"></span>\n"

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(88),
	  __webpack_require__(112)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Backbone, moment, Plumage, DateTimeUtil) {
	
	  return Plumage.view.grid.Formatters = {
	
	    MoneyFormatter: function(row, cell, value, columnDef, dataContext) {
	      if (value && value.toFixed) {
	        return value.toFixed(2);
	      }
	      return value;
	    },
	
	    DateFromNowFormatter: function(row, cell, value, columnDef, dataContext) {
	      return DateTimeUtil.formatDateFromNow(value);
	    },
	
	    DateFormatter: function(row, cell, value, columnDef, dataContext) {
	      return DateTimeUtil.formatDate(value, columnDef.dateFormat);
	    },
	
	    DateFormatterUTC: function(row, cell, value, columnDef, dataContext) {
	      return DateTimeUtil.formatDateUTC(value, columnDef.dateFormat);
	    },
	
	    DurationFormatter: function(row, cell, value, columnDef, dataContext) {
	      return DateTimeUtil.formatDurationShort(Number(value));
	    },
	
	    NameWithCommentsFormatter: function(row, cell, value, columnDef, dataContext) {
	      var count = dataContext.get('comments_count');
	      if (count > 0) {
	        return value + '<span class="comments-count-icon">' + count + '</span>';
	      } else {
	        return value;
	      }
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(194),
	  __webpack_require__(102),
	  __webpack_require__(127),
	  __webpack_require__(128)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ModelView, GridData, BufferedCollection, GridSelection, Slick) {
	
	  return Plumage.view.grid.GridView = ModelView.extend({
	
	    className: 'grid-view',
	
	    columns: undefined,
	
	    gridOptions: {},
	
	    gridDataCls: GridData,
	
	    defaultGridOptions: {
	      editable: false,
	      multiSelect: false,
	      explicitInitialization: true,
	      rowHeight: 34,
	      dataItemColumnValueExtractor: function(item, columnDef) {
	        return item.get(columnDef.field);
	      }
	    },
	
	    selection: undefined,
	
	    firstShow: true,
	
	    infiniteScroll: true,
	
	    checkboxSelect: false,
	
	    checkboxColumn: {
	      id: 'checkbox-select',
	      cssClass: 'checkbox-select',
	      field: 'sel',
	      width: 30,
	      resizable: false,
	      sortable: false
	    },
	
	    noDataText: 'No Rows Found',
	
	    saveViewState: true,
	
	    filterView: undefined,
	
	    initialize: function () {
	      var me = this;
	      ModelView.prototype.initialize.apply(this, arguments);
	
	      //checkbox select
	      if (this.checkboxSelect) {
	        this.columns = _.clone(this.columns);
	        this.columns.unshift(_.extend({
	          formatter: function(row, cell, value, columnDef, dataContext) {
	            if (dataContext) {
	              var selected = this.selection.isSelectedId(dataContext.id);
	              return selected ? '<input type="checkbox" checked="checked">' : '<input type="checkbox">';
	            }
	            return null;
	          }.bind(this)
	        }, this.checkboxColumn));
	      }
	
	      var gridData = this.createGridData();
	
	      this.gridEl = $('<div class="grid"></div>');
	      this.grid = new Slick.Grid(this.gridEl, gridData, this.columns, _.extend({}, this.defaultGridOptions, this.gridOptions));
	      this.grid.onClick.subscribe(this.onGridClick.bind(this));
	
	      this.grid.onSort.subscribe(this.onSort.bind(this));
	
	      if (this.infiniteScroll) {
	        this.grid.onViewportChanged.subscribe(function (e, args) {
	          var vp = this.grid.getViewport();
	          this.ensureGridData(vp.top, vp.bottom);
	        }.bind(this));
	      }
	
	      if (this.filterView) {
	        this.setFilterView(this.filterView);
	      }
	
	      this.onResize = _.debounce(this.onResize, 50);
	    },
	
	    delegateEvents: function(events) {
	      ModelView.prototype.delegateEvents.apply(this, arguments);
	      $(window).on('resize.delegateEvents'+ this.cid, this.onResize.bind(this));
	    },
	
	    undelegateEvents: function(events) {
	      ModelView.prototype.undelegateEvents.apply(this, arguments);
	      $('window').off('.delegateEvents'+ this.cid);
	    },
	
	    onRender: function () {
	//      this.grid.scrollToLastRendered();
	      $(this.el).append(this.gridEl);
	    },
	
	    setModel: function(rootModel, parentModel) {
	      var oldModel = this.model;
	      ModelView.prototype.setModel.apply(this, arguments);
	      if (this.model && this.model !== oldModel) {
	        this.grid.setData(this.createGridData(this.model));
	        if (this.shown) {
	          var vp = this.grid.getViewport();
	          this.ensureGridData(vp.top, vp.bottom);
	          this.grid.updateRowCount();
	          this.grid.render();
	        }
	      }
	    },
	
	    setSelection: function(selection) {
	      if (this.selection) {
	        this.selection.off('all', this.onSelectionChanged, this);
	      }
	      this.selection = selection;
	      this.selection.on('all', this.onSelectionChanged, this);
	
	      this.grid.setSelectionModel(new GridSelection(selection));
	    },
	
	    setFilterView: function(filterView) {
	      if (this.filterView) {
	        this.filterView.moreMenu.off('itemClick', this.onMoreMenuItemClick, this);
	      }
	      this.filterView = filterView;
	      this.filterView.moreMenu.on('itemClick', this.onMoreMenuItemClick, this);
	    },
	
	    /**
	     * Helpers
	     */
	
	    createGridData: function(model) {
	      if (model) {
	        if (this.infiniteScroll) {
	          model = new BufferedCollection(model);
	          model.on('pageLoad', this.onPageLoad.bind(this));
	        }
	        return new this.gridDataCls(model);
	      }
	      return [];
	    },
	
	    ensureGridData: _.debounce(function(from, to) {
	      this.grid.getData().ensureData(from, to);
	    }, 200),
	
	    downloadCSV: function() {
	      if (!this.model) {
	        return;
	      }
	      var total = this.model.get('total');
	      if (!this.model.hasMore()) {
	        this._doDownloadCSV(this.model);
	      } else {
	        var model = this.model.clone();
	        model.set({page: 0, pageSize: total});
	        this.showLoadingAnimation();
	        model.load({success: function() {
	          this.hideLoadingAnimation();
	          this._doDownloadCSV(model);
	        }.bind(this)});
	      }
	    },
	
	    _doDownloadCSV: function(model) {
	      var data = [],
	        columns = this.grid.getColumns(),
	        titles = _.map(columns, function(column){ return column.name; });
	      model.each(function(item, iRow){
	        var rowData = [];
	        for (var iCol = 0; iCol < columns.length; iCol++) {
	          var column = columns[iCol];
	          var value = item.get(column.field);
	          if (column.formatter) {
	            value = column.formatter(iRow, iCol, value, column, item);
	            if (typeof(value) === 'string') {
	              value = value.replace(/<(?:.|\n)*?>/gm, ''); //strip html
	            }
	          }
	          rowData.push(value);
	        }
	        data.push(rowData);
	      });
	
	      var csv = titles.join(',') + '\n';
	      csv += _.map(data, function(rowData) { return rowData.join(','); }).join('\n');
	
	      //window.location = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
	    },
	
	    /*
	     * Event Handlers
	     *********************/
	
	    onModelLoad: function(models, options) {
	      if (!this.infiniteScroll) {
	        this.onDoneLoad();
	        if (this.isRendered) {
	          this.grid.invalidate();
	          this.updateNoData();
	          this.grid.scrollRowToTop(0);
	        }
	      }
	      if (models && models.get && models.get('sortField')) {
	        this.grid.setSortColumn(models.get('sortField'), String(models.get('sortDir')) === '1');
	      }
	    },
	
	    onModelChange: function(models, options) {
	    },
	
	    onShow: function() {
	      ModelView.prototype.onShow.apply(this, arguments);
	      if (this.gridEl.closest('html').length === 0) {
	        $(this.el).append(this.gridEl);
	      }
	      if (this.firstShow) {
	        this.firstShow = false;
	        this.grid.init();
	      } else {
	        this.grid.scrollToLastRendered();
	      }
	      this.grid.resizeCanvas();
	    },
	
	    onHide: function() {
	      ModelView.prototype.onHide.apply(this, arguments);
	      $(this.gridEl).detach();
	    },
	
	    onGridClick: function(e, args) {
	      var target = e.target;
	
	      if (target.tagName === 'A' && $(target).attr('href')) {
	        if (!$(target).hasClass('outlink')) {
	          e.preventDefault();
	          window.router.navigateWithQueryParams($(target).attr('href'), {trigger: true});
	        }
	        return false;
	      }
	
	      if (this.grid.getColumns()[args.cell].id === 'checkbox-select') {
	        if (this.selection) {
	          this.toggleRowSelected(args.row);
	        }
	        e.stopPropagation();
	        return;
	      }
	
	      var cell = this.grid.getCellFromEvent(e);
	      var item = this.grid.getDataItem(cell.row);
	      if (item) {
	        var id = this.grid.getDataItem(cell.row).id,
	        data = this.grid.getData(),
	        model = data.getItem(data.getIndexForId(id));
	        this.trigger('itemSelected',  model);
	      }
	    },
	
	    toggleRowSelected: function(index) {
	      this.selection.toggleIndex(index);
	    },
	
	    onSelectionChanged: function(event, selection, model, options) {
	      if (event === 'add' || event === 'remove') {
	        this.grid.invalidateRow(this.grid.getData().getIndexForId(model.id));
	      } else if (event === 'reset') {
	        this.grid.invalidate();
	      }
	      if (this.rendered) {
	        this.grid.render();
	      }
	    },
	
	    onResize: function() {
	      if (this.shown) {
	        this.grid.resizeCanvas();
	      }
	    },
	
	    onSort: function (e, options) {
	      var sortDir = options.sortAsc ? 1 : -1,
	        sortField = options.sortCol.field;
	
	      this.model.setSort(sortField, sortDir, false);
	    },
	
	    onMoreMenuItemClick: function(menu, value) {
	      if (value === 'download') {
	        this.downloadCSV();
	      }
	    },
	
	    /**
	     * Infinite scroll events
	     */
	
	    onBeginPageLoad: function() {
	      this.showLoadingAnimation();
	    },
	
	    onPageLoad: function(gridData, from, to) {
	      for (var i = from; i < to; i++) {
	        this.grid.invalidateRow(i);
	      }
	
	      this.grid.updateRowCount();
	      this.grid.render();
	
	      this.hideLoadingAnimation();
	      this.updateNoData();
	    },
	
	    /**
	     * Loading animation
	     */
	
	    updateNoData: function() {
	      if (!this.noDataEl) {
	        this.noDataEl = $('<div class="no-data">' + this.noDataText + '</div>');
	        $(this.el).append(this.noDataEl);
	      }
	      if (this.grid && this.grid.getData() && this.grid.getData().getLength && this.grid.getData().getLength() === 0) {
	        this.noDataEl.show();
	      } else {
	        this.noDataEl.hide();
	      }
	    },
	
	    onDoneLoad: function(){
	      this.hideLoadingAnimation();
	    },
	
	    onModelBeginLoad: function () {
	      ModelView.prototype.onModelBeginLoad.apply(this, arguments);
	      this.showLoadingAnimation();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	
	
	  /**
	   * Adapts a backbone Collection to the slickgrid data interface.
	   * @constructs Plumage.collection.GridData
	   */
	  var GridData = function() {
	    this.initialize.apply(this, arguments);
	  };
	
	  _.extend(GridData.prototype, Backbone.Events,
	  /** @lends Plumage.collection.GridData.prototype */
	  {
	
	    /** List of events to forward from the Collection */
	    relayEventNames: ['reset'],
	
	    /** The wrapped collection */
	    collection: undefined,
	
	    /** Initializtion logic */
	    initialize: function(collection, options) {
	      _.extend(this, options);
	      this.collection = collection;
	      this.collection.on('all', this.relayEvent, this);
	    },
	
	    ensureData: function(from, to) {
	      if (this.collection.ensureData) {
	        this.collection.ensureData(from, to);
	      }
	    },
	
	    /** calls setSort on Collection */
	    setSort: function(sortField, sortDir){
	      this.collection.setSort(sortField, sortDir, true);
	    },
	
	    /** gets size of collection  */
	    getLength: function() {
	      return this.collection.size();
	    },
	
	    /** get the model at the given index. */
	    getItem: function(index) {
	      return this.collection.at(index);
	    },
	
	    /** Can be overridden to provide row specific options for slickgrid */
	    getItemMetadata: function(index) {
	      return null;
	    },
	
	    /** Get the indes of the model with the given id. */
	    getIndexForId: function (id) {
	      var model = this.collection.getById(id);
	      return this.collection.indexOf(model);
	    },
	
	    /**
	     * Forwards events from Collection as if they were triggered on GridData
	     * @private
	     */
	    relayEvent: function(eventName) {
	      if (_.contains(this.relayEventNames, eventName)) {
	        this.trigger.apply(this, arguments);
	      }
	    }
	  });
	
	  GridData.extend = Backbone.Model.extend;
	
	  return Plumage.view.grid.GridData = GridData;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(196)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ModelView, template) {
	
	  return Plumage.view.grid.Pager = ModelView.extend({
	
	    className: 'pager',
	
	    template: template,
	
	    events: {
	      'click .pager .previous a': 'onPreviousClick',
	      'click .pager .next a': 'onNextClick',
	    },
	
	    getTemplateData: function() {
	      return {
	        atFirstPage: this.atFirstPage(),
	        atLastPage: this.atLastPage()
	      };
	    },
	
	    atFirstPage: function() {
	      if (this.model) {
	        return this.model.get('page') === 0;
	      }
	      return false;
	    },
	
	    atLastPage: function() {
	      if (this.model) {
	        return this.model.size() < this.model.get('pageSize');
	      }
	      return false;
	    },
	
	    onPreviousClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      if (!this.atFirstPage()) {
	        var page = this.model.get('page');
	        this.model.set('page', Math.max(page-1, 0));
	        this.model.load();
	      }
	    },
	
	    onNextClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var page = this.model.get('page'),
	        pageSize = this.model.get('pageSize'),
	        atLastPage = this.model.size() < pageSize;
	
	      if (!this.atLastPage()) {
	        this.model.set('page', page+1);
	        this.model.load();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 196 */
/***/ function(module, exports) {

	module.exports = "<ul class=\"pager\">\n  <li class=\"previous {{#if atFirstPage}}disabled{{/if}}\"><a href=\"#\">&larr;Previous</a></li>\n  <li class=\"next {{#if atLastPage}}disabled{{/if}}\"><a href=\"#\">Next &rarr;</a></li>\n</ul>"

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(198)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModelView, ListView) {
	
	  /**
	   * A selectable list and corresponding detail view.
	   */
	  return Plumage.view.ListAndDetailView = ModelView.extend({
	
	    className: 'list-and-detail-view',
	
	    template: '<div class="list"></div><div class="detail"></div>',
	
	    listOptions: {},
	
	    detailViewCls: undefined,
	
	    events: {
	      'click .select': 'onSelect'
	    },
	
	    initialize:function(options) {
	      options = options || {};
	      this.subViews = [
	        this.listView = new ListView(_.extend({
	          selector: '.list',
	          className: 'list-view'
	        }, this.listOptions)),
	        this.detailView = this.createDetailView()
	      ].concat(options.subViews || []);
	      ModelView.prototype.initialize.apply(this, arguments);
	
	      this.listView.on('selectionChange', this.onSelect.bind(this));
	    },
	
	    createDetailView: function() {
	      return new this.detailViewCls({selector: '.detail', replaceEl: true});
	    },
	
	    onRender: function(){
	      $(this.el).html(this.template());
	    },
	
	    onSelect: function(selectedId) {
	      var selectedModel = this.listView.model.getById(selectedId);
	      this.detailView.setModel(selectedModel);
	    },
	
	    update: function() {
	      //do nothing
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(3), __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(126),
	  __webpack_require__(144),__webpack_require__(199) ], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage,
	      Selection, CollectionView, ListItemView) {
	
	  /**
	   * ListView is a CollectionView that renders a selectable, navigable UL.
	   */
	  return Plumage.view.ListView = CollectionView.extend({
	
	    tagName : 'ul',
	
	    selection : undefined,
	
	    selectionAttr: 'selectionId',
	
	    className : 'list-view',
	
	    itemViewCls: ListItemView,
	
	    selectable : true,
	
	    /**
	     * Select first item by default
	     */
	    autoselect: true,
	
	    initialize : function(options) {
	      var me = this;
	      CollectionView.prototype.initialize.apply(this, arguments);
	
	      if (this.selectable && !this.selection) {
	        this.setSelectionModel(new Selection());
	      }
	    },
	
	    setSelectionModel: function(selection) {
	      if (this.selection) {
	        this.selection.off('change', this.onSelectionChange, this);
	      }
	      this.selection = selection;
	      this.selection.on('change', this.onSelectionChange, this);
	      this.autoSelectFirst();
	      this.updateSelection();
	    },
	
	    onRender : function() {
	      CollectionView.prototype.onRender.apply(this, arguments);
	      this.autoSelectFirst();
	      this.updateSelection();
	    },
	
	    /** Overrides */
	    renderItem: function() {
	      var itemView = CollectionView.prototype.renderItem.apply(this, arguments);
	      itemView.on('select', this.onItemViewSelect.bind(this));
	      return itemView;
	    },
	
	    update: function() {
	      CollectionView.prototype.update.apply(this, arguments);
	      this.autoSelectFirst();
	    },
	
	    /** Event Handlers */
	
	    onSelectionChange: function() {
	      if (this.selectable) {
	        this.updateSelection();
	        this.trigger('selectionChange', this.selection.get(this.selectionAttr));
	      }
	    },
	
	    onItemViewSelect: function(view, model) {
	      this.select(model.id);
	    },
	
	    /** Helpers */
	
	    autoSelectFirst: function() {
	      if (this.selection.get(this.selectionAttr) === undefined && this.autoselect) {
	        this.selectFirst();
	      }
	    },
	
	    updateSelection: function() {
	      if (this.selectable) {
	        var id = this.selection.get(this.selectionAttr);
	        if (id !== undefined) {
	          var selectedModel = this.model.getById(id);
	          if (!selectedModel) {
	            return;
	          }
	          for (var i=0; i < this.itemViews.length; i++) {
	            var itemView = this.itemViews[i];
	            if (itemView.model.id === selectedModel.id) {
	              itemView.$el.addClass('active');
	            } else {
	              itemView.$el.removeClass('active');
	            }
	          }
	        }
	      }
	    },
	
	    /** Modifiers */
	
	    select : function(id) {
	      this.selection.set(this.selectionAttr, id);
	    },
	
	    selectFirst: function() {
	      if (this.model && this.model.size()) {
	        this.selection.set(this.selectionAttr, this.model.at(0).id);
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(3), __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(93) ], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ModelView) {
	
	  /**
	   * ListView is a CollectionView that renders a selectable, navigable UL.
	   */
	  return Plumage.view.ListItemView = ModelView.extend({
	
	    tagName : 'li',
	
	    className : 'list-item-view',
	
	    events: {
	      'click': 'onClick'
	    },
	
	    /** Event Handlers */
	
	    onClick: function() {
	      this.trigger('select', this, this.model);
	    }
	
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(201),
	  __webpack_require__(156),
	  __webpack_require__(203)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModalDialog, MessageView, template) {
	
	  return Plumage.view.ConfirmationDialog = ModalDialog.extend({
	
	    template: template,
	
	    headerTemplate: 'Confirmation Dialog',
	
	    message: undefined,
	
	    messageCls: undefined,
	
	    bodyTemplate: 'Are you sure you want to do this?',
	
	    buttonText: 'Confirm',
	
	    buttonCls: 'btn-success',
	
	    events: {
	      'click .confirm': 'onConfirmClick'
	    },
	
	    subViews: [{
	      viewCls: MessageView,
	      name: 'message',
	      selector: '.message',
	      updateOnMessage: false,
	      replaceEl: true,
	    }],
	
	    initialize: function(options) {
	      options = options || {};
	      ModalDialog.prototype.initialize.apply(this, arguments);
	      this.bodyTemplate = this.initTemplate(this.bodyTemplate);
	    },
	
	    getTemplateData: function() {
	      var data = ModalDialog.prototype.getTemplateData.apply(this, arguments);
	      return _.extend(data, {
	        bodyTemplate: this.bodyTemplate(data),
	        buttonText: this.buttonText,
	        buttonCls: this.buttonCls,
	        message:  this.message,
	        messageCls: this.messageCls
	      });
	    },
	
	    setMessage: function(message, messageCls) {
	      this.getSubView('message').setMessage(message, messageCls);
	    },
	
	    onConfirmClick: function(e) {
	      $(e.target).attr('disabled', '');
	      this.trigger('confirm');
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(202),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModelView, template) {
	
	  return Plumage.view.ModalDialog = ModelView.extend({
	
	    template: template,
	
	    contentView: undefined,
	
	    headerTemplate: '',
	
	    showCancel: false,
	
	    showSubmit: false,
	
	    modalOptions: {
	      show:false
	    },
	
	    events: {
	      'click .submit': 'onSubmitClick'
	    },
	
	    initialize: function(options) {
	      options = options || {};
	      options.modalOptions = _.extend(this.modalOptions, options.modalOptions || {});
	      if (this.contentView) {
	        this.subViews = [this.contentView].concat(options.subViews || []);
	        this.contentView.selector = '.modal-content';
	        this.contentView.name = 'contentView';
	      }
	
	      ModelView.prototype.initialize.apply(this, arguments);
	
	      if (this.contentView) {
	        this.contentView = this.getSubView('contentView');
	      }
	    },
	
	    onRender: function() {
	      Handlebars.registerPartial('header', this.headerTemplate);
	      ModelView.prototype.onRender.apply(this, arguments);
	      if (this.$el.closest('html').length === 0) {
	        $('body').append(this.$el);
	        this.$('.modal').modal(this.modalOptions);
	      }
	    },
	
	    getTemplateData: function() {
	      var data = ModelView.prototype.getTemplateData.apply(this, arguments);
	      return _.extend(data,{
	        header: this.header,
	        showCancel: this.showCancel,
	        showSubmit: this.showSubmit,
	        canSubmit: this.canSubmit()
	      });
	    },
	
	    show: function() {
	      this.render();
	      this.$('.modal').modal('show');
	      ModelView.prototype.onShow.apply(this, arguments);
	    },
	
	    hide: function() {
	      this.$('.modal').modal('hide');
	      ModelView.prototype.onHide.apply(this, arguments);
	    },
	
	    canSubmit: function(model) {
	      return true;
	    },
	
	    onSubmitClick: function() {
	      this.trigger('submit', this);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 202 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal hide fade\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\">\n  <div class=\"modal-header\">\n    <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">x</button>\n    <h3 id=\"myModalLabel\">{{> header}}</h3>\n  </div>\n  <div class=\"modal-body\">\n    <div class=\"modal-content\"></div>\n  </div>\n  <div class=\"modal-footer\">\n    {{#if showCancel}}\n      <a class=\"cancel\" data-dismiss=\"modal\" aria-hidden=\"true\">Cancel</a>\n    {{else}}\n      <button class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">Close</button>\n    {{/if}}\n    {{#if showSubmit}}\n      <button class=\"btn submit\" {{#if canSubmit}}{{else}}disabled=\"true\"{{/if}}>Submit</button>\n    {{/if}}\n  </div>\n</div>"

/***/ },
/* 203 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal hide fade\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\">\n  <div class=\"modal-header\">\n    <div class=\"message\"></div>\n    <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">x</button>\n    <h3 id=\"myModalLabel\">{{> header}}</h3>\n\n  </div>\n  <div class=\"modal-body\">\n\n    <div class=\"modal-content\">\n\t    {{{bodyTemplate}}}\n    </div>\n  </div>\n  <div class=\"modal-footer\">\n  <button class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">Cancel</button>\n    <button class=\"btn confirm {{buttonCls}}\">{{buttonText}}</button>\n  </div>\n</div>"

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(205)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, ModelView, template) {
	
	  /**
	   * Displays a non-editable value with an optional label.
	   *
	   * Useful for detail views with lists of fields.
	   *
	   */
	  return Plumage.view.DisplayField = ModelView.extend({
	
	    className: 'display-field',
	
	    template: template,
	
	    /**
	     * optional. model attribute to display as label
	     */
	    labelAttr: undefined,
	
	    /**
	     * optional. String to use as label. Overrides labelAttr
	     */
	    label: undefined,
	
	    /**
	     * model attribute to display
	     */
	    valueAttr: undefined,
	
	    /**
	     * string to display. Overrides valueAttr.
	     */
	    value: undefined,
	
	    /**
	     * Used when value is null/undefined
	     */
	    defaultValue: '',
	
	    getTemplateData: function() {
	      var data = {
	        label: this.label ,
	        value: this.getValue(),
	      };
	      if (this.model) {
	        if (!data.label) {
	          if (this.labelAttr) {
	            data.label = this.model.get(this.labelAttr);
	          }
	        }
	        data.loading = !this.model.fetched;
	      }
	      return data;
	    },
	
	    getValue: function() {
	      var value = this.value;
	      if (this.model && !value) {
	        if (this.valueAttr) {
	          if (this.model.fetched) {
	            value = this.model.get(this.valueAttr);
	          }
	        }
	      }
	      if (value) {
	        return this.processValue(value);
	      } else {
	        return this.defaultValue;
	      }
	    },
	
	    processValue: function(value) {
	      return value;
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 205 */
/***/ function(module, exports) {

	module.exports = "{{#if label}}\n<div class=\"control-group\">\n  {{#label}}\n  <label class=\"control-label\">{{.}}</label>\n  {{/label}}\n  <div class=\"controls\">\n{{/if}}\n    <div class=\"field-value\">\n      {{#if loading}}\n        <span class=\"loading\">loading...</span>\n      {{else}}\n        {{value}}\n      {{/if}}\n    </div>\n{{#if label}}\n  </div>\n</div>\n{{/if}}"

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(94),
	  __webpack_require__(189),
	  __webpack_require__(183),
	  __webpack_require__(123),
	  __webpack_require__(207),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ContainerView, DropdownMenu, SearchField, SearchResults, template) {
	
	  return Plumage.view.NavView = ContainerView.extend(
	  /** @lends Plumage.view.NavView.prototype */
	  {
	
	    template: template,
	
	    /**
	     *
	     */
	    title: undefined,
	
	    titleUrl: '/',
	
	    subtitle: undefined,
	
	    showSearch: true,
	
	    navItems: [{
	      className: 'home-menu',
	      label: 'Home',
	      url: '/home'
	    }],
	
	    userMenuItems: [
	      {
	        label: 'logout',
	        value: 'logout'
	      }
	    ],
	
	    logoutUrl: '/logout',
	
	    aboutUrl: undefined,
	
	    aboutLabel: 'About',
	
	    helpUrl: undefined,
	
	    helpLabel: 'Help',
	
	    events: {
	      'click .nav-menu a': 'onNavClick',
	      'click a.brand': 'onLinkClick'
	    },
	
	    initialize: function () {
	      this.subViews = [];
	
	      if (this.userMenuItems) {
	        this.subViews.push(this.userMenu = new DropdownMenu({
	          selector: '.user-menu',
	          iconCls: 'icon-user',
	          label: window.currentUser,
	          menuItems: this.userMenuItems,
	          replaceEl: true
	        }));
	      }
	
	      if (this.showSearch) {
	        this.searchField = new SearchField({
	          selector: '.nav-search',
	          placeholder: 'Search'
	        });
	        this.subViews.push(this.searchField);
	      }
	
	      if (this.userMenu) {
	        this.userMenu.on('itemClick', this.onUserMenuClick.bind(this));
	      }
	
	      ContainerView.prototype.initialize.apply(this, arguments);
	
	      if (this.searchField) {
	        this.searchField.on('change', this.onSearchValueChange.bind(this));
	        this.searchField.on('blur', this.onSearchBlur.bind(this));
	        this.searchField.on('submit', this.onSearchSubmit.bind(this));
	      }
	    },
	
	    getUrl: function(navItem) {
	      return navItem.url;
	    },
	
	    onRender: function () {
	      var data = this.getTemplateData();
	      $(this.el).html(this.template(data));
	      this.$('.dropdown-toggle').dropdown();
	      if (this.currentNav) {
	        this.select(this.currentNav);
	      }
	    },
	
	    getTemplateData: function() {
	      var navItems = [];
	      for (var i=0;i<this.navItems.length;i++) {
	        var navItem =  _.clone(this.navItems[i]);
	        navItem.url = this.getUrl(navItem);
	        navItems.push(navItem);
	      }
	      return {
	        title: this.title,
	        titleUrl: this.titleUrl,
	        subtitle: this.subtitle,
	        navItems: navItems,
	        showAbout: this.aboutTemplate !== undefined,
	        showSearch: this.showSearch,
	        aboutUrl: this.aboutUrl,
	        aboutLabel: this.aboutLabel,
	        helpUrl: this.helpUrl,
	        helpLabel: this.helpLabel
	      };
	    },
	
	    processUrl: function(url) {
	      return url;
	    },
	
	    /**
	     * Helpers
	     */
	
	    select: function(menuItem) {
	      this.currentNav = menuItem;
	      this.$('.nav li').removeClass('active');
	      this.$('.' + menuItem).addClass('active');
	    },
	
	    expandSearchField: function() {
	      var el = this.$('.right-nav');
	      if (!el.hasClass('expand-search')) {
	        el.addClass('expand-search');
	        this.searchField.$el.attr('placeholder', '');
	      }
	
	    },
	
	    contractSearchField: function() {
	      var el = this.$('.right-nav');
	      if (el.hasClass('expand-search')) {
	        el.removeClass('expand-search');
	        this.searchField.$el.attr('placeholder', this.searchField.noSelectionText);
	      }
	    },
	
	    createSearchModel: function(query) {
	      return new SearchResults({query: query, model: 'all'});
	    },
	
	    /**
	     * Event Handlers
	     */
	
	    onNavClick: function(e) {
	      var a = e.target;
	      e.preventDefault();
	    },
	
	    onUserMenuClick: function(menu, value) {
	      if (value === 'logout') {
	        //window.location = this.logoutUrl;
	      }
	    },
	
	    onSearchValueChange: function(field, value) {
	      this.expandSearchField();
	    },
	
	    onSearchBlur: function() {
	      this.contractSearchField();
	    },
	
	    onSearchSubmit: function(field, value) {
	      var searchModel = this.createSearchModel(value);
	      searchModel.navigate();
	      this.contractSearchField();
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 207 */
/***/ function(module, exports) {

	module.exports = "\n<div id=\"nav-top\">\n  <a class=\"brand\" href=\"{{titleUrl}}\">\n    <span class=\"nav-title\">{{title}}</span>\n    {{#subtitle}}<span class=\"nav-subtitle\">{{.}}</span>{{/subtitle}}\n  </a>\n  <div id=\"extra-links\">\n  {{#if aboutUrl}}\n    <a class=\"outlink\" href=\"{{aboutUrl}}\" target=\"_\">{{aboutLabel}}</a>\n  {{/if}}\n\n  {{#if helpUrl}}\n    <a class=\"outlink\" href=\"{{helpUrl}}\" target=\"_\">{{helpLabel}}</a>\n  {{/if}}\n  </div>\n\n  <div id=\"nav-top-right\" class=\"nav pull-right\">\n    <div class=\"nav-search\"></div>\n  </div>\n  <div class=\"clear\"></div>\n</div>\n\n{{#if navItems}}\n<div id=\"main-nav\" class=\"navbar\">\n  <div class=\"navbar-inner\">\n    <ul class=\"nav-menu nav menu\">\n      {{#navItems}}\n      <li class=\"{{className}}\"><a href=\"{{url}}\">{{label}}</a></li>\n      {{/navItems}}\n    </ul>\n\n    <ul class=\"nav right-nav pull-right\">\n      <li class=\"user-menu\"></li>\n    </ul>\n  </div>\n</div>\n{{/if}}"

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(88),
	  __webpack_require__(93),
	  __webpack_require__(91),
	  __webpack_require__(209)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, ModelView, View, template) {
	
	  return Plumage.view.Popover = ModelView.extend({
	
	    template: template,
	
	    className: 'popover fade',
	
	    title: undefined,
	
	    content: undefined,
	
	    targetEl: undefined,
	
	    /**
	     * overrides automatic positioning. Values relative to targetEl's offset
	     * eg [x, y]
	     */
	    position: undefined,
	
	    placement: 'right',
	
	    dynamicPlacement: true,
	
	    events: {
	      'mouseover': 'onMouseOver',
	      'mouseout': 'onMouseOut',
	      'click a': 'onLinkClick'
	    },
	
	    initialize: function(options) {
	
	
	      ModelView.prototype.initialize.apply(this, arguments);
	
	      if (this.title) {
	        this.subViews = [
	          new ModelView({selector: '.popover-title', template: this.title, replaceEl: true})
	        ].concat(this.subViews || []);
	      }
	
	      if (this.content) {
	        this.setContent(this.content);
	      }
	      if (this.targetEl) {
	        var  targetEl = this.targetEl;
	        delete this.targetEl;
	        this.setTargetEl(targetEl);
	      }
	    },
	
	    getTemplateData: function() {
	      var data = ModelView.prototype.getTemplateData.apply(this, arguments);
	      data.hasTitle = this.title !== undefined;
	      return data;
	    },
	
	    setTargetEl: function(targetEl) {
	      if (this.targetEl) {
	        this.targetEl.removeClass('popovered');
	      }
	      this.targetEl = $(targetEl);
	      if (this.$el.is(':visible')) {
	        this.targetEl.addClass('popovered');
	      }
	    },
	
	    setContent: function(content) {
	      if (this.content && this.content.off) {
	        this.content.off('afterRender', this.onAfterContentRender);
	        this.subViews = _.select(this.subViews, function(view){
	          return view.selector !== '.popover-content';
	        });
	      }
	
	      if (typeof content === 'string') {
	        content = new View({template: content});
	      } else {
	        content = new Plumage.ViewBuilder().buildView(content);
	      }
	      content.selector = '.popover-content';
	      content.on('afterRender', this.onAfterContentRender.bind(this));
	      this.content = content;
	
	      this.subViews.push(this.content);
	    },
	
	    onRender: function() {
	      ModelView.prototype.onRender.apply(this, arguments);
	
	      if (this.$el.closest('html').length === 0) {
	        $('body').append(this.$el);
	      }
	    },
	
	    render: function() {
	      ModelView.prototype.render.apply(this, arguments);
	      this.updatePosition();
	    },
	
	    show: function() {
	      this.cancelHide();
	      this.render();
	      if (!this.$el.hasClass('in')) {
	        this.targetEl.addClass('popovered');
	        this.$el.show();
	        this.$el.addClass('in');
	        this.onShow();
	      }
	    },
	
	    cancelHide: function() {
	      clearTimeout(this.hideTimeout);
	      clearTimeout(this.fadeTimeout);
	    },
	
	    hide: function() {
	      var el = this.$el, me = this;
	      if (el.hasClass('in')) {
	        this.cancelHide();
	        this.fadeTimeout = setTimeout(function() {
	          me.targetEl.removeClass('popovered');
	          el.removeClass('in');
	          me.onHide();
	          me.hideTimeout = setTimeout(function() {
	            el.hide();
	
	          },200);
	          me.trigger('hide', me);
	        }, 300);
	      }
	    },
	
	    hideIfOut: function(el, newEl) {
	      el = $(el);
	      newEl = $(newEl);
	
	      if ($.contains(el, newEl) ||  // if newEl is a child element, it's not really out
	        newEl.closest('.popover').is(this.$el)  //  don't hide if mouse moved to popover
	      ) {
	        return;
	      }
	      if (!newEl.is(this.targetEl)) {
	        this.hide();
	      }
	    },
	
	    /**
	     * Event Handlers
	     */
	    update: function () {
	      //do nothing
	    },
	
	    onMouseOver: function() {
	      this.cancelHide();
	    },
	
	    onMouseOut: function(e) {
	      var newEl = $(e.toElement || e.relatedTarget);
	      if ($(this.targetEl).has(newEl).length > 0 || newEl.closest('.popover').is(this.$el)) {
	        return;
	      }
	
	      $(this.targetEl).removeClass('active');
	      this.hide();
	    },
	
	    onAfterContentRender: function() {
	      this.updatePosition();
	    },
	
	    /**
	     * Helpers
	     */
	
	    updatePosition: function () {
	      var targetEl = this.targetEl;
	      var placement = this.placement;
	
	      var screenHeight = $(window).height();
	      var screenWidth = $(window).width();
	
	      var position = this.getPosition(targetEl, placement);
	
	      //switch sides if not enough room
	      if (this.dynamicPlacement &&
	          ((placement === 'left' || placement === 'right') &&
	          (position.left < 0 || position.left + this.$el.width() > screenWidth) ||
	          (placement === 'top' || placement === 'bottom') &&
	          (position.top < 0 || position.top + this.$el.height() > screenHeight))
	      ) {
	        placement = this.getOppositePlacement(placement);
	        position = this.getPosition(targetEl, placement);
	      }
	
	      this.$el.removeClass('top right bottom left');
	      this.$el.addClass(placement);
	
	      this.$el.css({top: position.top, left: position.left});
	      if (position.arrowLeft  !== undefined) {
	        this.$('.arrow').css({left: position.arrowLeft});
	      }
	      if (position.arrowTop  !== undefined) {
	        this.$('.arrow').css({top: position.arrowTop});
	      }
	    },
	
	    getPosition: function(targetEl, placement) {
	      var el = $(targetEl), elOffset = el.offset(), left, top, arrowTop, arrowLeft;
	
	      var bbox = el[0].getBoundingClientRect(),
	        targetWidth = bbox.width,
	        targetHeight = bbox.height,
	        screenWidth = $(window).width(),
	        screenHeight = $(window).height(),
	        width = this.$el.width(),
	        height = this.$el.height();
	
	
	      if (placement === 'top' || placement === 'bottom') {
	        if (placement === 'top') {
	          top = elOffset.top - this.$el.height();
	        } else {
	          top = elOffset.top + targetHeight;
	        }
	        left = elOffset.left + targetWidth/2 - width/2;
	        if (left > screenWidth - width || left < 0) {
	          var newLeft = Math.max(Math.min(left, screenWidth - width), 0);
	          arrowTop = left - newLeft + width/2;
	          left = newLeft;
	        }
	      } else if (placement === 'left' || placement === 'right') {
	
	        if (placement === 'left') {
	          left = elOffset.left - width;
	        } else {
	          left = elOffset.left + targetWidth;
	        }
	        top = elOffset.top + targetHeight/2 - height/2;
	        if (top > screenHeight - height || top < 0) {
	          var newTop = Math.max(Math.min(top, screenHeight - height), 0);
	          arrowTop = top - newTop + height/2;
	          top = newTop;
	        }
	      } else {
	        throw 'Invalid placement';
	      }
	
	      var position = this.position;
	      if (position) {
	        if (placement === 'top' || placement === 'bottom') {
	          left += position[0] - targetWidth/2;
	          top += position[1];
	        } else {
	          left += position[0];
	          top += position[1] - targetHeight/2;
	        }
	      }
	
	      return {top: top, left: left, arrowTop: arrowTop, arrowLeft: arrowLeft};
	    },
	
	    getOppositePlacement: function(placement) {
	      switch(placement)
	      {
	      case 'left':
	        return 'right';
	      case 'right':
	        return 'left';
	      case 'top':
	        return 'bottom';
	      case 'bottom':
	        return 'top';
	      }
	      throw 'Invalid placement';
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 209 */
/***/ function(module, exports) {

	module.exports = "<div class=\"arrow\"></div>\n{{#hasTitle}}\n<h3 class=\"popover-title\"></h3>\n{{/hasTitle}}\n<div class=\"popover-content\"></div>\n"

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(88),
	  __webpack_require__(91),
	  __webpack_require__(93),
	  __webpack_require__(211),
	  __webpack_require__(212)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Handlebars, Plumage, View, ModelView, template) {
	
	  return Plumage.view.TabView = ModelView.extend({
	    /** @lends Plumage.view.ModelView.prototype */
	
	    className: 'tab-view tab-theme',
	
	    template: Handlebars.compile(template),
	
	    viewStateAttr: 'tab',
	
	    cookieName: undefined,
	
	    events: {
	      'click .tabs a': 'onTabClick'
	    },
	
	    triggerOnTabChange: false,
	
	    /**
	     * If set, call [router.logNavigationAction]{@link Plumage.Router#logNavigationAction}nAction on tab change.
	     */
	    logTabNavigation: false,
	
	    /**
	     * Tabbed view with subviews as tab panes.
	     *
	     * Tabs are generated from subViews with the tabId and tabLabel attributes.
	     *
	     * @extends Plumage.view.ModelView
	     * @constructs
	     */
	    initialize: function() {
	      ModelView.prototype.initialize.apply(this, arguments);
	      this.eachTabSubView(function(subView) {
	        subView.selector = '#' + subView.tabId + '-tab';
	      }, this);
	    },
	
	    onRender: function() {
	      var data = this.getTemplateData();
	      $(this.el).html(this.template(data));
	      this.updateActiveTab();
	    },
	
	    setModel: function() {
	      ModelView.prototype.setModel.apply(this, arguments);
	      var tab = this.model.get(this.viewStateAttr);
	      if (!tab) {
	        tab = this.getTabCookie();
	        if (tab === undefined) {
	          tab = _.find(this.subViews, function(subView){ return subView.tabId !== undefined;}).tabId;
	        }
	        this.model.set(this.viewStateAttr, tab);
	      }
	    },
	
	    getActiveTab: function() {
	      if (this.model) {
	        return this.model.get(this.viewStateAttr);
	      }
	    },
	
	    setActiveTab: function(tabId) {
	      if (this.model && tabId !== this.getActiveTab()) {
	        if (this.triggerOnTabChange) {
	          var extras = {};
	          extras[this.viewStateAttr] = tabId;
	          if (window.router) {
	            window.router.navigateWithQueryParams(this.model.viewUrlWithParams(extras), {trigger: true});
	          }
	        } else {
	          this.model.set(this.viewStateAttr, tabId);
	          this.model.updateUrl();
	        }
	        this.updateTabCookie();
	        if (this.logTabNavigation) {
	          if (window.router) {
	            window.router.logNavigationAction(window.location.href, window.location.pathname);
	          }
	        }
	      }
	    },
	
	    getTemplateData: function() {
	      var tabs = [];
	      this.eachTabSubView(function(subView) {
	        var tab = {
	          id: subView.tabId,
	          active: subView.tabId === this.getActiveTab(),
	          label: subView.tabLabel
	        };
	        tabs.push(tab);
	      }, this);
	      return {tabs: tabs};
	    },
	
	    updateActiveTab: function() {
	      var activeTab = this.getActiveTab();
	      if (activeTab === undefined) {
	        activeTab = this.subViews[0].tabId;
	      }
	      var cssId = activeTab +'-tab';
	      var tab = this.$('a[data-tab=#'+ cssId + ']');
	
	      this.$('.tabs li').removeClass('active');
	      tab.parent('li').addClass('active');
	
	      if (tab) {
	        this.eachTabSubView(function(subView) {
	          if (subView.tabId === this.getActiveTab()) {
	            this.$el.addClass(subView.tabId + '-tab-selected');
	            this.$('#'+subView.tabId+'-tab').addClass('active');
	            if (this.shown) {
	              subView.onShow();
	            }
	          } else {
	            this.$el.removeClass(subView.tabId + '-tab-selected');
	            this.$('#'+subView.tabId+'-tab').removeClass('active');
	            if (this.shown) {
	              subView.onHide();
	            }
	          }
	        }, this);
	      }
	    },
	
	    getTabCookie: function() {
	      if (this.cookieName) {
	        return $.cookie('tabview.' + this.cookieName);
	      }
	    },
	
	    updateTabCookie: function() {
	      if (this.cookieName) {
	        $.cookie('tabview.' + this.cookieName, this.getActiveTab(), { expires: 7 });
	      }
	    },
	
	    onTabClick: function(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var tab = $(e.target);
	      var tabId = this.cleanTabId(tab.data('tab'));
	      e.preventDefault();
	      this.setActiveTab(tabId);
	    },
	
	    eachTabSubView: function(callback, scope) {
	      _.each(this.subViews, function(subView) {
	        if (subView.tabId) {
	          if (scope) {
	            return callback.call(this, subView);
	          } else {
	            callback(subView);
	          }
	        }
	      }, this);
	    },
	
	    /**
	     * Override subview behavior. Don't call ModelView's versions
	     */
	    onModelLoad: function() {
	      var tab = this.model.get(this.viewStateAttr);
	      if (tab) {
	        this.updateActiveTab();
	      } else {
	        tab = this.getTabCookie();
	        if (tab === undefined) {
	          tab = _.find(this.subViews, function(subView){ return subView.tabId !== undefined;}).tabId;
	        }
	        this.setActiveTab(tab);
	      }
	    },
	
	    onModelChange: function() {
	      this.updateActiveTab();
	    },
	
	    onShow: function() {
	      View.prototype.onShow.apply(this, arguments);
	      this.updateActiveTab();
	
	      this.eachSubView(function(subView) {
	        if (subView.tabId === this.getActiveTab() || subView.tabId === undefined) {
	          subView.onShow();
	        }
	      }, this);
	    },
	
	    onHide: function() {
	      View.prototype.onHide.apply(this, arguments);
	      this.eachSubView(function(subView) {
	        if (subView.tabId === this.getActiveTab() || subView.tabId === undefined) {
	          subView.onHide();
	        }
	      }, this);
	    },
	
	    /**
	     * Helpers
	     */
	
	    cleanTabId: function(tabId) {
	      return tabId.replace(/^#/, '').replace(/-tab$/, '');
	    }
	
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tabs\">\n  <ul>\n    {{#tabs}}\n    <li class=\"{{id}} {{#active}}active{{/active}}\"><a data-tab=\"#{{id}}-tab\">{{label}}</a></li>\n    {{/tabs}}\n  </ul>\n</div>\n\n<div class=\"tab-content\">\n  {{#tabs}}\n  <div class=\"tab-pane {{#active}}active{{/active}}\" id=\"{{id}}-tab\"></div>\n  {{/tabs}}\n</div>"

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery Cookie Plugin v1.4.1
	 * https://github.com/carhartl/jquery-cookie
	 *
	 * Copyright 2013 Klaus Hartl
	 * Released under the MIT license
	 */
	(function (factory) {
		if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			// CommonJS
			factory(require('jquery'));
		} else {
			// Browser globals
			factory(jQuery);
		}
	}(function ($) {
	
		var pluses = /\+/g;
	
		function encode(s) {
			return config.raw ? s : encodeURIComponent(s);
		}
	
		function decode(s) {
			return config.raw ? s : decodeURIComponent(s);
		}
	
		function stringifyCookieValue(value) {
			return encode(config.json ? JSON.stringify(value) : String(value));
		}
	
		function parseCookieValue(s) {
			if (s.indexOf('"') === 0) {
				// This is a quoted cookie as according to RFC2068, unescape...
				s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
			}
	
			try {
				// Replace server-side written pluses with spaces.
				// If we can't decode the cookie, ignore it, it's unusable.
				// If we can't parse the cookie, ignore it, it's unusable.
				s = decodeURIComponent(s.replace(pluses, ' '));
				return config.json ? JSON.parse(s) : s;
			} catch(e) {}
		}
	
		function read(s, converter) {
			var value = config.raw ? s : parseCookieValue(s);
			return $.isFunction(converter) ? converter(value) : value;
		}
	
		var config = $.cookie = function (key, value, options) {
	
			// Write
	
			if (value !== undefined && !$.isFunction(value)) {
				options = $.extend({}, config.defaults, options);
	
				if (typeof options.expires === 'number') {
					var days = options.expires, t = options.expires = new Date();
					t.setTime(+t + days * 864e+5);
				}
	
				return (document.cookie = [
					encode(key), '=', stringifyCookieValue(value),
					options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
					options.path    ? '; path=' + options.path : '',
					options.domain  ? '; domain=' + options.domain : '',
					options.secure  ? '; secure' : ''
				].join(''));
			}
	
			// Read
	
			var result = key ? undefined : {};
	
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling $.cookie().
			var cookies = document.cookie ? document.cookie.split('; ') : [];
	
			for (var i = 0, l = cookies.length; i < l; i++) {
				var parts = cookies[i].split('=');
				var name = decode(parts.shift());
				var cookie = parts.join('=');
	
				if (key && key === name) {
					// If second argument (value) is a function it's a converter...
					result = read(cookie, value);
					break;
				}
	
				// Prevent storing a cookie that we couldn't decode.
				if (!key && (cookie = read(cookie)) !== undefined) {
					result[name] = cookie;
				}
			}
	
			return result;
		};
	
		config.defaults = {};
	
		$.removeCookie = function (key, options) {
			if ($.cookie(key) === undefined) {
				return false;
			}
	
			// Must not alter options, thus extending a fresh object...
			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
			return !$.cookie(key);
		};
	
	}));


/***/ },
/* 213 */,
/* 214 */,
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(4),
	  __webpack_require__(216)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage, City) {
	
	  return Plumage.model.Model.extend({
	    idAttribute: 'name',
	
	    urlIdAttribute: 'name',
	
	    urlRoot: '/',
	
	    queryAttrs: ['name', 'region'],
	
	    relationships: {
	      'capital': {
	        modelCls: City,
	        reverse: 'parent'
	      },
	      'language': {
	        modelCls: Plumage.collection.DataCollection
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(1),
	  __webpack_require__(3),
	  __webpack_require__(2),
	  __webpack_require__(4),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function($, _, Backbone, Plumage) {
	
	  return Plumage.model.Model.extend({
	    urlRoot: '/cities',
	    urlIdAttribute: 'name'
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(4),
	  __webpack_require__(215)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Plumage, Country) {
	
	  return Plumage.collection.Collection.extend({
	    model: Country
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */
/***/ function(module, exports) {

	module.exports = [
		{
			"name": "Afghanistan",
			"nativeName": "Afnistn",
			"tld": [
				".af"
			],
			"cca2": "AF",
			"ccn3": "004",
			"cca3": "AFG",
			"currency": [
				"AFN"
			],
			"callingCode": [
				"93"
			],
			"capital": {
				"city": "kabul",
				"accentcity": "Kabul",
				"population": "3043589",
				"latitude": "34.516667",
				"longitude": "69.183333"
			},
			"altSpellings": [
				"AF",
				"Afnistn"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Pashto"
				},
				{
					"name": "Dari"
				}
			],
			"population": 25500100,
			"demonym": "Afghan",
			"borders": [
				"IRN",
				"PAK",
				"TKM",
				"UZB",
				"TJK",
				"CHN"
			]
		},
		{
			"name": "Albania",
			"nativeName": "Shqipria",
			"tld": [
				".al"
			],
			"cca2": "AL",
			"ccn3": "008",
			"cca3": "ALB",
			"currency": [
				"ALL"
			],
			"callingCode": [
				"355"
			],
			"capital": {
				"city": "tirana",
				"accentcity": "Tirana",
				"population": "374801",
				"latitude": "41.3275",
				"longitude": "19.8188889"
			},
			"altSpellings": [
				"AL",
				"Shqipri",
				"Shqipria",
				"Shqipnia"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Albanian"
				}
			],
			"population": 2821977,
			"demonym": "Albanian",
			"borders": [
				"MNE",
				"GRC",
				"MKD",
				"KOS"
			]
		},
		{
			"name": "Algeria",
			"nativeName": "al-Jazir",
			"tld": [
				".dz"
			],
			"cca2": "DZ",
			"ccn3": "012",
			"cca3": "DZA",
			"currency": [
				"DZD"
			],
			"callingCode": [
				"213"
			],
			"capital": {
				"city": "algiers",
				"accentcity": "Algiers",
				"population": "1980242",
				"latitude": "36.7630556",
				"longitude": "3.0505556"
			},
			"altSpellings": [
				"DZ",
				"Dzayer",
				"Algrie"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 37900000,
			"demonym": "Algerian",
			"borders": [
				"TUN",
				"LDY",
				"NER",
				"ESH",
				"MRT",
				"MLI",
				"MAR"
			]
		},
		{
			"name": "Andorra",
			"nativeName": "Andorra",
			"tld": [
				".ad"
			],
			"cca2": "AD",
			"ccn3": "020",
			"cca3": "AND",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"376"
			],
			"capital": {
				"city": "andorra la vella",
				"accentcity": "Andorra la Vella",
				"population": "20430",
				"latitude": "42.5",
				"longitude": "1.5166667"
			},
			"altSpellings": [
				"AD",
				"Principality of Andorra",
				"Principat d'Andorra"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Catalan"
				}
			],
			"population": 76246,
			"demonym": "Andorran",
			"borders": [
				"FRA",
				"ESP"
			]
		},
		{
			"name": "Angola",
			"nativeName": "Angola",
			"tld": [
				".ao"
			],
			"cca2": "AO",
			"ccn3": "024",
			"cca3": "AGO",
			"currency": [
				"AOA"
			],
			"callingCode": [
				"244"
			],
			"capital": {
				"city": "luanda",
				"accentcity": "Luanda",
				"population": null,
				"latitude": "-7.05",
				"longitude": "14.8166667"
			},
			"altSpellings": [
				"AO",
				"Repblica de Angola",
				"publika de an'la"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "Portuguese"
				}
			],
			"population": 20609294,
			"demonym": "Angolan",
			"borders": [
				"COG",
				"COD",
				"ZMB",
				"NAM"
			]
		},
		{
			"name": "Anguilla",
			"nativeName": "Anguilla",
			"tld": [
				".ai"
			],
			"cca2": "AI",
			"ccn3": "660",
			"cca3": "AIA",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1264"
			],
			"capital": {
				"city": "the valley",
				"accentcity": "The Valley",
				"population": "1379",
				"latitude": "18.2166667",
				"longitude": "-63.05"
			},
			"altSpellings": [
				"AI"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 13452,
			"demonym": "Anguillian",
			"borders": []
		},
		{
			"name": "Antigua and Barbuda",
			"nativeName": "Antigua and Barbuda",
			"tld": [
				".ag"
			],
			"cca2": "AG",
			"ccn3": "028",
			"cca3": "ATG",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1268"
			],
			"capital": {
				"city": "saint john's",
				"accentcity": "Saint John's",
				"population": null,
				"latitude": "17.1166667",
				"longitude": "-61.85"
			},
			"altSpellings": [
				"AG"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 86295,
			"demonym": "Antiguan, Barbudan",
			"borders": []
		},
		{
			"name": "Argentina",
			"nativeName": "Argentina",
			"tld": [
				".ar"
			],
			"cca2": "AR",
			"ccn3": "032",
			"cca3": "ARG",
			"currency": [
				"ARS"
			],
			"callingCode": [
				"54"
			],
			"capital": {
				"city": "buenos aires",
				"accentcity": "Buenos Aires",
				"population": null,
				"latitude": "-34.5875",
				"longitude": "-58.6725"
			},
			"altSpellings": [
				"AR",
				"Argentine Republic",
				"Repblica Argentina"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 40117096,
			"demonym": "Argentinean",
			"borders": [
				"BOL",
				"BRA",
				"CHL",
				"PRY",
				"URY"
			]
		},
		{
			"name": "Armenia",
			"nativeName": "",
			"tld": [
				".am"
			],
			"cca2": "AM",
			"ccn3": "051",
			"cca3": "ARM",
			"currency": [
				"AMD"
			],
			"callingCode": [
				"374"
			],
			"capital": {
				"city": "yerevan",
				"accentcity": "Yerevan",
				"population": "1093499",
				"latitude": "40.1811111",
				"longitude": "44.5136111"
			},
			"altSpellings": [
				"AM",
				"Hayastan",
				"Republic of Armenia",
				" "
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Armenian"
				}
			],
			"population": 3024100,
			"demonym": "Armenian",
			"borders": [
				"AZE",
				"GEO",
				"IRN",
				"TUR"
			]
		},
		{
			"name": "Aruba",
			"nativeName": "Aruba",
			"tld": [
				".aw"
			],
			"cca2": "AW",
			"ccn3": "533",
			"cca3": "ABW",
			"currency": [
				"AWG"
			],
			"callingCode": [
				"297"
			],
			"capital": {
				"city": "oranjestad",
				"accentcity": "Oranjestad",
				"population": "29998",
				"latitude": "12.5166667",
				"longitude": "-70.0333333"
			},
			"altSpellings": [
				"AW"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "Dutch"
				},
				{
					"name": "Papiamento"
				}
			],
			"population": 101484,
			"demonym": "Aruban",
			"borders": []
		},
		{
			"name": "Australia",
			"nativeName": "Australia",
			"tld": [
				".au"
			],
			"cca2": "AU",
			"ccn3": "036",
			"cca3": "AUS",
			"currency": [
				"AUD"
			],
			"callingCode": [
				"61"
			],
			"capital": {
				"city": "canberra",
				"accentcity": "Canberra",
				"population": "324025",
				"latitude": "-35.283333",
				"longitude": "149.216667"
			},
			"altSpellings": [
				"AU"
			],
			"region": "Oceania",
			"subregion": [
				"Australia",
				"New Zealand"
			],
			"language": [
				{
					"name": "English"
				}
			],
			"population": 23254142,
			"demonym": "Australian",
			"borders": []
		},
		{
			"name": "Austria",
			"nativeName": "sterreich",
			"tld": [
				".at"
			],
			"cca2": "AT",
			"ccn3": "040",
			"cca3": "AUT",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"43"
			],
			"capital": {
				"city": "vienna",
				"accentcity": "Vienna",
				"population": "1569315",
				"latitude": "48.2",
				"longitude": "16.3666667"
			},
			"altSpellings": [
				"AT",
				"sterreich",
				"Osterreich",
				"Oesterreich"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "German"
				}
			],
			"population": 8501502,
			"demonym": "Austrian",
			"borders": [
				"CZE",
				"DEU",
				"HUN",
				"ITA",
				"LIE",
				"SVK",
				"SVN",
				"CHE"
			]
		},
		{
			"name": "Azerbaijan",
			"nativeName": "Azrbaycan",
			"tld": [
				".az"
			],
			"cca2": "AZ",
			"ccn3": "031",
			"cca3": "AZE",
			"currency": [
				"AZN"
			],
			"callingCode": [
				"994"
			],
			"capital": {
				"city": "baku",
				"accentcity": "Baku",
				"population": "1116513",
				"latitude": "40.3952778",
				"longitude": "49.8822222"
			},
			"altSpellings": [
				"AZ",
				"Republic of Azerbaijan",
				"Azrbaycan Respublikas"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Azerbaijani"
				}
			],
			"population": 9235100,
			"demonym": "Azerbaijani",
			"borders": [
				"ARM",
				"GEO",
				"IRN",
				"RUS",
				"TUR"
			]
		},
		{
			"name": "Bahamas",
			"nativeName": "Bahamas",
			"tld": [
				".bs"
			],
			"cca2": "BS",
			"ccn3": "044",
			"cca3": "BHS",
			"currency": [
				"BSD"
			],
			"callingCode": [
				"1242"
			],
			"capital": {
				"city": "nassau",
				"accentcity": "Nassau",
				"population": "227936",
				"latitude": "25.0833333",
				"longitude": "-77.35"
			},
			"altSpellings": [
				"BS",
				"Commonwealth of the Bahamas"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": -1,
			"demonym": "Bahamian",
			"borders": []
		},
		{
			"name": "Bahrain",
			"nativeName": "al-Barayn",
			"tld": [
				".bh"
			],
			"cca2": "BH",
			"ccn3": "048",
			"cca3": "BHR",
			"currency": [
				"BHD"
			],
			"callingCode": [
				"973"
			],
			"capital": {
				"city": "manama",
				"accentcity": "Manama",
				"population": "147097",
				"latitude": "26.2361111",
				"longitude": "50.5830556"
			},
			"altSpellings": [
				"BH",
				"Kingdom of Bahrain",
				"Mamlakat al-Barayn"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 1234571,
			"demonym": "Bahraini",
			"borders": []
		},
		{
			"name": "Bangladesh",
			"nativeName": "Bangladesh",
			"tld": [
				".bd"
			],
			"cca2": "BD",
			"ccn3": "050",
			"cca3": "BGD",
			"currency": [
				"BDT"
			],
			"callingCode": [
				"880"
			],
			"capital": {
				"city": "dhaka",
				"accentcity": "Dhaka",
				"population": "6493177",
				"latitude": "23.7230556",
				"longitude": "90.4086111"
			},
			"altSpellings": [
				"BD",
				"People's Republic of Bangladesh",
				"Gnprjatntri Bangladesh"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Bangla"
				}
			],
			"population": 152518015,
			"demonym": "Bangladeshi",
			"borders": [
				"MMR",
				"IND"
			]
		},
		{
			"name": "Barbados",
			"nativeName": "Barbados",
			"tld": [
				".bb"
			],
			"cca2": "BB",
			"ccn3": "052",
			"cca3": "BRB",
			"currency": [
				"BBD"
			],
			"callingCode": [
				"1246"
			],
			"capital": {
				"city": "bridgetown",
				"accentcity": "Bridgetown",
				"population": "98511",
				"latitude": "13.1",
				"longitude": "-59.6166667"
			},
			"altSpellings": [
				"BB"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 274200,
			"demonym": "Barbadian",
			"borders": []
		},
		{
			"name": "Belarus",
			"nativeName": "",
			"tld": [
				".by"
			],
			"cca2": "BY",
			"ccn3": "112",
			"cca3": "BLR",
			"currency": [
				"BYR"
			],
			"callingCode": [
				"375"
			],
			"capital": {
				"city": "minsk",
				"accentcity": "Minsk",
				"population": "1742123",
				"latitude": "53.9",
				"longitude": "27.5666667"
			},
			"altSpellings": [
				"BY",
				"Bielaru",
				"Republic of Belarus",
				"",
				" ",
				"Belorussiya",
				"Respublika Belarus"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Belarusian"
				},
				{
					"name": "Russian"
				}
			],
			"population": 9465500,
			"demonym": "Belarusian",
			"borders": [
				"LVA",
				"LTU",
				"POL",
				"RUS",
				"UKR"
			]
		},
		{
			"name": "Belgium",
			"nativeName": "Belgi",
			"tld": [
				".be"
			],
			"cca2": "BE",
			"ccn3": "056",
			"cca3": "BEL",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"32"
			],
			"capital": {
				"city": "brussels",
				"accentcity": "Brussels",
				"population": "1019022",
				"latitude": "50.833333",
				"longitude": "4.333333"
			},
			"altSpellings": [
				"BE",
				"Belgi",
				"Belgie",
				"Belgien",
				"Belgique",
				"Kingdom of Belgium",
				"Koninkrijk Belgi",
				"Royaume de Belgique",
				"Knigreich Belgien"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "Dutch"
				},
				{
					"name": "French"
				},
				{
					"name": "German"
				}
			],
			"population": 11175653,
			"demonym": "Belgian",
			"borders": [
				"FRA",
				"DEU",
				"LUX",
				"NLD"
			]
		},
		{
			"name": "Belize",
			"nativeName": "Belize",
			"tld": [
				".bz"
			],
			"cca2": "BZ",
			"ccn3": "084",
			"cca3": "BLZ",
			"currency": [
				"BZD"
			],
			"callingCode": [
				"501"
			],
			"capital": {
				"city": "belmopan",
				"accentcity": "Belmopan",
				"population": "13381",
				"latitude": "17.25",
				"longitude": "-88.7666667"
			},
			"altSpellings": [
				"BZ"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 312971,
			"demonym": "Belizean",
			"borders": [
				"GTM",
				"MEX"
			]
		},
		{
			"name": "Benin",
			"nativeName": "Bnin",
			"tld": [
				".bj"
			],
			"cca2": "BJ",
			"ccn3": "204",
			"cca3": "BEN",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"229"
			],
			"capital": {
				"city": "porto-novo",
				"accentcity": "Porto-Novo",
				"population": null,
				"latitude": "6.4833333",
				"longitude": "2.6166667"
			},
			"altSpellings": [
				"BJ",
				"Republic of Benin",
				"Rpublique du Bnin"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 10323000,
			"demonym": "Beninese",
			"borders": [
				"BFA",
				"NER",
				"NGA",
				"TGO"
			]
		},
		{
			"name": "Bermuda",
			"nativeName": "Bermuda",
			"tld": [
				".bm"
			],
			"cca2": "BM",
			"ccn3": "060",
			"cca3": "BMU",
			"currency": [
				"BMD"
			],
			"callingCode": [
				"1441"
			],
			"capital": {
				"city": "hamilton",
				"accentcity": "Hamilton",
				"population": "902",
				"latitude": "32.2941667",
				"longitude": "-64.7838889"
			},
			"altSpellings": [
				"BM",
				"The Islands of Bermuda",
				"The Bermudas",
				"Somers Isles"
			],
			"region": "Americas",
			"subregion": "Northern America",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 64237,
			"demonym": "Bermudian",
			"borders": []
		},
		{
			"name": "Bhutan",
			"nativeName": "brug-yul",
			"tld": [
				".bt"
			],
			"cca2": "BT",
			"ccn3": "064",
			"cca3": "BTN",
			"currency": [
				"BTN",
				"INR"
			],
			"callingCode": [
				"975"
			],
			"capital": {
				"city": "thimphu",
				"accentcity": "Thimphu",
				"population": null,
				"latitude": "27.4833333",
				"longitude": "89.6"
			},
			"altSpellings": [
				"BT",
				"Kingdom of Bhutan"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Dzongkha"
				}
			],
			"population": 740990,
			"demonym": "Bhutanese",
			"borders": [
				"CHN",
				"IND"
			]
		},
		{
			"name": "Bolivia",
			"nativeName": "Bolivia",
			"tld": [
				".bo"
			],
			"cca2": "BO",
			"ccn3": "068",
			"cca3": "BOL",
			"currency": [
				"BOB",
				"BOV"
			],
			"callingCode": [
				"591"
			],
			"capital": {
				"city": "sucre",
				"accentcity": "Sucre",
				"population": null,
				"latitude": "-21.6166667",
				"longitude": "-66.1333333"
			},
			"altSpellings": [
				"BO",
				"Buliwya",
				"Wuliwya",
				"Plurinational State of Bolivia",
				"Estado Plurinacional de Bolivia",
				"Buliwya Mamallaqta",
				"Wuliwya Suyu",
				"Tet Volvia"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				},
				{
					"name": "Quechua"
				},
				{
					"name": "Aymara"
				},
				{
					"name": "Guaran"
				}
			],
			"population": 10027254,
			"demonym": "Bolivian",
			"borders": [
				"ARG",
				"BRA",
				"CHL",
				"PRY",
				"PRU"
			]
		},
		{
			"name": "Bosnia and Herzegovina",
			"nativeName": "Bosna i Hercegovina",
			"tld": [
				".ba"
			],
			"cca2": "BA",
			"ccn3": "070",
			"cca3": "BIH",
			"currency": [
				"BAM"
			],
			"callingCode": [
				"387"
			],
			"capital": {
				"city": "sarajevo",
				"accentcity": "Sarajevo",
				"population": "696726",
				"latitude": "43.85",
				"longitude": "18.3833333"
			},
			"altSpellings": [
				"BA",
				"Bosnia-Herzegovina",
				"  "
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Bosnian"
				},
				{
					"name": "Croatian"
				},
				{
					"name": "Serbian"
				}
			],
			"population": 3791622,
			"demonym": "Bosnian, Herzegovinian",
			"borders": [
				"HRV",
				"MNE",
				"SRB"
			]
		},
		{
			"name": "Botswana",
			"nativeName": "Botswana",
			"tld": [
				".bw"
			],
			"cca2": "BW",
			"ccn3": "072",
			"cca3": "BWA",
			"currency": [
				"BWP"
			],
			"callingCode": [
				"267"
			],
			"capital": {
				"city": "gaborone",
				"accentcity": "Gaborone",
				"population": "208411",
				"latitude": "-24.6463889",
				"longitude": "25.9119444"
			},
			"altSpellings": [
				"BW",
				"Republic of Botswana",
				"Lefatshe la Botswana"
			],
			"region": "Africa",
			"subregion": "Southern Africa",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Setswana"
				}
			],
			"population": 2024904,
			"demonym": "Motswana",
			"borders": [
				"NAM",
				"ZAF",
				"ZMB",
				"ZWE"
			]
		},
		{
			"name": "British Virgin Islands",
			"nativeName": "British Virgin Islands",
			"tld": [
				".vg"
			],
			"cca2": "VG",
			"ccn3": "092",
			"cca3": "VGB",
			"currency": [
				"USD"
			],
			"callingCode": [
				"1284"
			],
			"capital": {
				"city": "road town",
				"accentcity": "Road Town",
				"population": "8449",
				"latitude": "18.4166667",
				"longitude": "-64.6166667"
			},
			"altSpellings": [
				"VG"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 29537,
			"demonym": "Virgin Islander",
			"borders": []
		},
		{
			"name": "Brunei",
			"nativeName": "Negara Brunei Darussalam",
			"tld": [
				".bn"
			],
			"cca2": "BN",
			"ccn3": "096",
			"cca3": "BRN",
			"currency": [
				"BND"
			],
			"callingCode": [
				"673"
			],
			"capital": {
				"city": "bandar seri begawan",
				"accentcity": "Bandar Seri Begawan",
				"population": null,
				"latitude": "4.8833333",
				"longitude": "114.9333333"
			},
			"altSpellings": [
				"BN",
				"Nation of Brunei",
				" the Abode of Peace"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Malay"
				}
			],
			"population": 393162,
			"demonym": "Bruneian",
			"borders": [
				"MYS"
			]
		},
		{
			"name": "Bulgaria",
			"nativeName": "",
			"tld": [
				".bg"
			],
			"cca2": "BG",
			"ccn3": "100",
			"cca3": "BGR",
			"currency": [
				"BGN"
			],
			"callingCode": [
				"359"
			],
			"capital": {
				"city": "sofia",
				"accentcity": "Sofia",
				"population": "1062065",
				"latitude": "42.6833333",
				"longitude": "23.3166667"
			},
			"altSpellings": [
				"BG",
				"Republic of Bulgaria",
				" "
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Bulgarian"
				}
			],
			"population": 7282041,
			"demonym": "Bulgarian",
			"borders": [
				"GRC",
				"MKD",
				"ROU",
				"SRB",
				"TUR"
			]
		},
		{
			"name": "Burkina Faso",
			"nativeName": "Burkina Faso",
			"tld": [
				".bf"
			],
			"cca2": "BF",
			"ccn3": "854",
			"cca3": "BFA",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"226"
			],
			"capital": {
				"city": "ouagadougou",
				"accentcity": "Ouagadougou",
				"population": "1031330",
				"latitude": "12.3702778",
				"longitude": "-1.5247222"
			},
			"altSpellings": [
				"BF"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 17322796,
			"demonym": "Burkinabe",
			"borders": [
				"BEN",
				"CIV",
				"GHA",
				"MLI",
				"NER",
				"TGO"
			]
		},
		{
			"name": "Burundi",
			"nativeName": "Burundi",
			"tld": [
				".bi"
			],
			"cca2": "BI",
			"ccn3": "108",
			"cca3": "BDI",
			"currency": [
				"BIF"
			],
			"callingCode": [
				"257"
			],
			"capital": {
				"city": "bujumbura",
				"accentcity": "Bujumbura",
				"population": "330539",
				"latitude": "-3.3761111",
				"longitude": "29.36"
			},
			"altSpellings": [
				"BI",
				"Republic of Burundi",
				"Republika y'Uburundi",
				"Rpublique du Burundi"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Kirundi"
				},
				{
					"name": "French"
				}
			],
			"population": 10163000,
			"demonym": "Burundian",
			"borders": [
				"COD",
				"RWA",
				"TZA"
			]
		},
		{
			"name": "Cambodia",
			"nativeName": "Kmpcha",
			"tld": [
				".kh"
			],
			"cca2": "KH",
			"ccn3": "116",
			"cca3": "KHM",
			"currency": [
				"KHR"
			],
			"callingCode": [
				"855"
			],
			"capital": {
				"city": "phnom penh",
				"accentcity": "Phnom Penh",
				"population": null,
				"latitude": "11.55",
				"longitude": "104.9166667"
			},
			"altSpellings": [
				"KH",
				"Kingdom of Cambodia"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Khmer"
				}
			],
			"population": 15135000,
			"demonym": "Cambodian",
			"borders": [
				"LAO",
				"THA",
				"VNM"
			]
		},
		{
			"name": "Canada",
			"nativeName": "Canada",
			"tld": [
				".ca"
			],
			"cca2": "CA",
			"ccn3": "124",
			"cca3": "CAN",
			"currency": [
				"CAD"
			],
			"callingCode": [
				"1"
			],
			"capital": {
				"city": "ottawa",
				"accentcity": "Ottawa",
				"population": "874433",
				"latitude": "45.416667",
				"longitude": "-75.7"
			},
			"altSpellings": [
				"CA"
			],
			"region": "Americas",
			"subregion": "Northern America",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "French"
				}
			],
			"population": 35158304,
			"demonym": "Canadian",
			"borders": [
				"USA"
			]
		},
		{
			"name": "Cape Verde",
			"nativeName": "Cabo Verde",
			"tld": [
				".cv"
			],
			"cca2": "CV",
			"ccn3": "132",
			"cca3": "CPV",
			"currency": [
				"CVE"
			],
			"callingCode": [
				"238"
			],
			"capital": {
				"city": "praia",
				"accentcity": "Praia",
				"population": "111611",
				"latitude": "14.9166667",
				"longitude": "-23.5166667"
			},
			"altSpellings": [
				"CV",
				"Republic of Cabo Verde",
				"Repblica de Cabo Verde"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "Portuguese"
				}
			],
			"population": 491875,
			"demonym": "Cape Verdian",
			"borders": []
		},
		{
			"name": "Cayman Islands",
			"nativeName": "Cayman Islands",
			"tld": [
				".ky"
			],
			"cca2": "KY",
			"ccn3": "136",
			"cca3": "CYM",
			"currency": [
				"KYD"
			],
			"callingCode": [
				"1345"
			],
			"capital": {
				"city": "george town",
				"accentcity": "George Town",
				"population": "27340",
				"latitude": "19.3",
				"longitude": "-81.3833333"
			},
			"altSpellings": [
				"KY"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 55456,
			"demonym": "Caymanian",
			"borders": []
		},
		{
			"name": "Central African Republic",
			"nativeName": "Kdrsse t Bafrka",
			"tld": [
				".cf"
			],
			"cca2": "CF",
			"ccn3": "140",
			"cca3": "CAF",
			"currency": [
				"XAF"
			],
			"callingCode": [
				"236"
			],
			"capital": {
				"city": "bangui",
				"accentcity": "Bangui",
				"population": "684190",
				"latitude": "4.3666667",
				"longitude": "18.5833333"
			},
			"altSpellings": [
				"CF",
				"Central African Republic",
				"Rpublique centrafricaine"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "Sango"
				},
				{
					"name": "French"
				}
			],
			"population": 4616000,
			"demonym": "Central African",
			"borders": [
				"CMR",
				"TCD",
				"COD",
				"COG",
				"SSD",
				"SDN"
			]
		},
		{
			"name": "Chad",
			"nativeName": "Tchad",
			"tld": [
				".td"
			],
			"cca2": "TD",
			"ccn3": "148",
			"cca3": "TCD",
			"currency": [
				"XAF"
			],
			"callingCode": [
				"235"
			],
			"capital": {
				"city": "n'djamena",
				"accentcity": "N'Djamena",
				"population": null,
				"latitude": "12.1130556",
				"longitude": "15.0491667"
			},
			"altSpellings": [
				"TD",
				"Tchad",
				"Republic of Chad",
				"Rpublique du Tchad"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "French"
				},
				{
					"name": "Arabic"
				}
			],
			"population": 12825000,
			"demonym": "Chadian",
			"borders": [
				"CMR",
				"CAF",
				"LBY",
				"NER",
				"NGA",
				"SSD"
			]
		},
		{
			"name": "Chile",
			"nativeName": "Chile",
			"tld": [
				".cl"
			],
			"cca2": "CL",
			"ccn3": "152",
			"cca3": "CHL",
			"currency": [
				"CLF",
				"CLP"
			],
			"callingCode": [
				"56"
			],
			"capital": {
				"city": "santiago",
				"accentcity": "Santiago",
				"population": "4837248",
				"latitude": "-33.45",
				"longitude": "-70.6666667"
			},
			"altSpellings": [
				"CL",
				"Republic of Chile",
				"Repblica de Chile"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 16634603,
			"demonym": "Chilean",
			"borders": [
				"ARG",
				"BOL",
				"PER"
			]
		},
		{
			"name": "China",
			"nativeName": "",
			"tld": [
				".cn"
			],
			"cca2": "CN",
			"ccn3": "156",
			"cca3": "CHN",
			"currency": [
				"CNY"
			],
			"callingCode": [
				"86"
			],
			"capital": {
				"city": "beijing",
				"accentcity": "Beijing",
				"population": null,
				"latitude": "35.2091667",
				"longitude": "110.7327778"
			},
			"altSpellings": [
				"CN",
				"Zhnggu",
				"Zhongguo",
				"Zhonghua",
				"People's Republic of China",
				"",
				"Zhnghu Rnmn Gnghgu"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Standard Chinese"
				}
			],
			"population": 1361170000,
			"demonym": "Chinese",
			"borders": [
				"AFG",
				"BTN",
				"MMR",
				"HKG",
				"IND",
				"KAZ",
				"PRK",
				"KGZ",
				"LAO",
				"MAC",
				"MNG",
				"PAK",
				"RUS",
				"TJK",
				"VNM"
			]
		},
		{
			"name": "Christmas Island",
			"nativeName": "Christmas Island",
			"tld": [
				".cx"
			],
			"cca2": "CX",
			"ccn3": "162",
			"cca3": "CXR",
			"currency": [
				"AUD"
			],
			"callingCode": [
				"61"
			],
			"capital": {
				"city": "flying fish cove",
				"accentcity": "Flying Fish Cove",
				"population": null,
				"latitude": "-10.4166667",
				"longitude": "105.7166667"
			},
			"altSpellings": [
				"CX",
				"Territory of Christmas Island"
			],
			"region": "Oceania",
			"subregion": [
				"Australia",
				"New Zealand"
			],
			"language": [
				{
					"name": "English"
				}
			],
			"population": 2072,
			"demonym": "Christmas Island",
			"borders": []
		},
		{
			"name": "Comoros",
			"nativeName": "Komori",
			"tld": [
				".km"
			],
			"cca2": "KM",
			"ccn3": "174",
			"cca3": "COM",
			"currency": [
				"KMF"
			],
			"callingCode": [
				"269"
			],
			"capital": {
				"city": "moroni",
				"accentcity": "Moroni",
				"population": "42882",
				"latitude": "-11.7041667",
				"longitude": "43.2402778"
			},
			"altSpellings": [
				"KM",
				"Union of the Comoros",
				"Union des Comores",
				"Udzima wa Komori",
				"al-Ittid al-Qumur"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Comorian"
				},
				{
					"name": "Arabic"
				},
				{
					"name": "French"
				}
			],
			"population": 724300,
			"demonym": "Comoran",
			"borders": []
		},
		{
			"name": "Republic of the Congo",
			"nativeName": "Rpublique du Congo",
			"tld": [
				".cg"
			],
			"cca2": "CG",
			"ccn3": "178",
			"cca3": "COG",
			"currency": [
				"XAF"
			],
			"callingCode": [
				"242"
			],
			"capital": {
				"city": "brazzaville",
				"accentcity": "Brazzaville",
				"population": "1115773",
				"latitude": "-4.2591667",
				"longitude": "15.2847222"
			},
			"altSpellings": [
				"CG",
				"Congo-Brazzaville"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 4448000,
			"demonym": "Congolese",
			"borders": [
				"AGO",
				"CMR",
				"CAF",
				"COD",
				"GAB"
			]
		},
		{
			"name": "Democratic Republic of the Congo",
			"nativeName": "Rpublique dmocratique du Congo",
			"tld": [
				".cd"
			],
			"cca2": "CD",
			"ccn3": "180",
			"cca3": "COD",
			"currency": [
				"CDF"
			],
			"callingCode": [
				"243"
			],
			"capital": {
				"city": "kinshasa",
				"accentcity": "Kinshasa",
				"population": "7787832",
				"latitude": "-4.3",
				"longitude": "15.3"
			},
			"altSpellings": [
				"CD",
				"DR Congo",
				"Congo-Kinshasa",
				"DRC"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 67514000,
			"demonym": "Congolese",
			"borders": [
				"AGO",
				"BDI",
				"CAF",
				"COG",
				"RWA",
				"SSD",
				"TZA",
				"UGA",
				"ZMB"
			]
		},
		{
			"name": "Cook Islands",
			"nativeName": "Cook Islands",
			"tld": [
				".ck"
			],
			"cca2": "CK",
			"ccn3": "184",
			"cca3": "COK",
			"currency": [
				"NZD"
			],
			"callingCode": [
				"682"
			],
			"capital": {
				"city": "avarua",
				"accentcity": "Avarua",
				"population": "13374",
				"latitude": "-21.2077778",
				"longitude": "-159.775"
			},
			"altSpellings": [
				"CK",
				"Kki 'irani"
			],
			"region": "Oceania",
			"subregion": "Polynesia",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Cook Islands Mori"
				}
			],
			"population": 14974,
			"demonym": "Cook Islander",
			"borders": []
		},
		{
			"name": "Cte d'Ivoire",
			"nativeName": "Cte d'Ivoire",
			"tld": [
				".ci"
			],
			"cca2": "CI",
			"ccn3": "384",
			"cca3": "CIV",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"225"
			],
			"capital": {
				"city": "yamoussoukro",
				"accentcity": "Yamoussoukro",
				"population": "200659",
				"latitude": "6.816667",
				"longitude": "-5.283333"
			},
			"altSpellings": [
				"CI",
				"Ivory Coast",
				"Republic of Cte d'Ivoire",
				"Rpublique de Cte d'Ivoire"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": -1,
			"demonym": "Ivorian",
			"borders": [
				"BFA",
				"GHA",
				"GIN",
				"LBR",
				"MLI"
			]
		},
		{
			"name": "Croatia",
			"nativeName": "Hrvatska",
			"tld": [
				".hr"
			],
			"cca2": "HR",
			"ccn3": "191",
			"cca3": "HRV",
			"currency": [
				"HRK"
			],
			"callingCode": [
				"385"
			],
			"capital": {
				"city": "zagreb",
				"accentcity": "Zagreb",
				"population": "698967",
				"latitude": "45.8",
				"longitude": "16.0"
			},
			"altSpellings": [
				"HR",
				"Hrvatska",
				"Republic of Croatia",
				"Republika Hrvatska"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Croatian"
				}
			],
			"population": 4290612,
			"demonym": "Croatian",
			"borders": [
				"BIH",
				"HUN",
				"MNE",
				"SRB",
				"SVN"
			]
		},
		{
			"name": "Cuba",
			"nativeName": "Cuba",
			"tld": [
				".cu"
			],
			"cca2": "CU",
			"ccn3": "192",
			"cca3": "CUB",
			"currency": [
				"CUC",
				"CUP"
			],
			"callingCode": [
				"53"
			],
			"capital": {
				"city": "havana",
				"accentcity": "Havana",
				"population": null,
				"latitude": "23.1319444",
				"longitude": "-82.3641667"
			},
			"altSpellings": [
				"CU",
				"Republic of Cuba",
				"Repblica de Cuba"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 11167325,
			"demonym": "Cuban",
			"borders": []
		},
		{
			"name": "Cyprus",
			"nativeName": "",
			"tld": [
				".cy"
			],
			"cca2": "CY",
			"ccn3": "196",
			"cca3": "CYP",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"357"
			],
			"capital": {
				"city": "nicosia",
				"accentcity": "Nicosia",
				"population": "42342",
				"latitude": "35.1666667",
				"longitude": "33.3666667"
			},
			"altSpellings": [
				"CY",
				"Kpros",
				"Kbrs",
				"Republic of Cyprus",
				" ",
				"Kbrs Cumhuriyeti"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Greek"
				},
				{
					"name": "Turkish"
				}
			],
			"population": 865878,
			"demonym": "Cypriot",
			"borders": []
		},
		{
			"name": "Czech Republic",
			"nativeName": "esk republika",
			"tld": [
				".cz"
			],
			"cca2": "CZ",
			"ccn3": "203",
			"cca3": "CZE",
			"currency": [
				"CZK"
			],
			"callingCode": [
				"420"
			],
			"capital": {
				"city": "prague",
				"accentcity": "Prague",
				"population": "1154508",
				"latitude": "50.0833333",
				"longitude": "14.4666667"
			},
			"altSpellings": [
				"CZ",
				"esk republika",
				"esko"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Czech"
				}
			],
			"population": 10512900,
			"demonym": "Czech",
			"borders": [
				"AUT",
				"DEU",
				"POL",
				"SVK"
			]
		},
		{
			"name": "Denmark",
			"nativeName": "Danmark",
			"tld": [
				".dk"
			],
			"cca2": "DK",
			"ccn3": "208",
			"cca3": "DNK",
			"currency": [
				"DKK"
			],
			"callingCode": [
				"45"
			],
			"capital": {
				"city": "copenhagen",
				"accentcity": "Copenhagen",
				"population": "1089958",
				"latitude": "55.666667",
				"longitude": "12.583333"
			},
			"altSpellings": [
				"DK",
				"Danmark",
				"Kingdom of Denmark",
				"Kongeriget Danmark"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Danish"
				}
			],
			"population": 5623501,
			"demonym": "Danish",
			"borders": [
				"DEU"
			]
		},
		{
			"name": "Djibouti",
			"nativeName": "Djibouti",
			"tld": [
				".dj"
			],
			"cca2": "DJ",
			"ccn3": "262",
			"cca3": "DJI",
			"currency": [
				"DJF"
			],
			"callingCode": [
				"253"
			],
			"capital": {
				"city": "djibouti",
				"accentcity": "Djibouti",
				"population": null,
				"latitude": "11.595",
				"longitude": "43.1480556"
			},
			"altSpellings": [
				"DJ",
				"Jabuuti",
				"Gabuuti",
				"Republic of Djibouti",
				"Rpublique de Djibouti",
				"Gabuutih Ummuuno",
				"Jamhuuriyadda Jabuuti"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "French"
				},
				{
					"name": "Arabic"
				}
			],
			"population": 864618,
			"demonym": "Djibouti",
			"borders": [
				"ERI",
				"ETH",
				"SOM"
			]
		},
		{
			"name": "Dominica",
			"nativeName": "Dominica",
			"tld": [
				".dm"
			],
			"cca2": "DM",
			"ccn3": "212",
			"cca3": "DMA",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1767"
			],
			"capital": {
				"city": "roseau",
				"accentcity": "Roseau",
				"population": "16571",
				"latitude": "15.3",
				"longitude": "-61.4"
			},
			"altSpellings": [
				"DM",
				"Dominique",
				"Waitu kubuli",
				"Commonwealth of Dominica"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 71293,
			"demonym": "Dominican",
			"borders": []
		},
		{
			"name": "Dominican Republic",
			"nativeName": "Repblica Dominicana",
			"tld": [
				".do"
			],
			"cca2": "DO",
			"ccn3": "214",
			"cca3": "DOM",
			"currency": [
				"DOP"
			],
			"callingCode": [
				"1809",
				"1829",
				"1849"
			],
			"capital": {
				"city": "santo domingo",
				"accentcity": "Santo Domingo",
				"population": "2202016",
				"latitude": "18.4666667",
				"longitude": "-69.9"
			},
			"altSpellings": [
				"DO"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 9445281,
			"demonym": "Dominican",
			"borders": [
				"HTI"
			]
		},
		{
			"name": "Ecuador",
			"nativeName": "Ecuador",
			"tld": [
				".ec"
			],
			"cca2": "EC",
			"ccn3": "218",
			"cca3": "ECU",
			"currency": [
				"USD"
			],
			"callingCode": [
				"593"
			],
			"capital": {
				"city": "quito",
				"accentcity": "Quito",
				"population": "1399814",
				"latitude": "-0.2166667",
				"longitude": "-78.5"
			},
			"altSpellings": [
				"EC",
				"Republic of Ecuador",
				"Repblica del Ecuador"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 15617900,
			"demonym": "Ecuadorean",
			"borders": [
				"COL",
				"PER"
			]
		},
		{
			"name": "Egypt",
			"nativeName": "Mir",
			"tld": [
				".eg"
			],
			"cca2": "EG",
			"ccn3": "818",
			"cca3": "EGY",
			"currency": [
				"EGP"
			],
			"callingCode": [
				"20"
			],
			"capital": {
				"city": "cairo",
				"accentcity": "Cairo",
				"population": "7734602",
				"latitude": "30.05",
				"longitude": "31.25"
			},
			"altSpellings": [
				"EG",
				"Arab Republic of Egypt"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Egyptian Arabic"
				}
			],
			"population": 83661000,
			"demonym": "Egyptian",
			"borders": [
				"ISR",
				"LBY",
				"SDN"
			]
		},
		{
			"name": "El Salvador",
			"nativeName": "El Salvador",
			"tld": [
				".sv"
			],
			"cca2": "SV",
			"ccn3": "222",
			"cca3": "SLV",
			"currency": [
				"SVC",
				"USD"
			],
			"callingCode": [
				"503"
			],
			"capital": {
				"city": "san salvador",
				"accentcity": "San Salvador",
				"population": "526013",
				"latitude": "13.7086111",
				"longitude": "-89.2030556"
			},
			"altSpellings": [
				"SV",
				"Republic of El Salvador",
				"Repblica de El Salvador"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "Castilian"
				}
			],
			"population": 6340000,
			"demonym": "Salvadoran",
			"borders": [
				"GTM",
				"HND"
			]
		},
		{
			"name": "Equatorial Guinea",
			"nativeName": "Guinea Ecuatorial",
			"tld": [
				".gq"
			],
			"cca2": "GQ",
			"ccn3": "226",
			"cca3": "GNQ",
			"currency": [
				"XAF"
			],
			"callingCode": [
				"240"
			],
			"capital": {
				"city": "malabo",
				"accentcity": "Malabo",
				"population": null,
				"latitude": "3.35",
				"longitude": "8.65"
			},
			"altSpellings": [
				"GQ",
				"Republic of Equatorial Guinea",
				"Repblica de Guinea Ecuatorial",
				"Rpublique de Guine quatoriale",
				"Repblica da Guin Equatorial"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "Spanish"
				},
				{
					"name": "French"
				},
				{
					"name": "Portuguese"
				}
			],
			"population": 1622000,
			"demonym": "Equatorial Guinean",
			"borders": [
				"CMR",
				"GAB"
			]
		},
		{
			"name": "Eritrea",
			"nativeName": "",
			"tld": [
				".er"
			],
			"cca2": "ER",
			"ccn3": "232",
			"cca3": "ERI",
			"currency": [
				"ERN"
			],
			"callingCode": [
				"291"
			],
			"capital": {
				"city": "asmara",
				"accentcity": "Asmara",
				"population": "563948",
				"latitude": "15.3333333",
				"longitude": "38.9333333"
			},
			"altSpellings": [
				"ER",
				"State of Eritrea",
				" ",
				"Dawlat Iritriy",
				"Ertr",
				"Iritriy",
				""
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Tigrinya"
				},
				{
					"name": "Arabic"
				},
				{
					"name": "English"
				}
			],
			"population": 6333000,
			"demonym": "Eritrean",
			"borders": [
				"DJI",
				"ETH",
				"SDN"
			]
		},
		{
			"name": "Estonia",
			"nativeName": "Eesti",
			"tld": [
				".ee"
			],
			"cca2": "EE",
			"ccn3": "233",
			"cca3": "EST",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"372"
			],
			"capital": {
				"city": "tallinn",
				"accentcity": "Tallinn",
				"population": "394023",
				"latitude": "59.4338889",
				"longitude": "24.7280556"
			},
			"altSpellings": [
				"EE",
				"Eesti",
				"Republic of Estonia",
				"Eesti Vabariik"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Estonian"
				}
			],
			"population": 1286540,
			"demonym": "Estonian",
			"borders": [
				"LVA",
				"RUS"
			]
		},
		{
			"name": "Ethiopia",
			"nativeName": "",
			"tld": [
				".et"
			],
			"cca2": "ET",
			"ccn3": "231",
			"cca3": "ETH",
			"currency": [
				"ETB"
			],
			"callingCode": [
				"251"
			],
			"capital": {
				"city": "addis ababa",
				"accentcity": "Addis Ababa",
				"population": null,
				"latitude": "9.0333333",
				"longitude": "38.7"
			},
			"altSpellings": [
				"ET",
				"tyy",
				"Federal Democratic Republic of Ethiopia",
				"   "
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Amharic"
				}
			],
			"population": 86613986,
			"demonym": "Ethiopian",
			"borders": [
				"DJI",
				"ERI",
				"KEN",
				"SOM",
				"SSD",
				"SDN"
			]
		},
		{
			"name": "Falkland Islands",
			"nativeName": "Falkland Islands",
			"tld": [
				".fk"
			],
			"cca2": "FK",
			"ccn3": "238",
			"cca3": "FLK",
			"currency": [
				"FKP"
			],
			"callingCode": [
				"500"
			],
			"capital": {
				"city": "stanley",
				"accentcity": "Stanley",
				"population": null,
				"latitude": "-51.7",
				"longitude": "-57.85"
			},
			"altSpellings": [
				"FK",
				"Islas Malvinas"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 2563,
			"demonym": "Falkland Islander",
			"borders": []
		},
		{
			"name": "Fiji",
			"nativeName": "Fiji",
			"tld": [
				".fj"
			],
			"cca2": "FJ",
			"ccn3": "242",
			"cca3": "FJI",
			"currency": [
				"FJD"
			],
			"callingCode": [
				"679"
			],
			"capital": {
				"city": "suva",
				"accentcity": "Suva",
				"population": null,
				"latitude": "-18.1333333",
				"longitude": "178.4166667"
			},
			"altSpellings": [
				"FJ",
				"Viti",
				"Republic of Fiji",
				"Matanitu ko Viti",
				"Fij Gaarjya"
			],
			"region": "Oceania",
			"subregion": "Melanesia",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Fijian"
				},
				{
					"name": "Fiji Hindi"
				}
			],
			"population": 858038,
			"demonym": "Fijian",
			"borders": []
		},
		{
			"name": "Finland",
			"nativeName": "Suomi",
			"tld": [
				".fi"
			],
			"cca2": "FI",
			"ccn3": "246",
			"cca3": "FIN",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"358"
			],
			"capital": {
				"city": "helsinki",
				"accentcity": "Helsinki",
				"population": null,
				"latitude": "60.6",
				"longitude": "21.433333"
			},
			"altSpellings": [
				"FI",
				"Suomi",
				"Republic of Finland",
				"Suomen tasavalta",
				"Republiken Finland"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Finnish"
				},
				{
					"name": "Swedish"
				}
			],
			"population": 5445883,
			"demonym": "Finnish",
			"borders": [
				"NOR",
				"SWE",
				"RUS"
			]
		},
		{
			"name": "France",
			"nativeName": "France",
			"tld": [
				".fr"
			],
			"cca2": "FR",
			"ccn3": "250",
			"cca3": "FRA",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"33"
			],
			"capital": {
				"city": "paris",
				"accentcity": "Paris",
				"population": null,
				"latitude": "45.633333",
				"longitude": "5.733333"
			},
			"altSpellings": [
				"FR",
				"French Republic",
				"Rpublique franaise"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 65806000,
			"demonym": "French",
			"borders": [
				"AND",
				"BEL",
				"DEU",
				"ITA",
				"LUX",
				"MCO",
				"ESP",
				"CHE"
			]
		},
		{
			"name": "French Guiana",
			"nativeName": "Guyane franaise",
			"tld": [
				".gf"
			],
			"cca2": "GF",
			"ccn3": "254",
			"cca3": "GUF",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"594"
			],
			"capital": {
				"city": "cayenne",
				"accentcity": "Cayenne",
				"population": "61642",
				"latitude": "4.9333333",
				"longitude": "-52.3333333"
			},
			"altSpellings": [
				"GF",
				"Guiana",
				"Guyane"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 229040,
			"demonym": "",
			"borders": [
				"BRA",
				"SUR"
			]
		},
		{
			"name": "Gabon",
			"nativeName": "Gabon",
			"tld": [
				".ga"
			],
			"cca2": "GA",
			"ccn3": "266",
			"cca3": "GAB",
			"currency": [
				"XAF"
			],
			"callingCode": [
				"241"
			],
			"capital": {
				"city": "libreville",
				"accentcity": "Libreville",
				"population": "578156",
				"latitude": "0.3833333",
				"longitude": "9.45"
			},
			"altSpellings": [
				"GA",
				"Gabonese Republic",
				"Rpublique Gabonaise"
			],
			"region": "Africa",
			"subregion": "Middle Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 1672000,
			"demonym": "Gabonese",
			"borders": [
				"CMR",
				"COG",
				"GNQ"
			]
		},
		{
			"name": "Gambia",
			"nativeName": "Gambia",
			"tld": [
				".gm"
			],
			"cca2": "GM",
			"ccn3": "270",
			"cca3": "GMB",
			"currency": [
				"GMD"
			],
			"callingCode": [
				"220"
			],
			"capital": {
				"city": "banjul",
				"accentcity": "Banjul",
				"population": "34598",
				"latitude": "13.4530556",
				"longitude": "-16.5775"
			},
			"altSpellings": [
				"GM",
				"Republic of the Gambia"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": -1,
			"demonym": "Gambian",
			"borders": [
				"SEN"
			]
		},
		{
			"name": "Georgia",
			"nativeName": "",
			"tld": [
				".ge"
			],
			"cca2": "GE",
			"ccn3": "268",
			"cca3": "GEO",
			"currency": [
				"GEL"
			],
			"callingCode": [
				"995"
			],
			"capital": {
				"city": "tbilisi",
				"accentcity": "Tbilisi",
				"population": "1049516",
				"latitude": "41.725",
				"longitude": "44.7908333"
			},
			"altSpellings": [
				"GE",
				"Sakartvelo"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Georgian"
				}
			],
			"population": -1,
			"demonym": "Georgian",
			"borders": [
				"ARM",
				"AZE",
				"RUS",
				"TUR"
			]
		},
		{
			"name": "Germany",
			"nativeName": "Deutschland",
			"tld": [
				".de"
			],
			"cca2": "DE",
			"ccn3": "276",
			"cca3": "DEU",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"49"
			],
			"capital": {
				"city": "berlin",
				"accentcity": "Berlin",
				"population": "3398362",
				"latitude": "52.516667",
				"longitude": "13.4"
			},
			"altSpellings": [
				"DE",
				"Federal Republic of Germany",
				"Bundesrepublik Deutschland"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "German"
				}
			],
			"population": 80523700,
			"demonym": "German",
			"borders": [
				"AUT",
				"BEL",
				"CZE",
				"DNK",
				"FRA",
				"LUX",
				"NLD",
				"POL",
				"CHE"
			]
		},
		{
			"name": "Ghana",
			"nativeName": "Ghana",
			"tld": [
				".gh"
			],
			"cca2": "GH",
			"ccn3": "288",
			"cca3": "GHA",
			"currency": [
				"GHS"
			],
			"callingCode": [
				"233"
			],
			"capital": {
				"city": "accra",
				"accentcity": "Accra",
				"population": "1963460",
				"latitude": "5.55",
				"longitude": "-0.2166667"
			},
			"altSpellings": [
				"GH"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 24658823,
			"demonym": "Ghanaian",
			"borders": [
				"BFA",
				"CIV",
				"TGO"
			]
		},
		{
			"name": "Gibraltar",
			"nativeName": "Gibraltar",
			"tld": [
				".gi"
			],
			"cca2": "GI",
			"ccn3": "292",
			"cca3": "GIB",
			"currency": [
				"GIP"
			],
			"callingCode": [
				"350"
			],
			"capital": {
				"city": "gibraltar",
				"accentcity": "Gibraltar",
				"population": "26544",
				"latitude": "36.1333333",
				"longitude": "-5.35"
			},
			"altSpellings": [
				"GI"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 29752,
			"demonym": "Gibraltar",
			"borders": [
				"ESP"
			]
		},
		{
			"name": "Greece",
			"nativeName": "",
			"tld": [
				".gr"
			],
			"cca2": "GR",
			"ccn3": "300",
			"cca3": "GRC",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"30"
			],
			"capital": {
				"city": "athens",
				"accentcity": "Athens",
				"population": "729139",
				"latitude": "37.9833333",
				"longitude": "23.7333333"
			},
			"altSpellings": [
				"GR",
				"Ellda",
				"Hellenic Republic",
				" "
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Greek"
				}
			],
			"population": 10815197,
			"demonym": "Greek",
			"borders": [
				"ALB",
				"BGR",
				"TUR",
				"MKD"
			]
		},
		{
			"name": "Greenland",
			"nativeName": "Kalaallit Nunaat",
			"tld": [
				".gl"
			],
			"cca2": "GL",
			"ccn3": "304",
			"cca3": "GRL",
			"currency": [
				"DKK"
			],
			"callingCode": [
				"299"
			],
			"capital": {
				"city": "nuuk",
				"accentcity": "Nuuk",
				"population": "14799",
				"latitude": "64.1833333",
				"longitude": "-51.75"
			},
			"altSpellings": [
				"GL",
				"Grnland"
			],
			"region": "Americas",
			"subregion": "Northern America",
			"language": [
				{
					"name": "Greenlandic"
				}
			],
			"population": 56370,
			"demonym": "Greenlandic",
			"borders": []
		},
		{
			"name": "Guadeloupe",
			"nativeName": "Guadeloupe",
			"tld": [
				".gp"
			],
			"cca2": "GP",
			"ccn3": "312",
			"cca3": "GLP",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"590"
			],
			"capital": {
				"city": "basse-terre",
				"accentcity": "Basse-Terre",
				"population": "11472",
				"latitude": "16.0",
				"longitude": "-61.7166667"
			},
			"altSpellings": [
				"GP",
				"Gwadloup"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 403355,
			"demonym": "Guadeloupian",
			"borders": []
		},
		{
			"name": "Guatemala",
			"nativeName": "Guatemala",
			"tld": [
				".gt"
			],
			"cca2": "GT",
			"ccn3": "320",
			"cca3": "GTM",
			"currency": [
				"GTQ"
			],
			"callingCode": [
				"502"
			],
			"capital": {
				"city": "guatemala city",
				"accentcity": "Guatemala City",
				"population": "973208",
				"latitude": "14.6211111",
				"longitude": "-90.5269444"
			},
			"altSpellings": [
				"GT"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 15438384,
			"demonym": "Guatemalan",
			"borders": [
				"BLZ",
				"SLV",
				"HND",
				"MEX"
			]
		},
		{
			"name": "Guinea",
			"nativeName": "Guine",
			"tld": [
				".gn"
			],
			"cca2": "GN",
			"ccn3": "324",
			"cca3": "GIN",
			"currency": [
				"GNF"
			],
			"callingCode": [
				"224"
			],
			"capital": {
				"city": "conakry",
				"accentcity": "Conakry",
				"population": "1871185",
				"latitude": "9.5091667",
				"longitude": "-13.7122222"
			},
			"altSpellings": [
				"GN",
				"Republic of Guinea",
				"Rpublique de Guine"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 10824200,
			"demonym": "Guinean",
			"borders": [
				"CIV",
				"GNB",
				"LBR",
				"MLI",
				"SEN",
				"SLE"
			]
		},
		{
			"name": "Guinea-Bissau",
			"nativeName": "Guin-Bissau",
			"tld": [
				".gw"
			],
			"cca2": "GW",
			"ccn3": "624",
			"cca3": "GNB",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"245"
			],
			"capital": {
				"city": "bissau",
				"accentcity": "Bissau",
				"population": "388094",
				"latitude": "11.85",
				"longitude": "-15.5833333"
			},
			"altSpellings": [
				"GW",
				"Republic of Guinea-Bissau",
				"Repblica da Guin-Bissau"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "Portuguese"
				}
			],
			"population": 1704000,
			"demonym": "Guinea-Bissauan",
			"borders": [
				"GIN",
				"SEN"
			]
		},
		{
			"name": "Guyana",
			"nativeName": "Guyana",
			"tld": [
				".gy"
			],
			"cca2": "GY",
			"ccn3": "328",
			"cca3": "GUY",
			"currency": [
				"GYD"
			],
			"callingCode": [
				"592"
			],
			"capital": {
				"city": "georgetown",
				"accentcity": "Georgetown",
				"population": "235017",
				"latitude": "6.8",
				"longitude": "-58.1666667"
			},
			"altSpellings": [
				"GY",
				"Co-operative Republic of Guyana"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 784894,
			"demonym": "Guyanese",
			"borders": [
				"BRA",
				"SUR",
				"VEN"
			]
		},
		{
			"name": "Haiti",
			"nativeName": "Hati",
			"tld": [
				".ht"
			],
			"cca2": "HT",
			"ccn3": "332",
			"cca3": "HTI",
			"currency": [
				"HTG",
				"USD"
			],
			"callingCode": [
				"509"
			],
			"capital": {
				"city": "port-au-prince",
				"accentcity": "Port-au-Prince",
				"population": "1234750",
				"latitude": "18.5391667",
				"longitude": "-72.335"
			},
			"altSpellings": [
				"HT",
				"Republic of Haiti",
				"Rpublique d'Hati",
				"Repiblik Ayiti"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "French"
				},
				{
					"name": "Haitian Creole"
				}
			],
			"population": 10413211,
			"demonym": "Haitian",
			"borders": [
				"DOM"
			]
		},
		{
			"name": "Honduras",
			"nativeName": "Honduras",
			"tld": [
				".hn"
			],
			"cca2": "HN",
			"ccn3": "340",
			"cca3": "HND",
			"currency": [
				"HNL"
			],
			"callingCode": [
				"504"
			],
			"capital": {
				"city": "tegucigalpa",
				"accentcity": "Tegucigalpa",
				"population": null,
				"latitude": "15.1333333",
				"longitude": "-87.4666667"
			},
			"altSpellings": [
				"HN",
				"Republic of Honduras",
				"Repblica de Honduras"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 8555072,
			"demonym": "Honduran",
			"borders": [
				"GTM",
				"SLV",
				"NIC"
			]
		},
		{
			"name": "Hungary",
			"nativeName": "Magyarorszg",
			"tld": [
				".hu"
			],
			"cca2": "HU",
			"ccn3": "348",
			"cca3": "HUN",
			"currency": [
				"HUF"
			],
			"callingCode": [
				"36"
			],
			"capital": {
				"city": "budapest",
				"accentcity": "Budapest",
				"population": "1708088",
				"latitude": "47.5",
				"longitude": "19.0833333"
			},
			"altSpellings": [
				"HU"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Hungarian"
				}
			],
			"population": 9906000,
			"demonym": "Hungarian",
			"borders": [
				"AUT",
				"HRV",
				"ROU",
				"SRB",
				"SVK",
				"SVN",
				"UKR"
			]
		},
		{
			"name": "Iceland",
			"nativeName": "sland",
			"tld": [
				".is"
			],
			"cca2": "IS",
			"ccn3": "352",
			"cca3": "ISL",
			"currency": [
				"ISK"
			],
			"callingCode": [
				"354"
			],
			"capital": {
				"city": "reykjavik",
				"accentcity": "Reykjavk",
				"population": "113907",
				"latitude": "64.15",
				"longitude": "-21.95"
			},
			"altSpellings": [
				"IS",
				"Island",
				"Republic of Iceland",
				"Lveldi sland"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Icelandic"
				}
			],
			"population": 325010,
			"demonym": "Icelander",
			"borders": []
		},
		{
			"name": "India",
			"nativeName": "",
			"tld": [
				".in"
			],
			"cca2": "IN",
			"ccn3": "356",
			"cca3": "IND",
			"currency": [
				"INR"
			],
			"callingCode": [
				"91"
			],
			"capital": {
				"city": "new delhi",
				"accentcity": "New Delhi",
				"population": "10928270",
				"latitude": "28.6",
				"longitude": "77.2"
			},
			"altSpellings": [
				"IN",
				"Bhrat",
				"Republic of India",
				"Bharat Ganrajya"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Hindi"
				},
				{
					"name": "English"
				}
			],
			"population": 1236670000,
			"demonym": "Indian",
			"borders": [
				"AFG",
				"BGD",
				"BTN",
				"MMR",
				"CHN",
				"NPL",
				"PAK",
				"LKA"
			]
		},
		{
			"name": "Indonesia",
			"nativeName": "Indonesia",
			"tld": [
				".id"
			],
			"cca2": "ID",
			"ccn3": "360",
			"cca3": "IDN",
			"currency": [
				"IDR"
			],
			"callingCode": [
				"62"
			],
			"capital": {
				"city": "jakarta",
				"accentcity": "Jakarta",
				"population": "8540306",
				"latitude": "-6.174444",
				"longitude": "106.829444"
			},
			"altSpellings": [
				"ID",
				"Republic of Indonesia",
				"Republik Indonesia"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Indonesian"
				}
			],
			"population": 237641326,
			"demonym": "Indonesian",
			"borders": [
				"TLS",
				"MYS",
				"PNG"
			]
		},
		{
			"name": "Iran",
			"nativeName": "Irn",
			"tld": [
				".ir"
			],
			"cca2": "IR",
			"ccn3": "364",
			"cca3": "IRN",
			"currency": [
				"IRR"
			],
			"callingCode": [
				"98"
			],
			"capital": {
				"city": "tehran",
				"accentcity": "Tehran",
				"population": null,
				"latitude": "32.7026",
				"longitude": "51.1537"
			},
			"altSpellings": [
				"IR",
				"Islamic Republic of Iran",
				"Jomhuri-ye Eslmi-ye Irn"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Persian"
				}
			],
			"population": 77068000,
			"demonym": "Iranian",
			"borders": [
				"AFG",
				"ARM",
				"AZE",
				"IRQ",
				"PAK",
				"TUR",
				"TKM"
			]
		},
		{
			"name": "Iraq",
			"nativeName": "Irq",
			"tld": [
				".iq"
			],
			"cca2": "IQ",
			"ccn3": "368",
			"cca3": "IRQ",
			"currency": [
				"IQD"
			],
			"callingCode": [
				"964"
			],
			"capital": {
				"city": "baghdad",
				"accentcity": "Baghdad",
				"population": "5672516",
				"latitude": "33.3386111",
				"longitude": "44.3938889"
			},
			"altSpellings": [
				"IQ",
				"Republic of Iraq",
				"Jumhriyyat al-Irq"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				},
				{
					"name": "Kurdish"
				}
			],
			"population": 34035000,
			"demonym": "Iraqi",
			"borders": [
				"IRN",
				"JOR",
				"KWT",
				"SAU",
				"SYR",
				"TUR"
			]
		},
		{
			"name": "Ireland",
			"nativeName": "ire",
			"tld": [
				".ie"
			],
			"cca2": "IE",
			"ccn3": "372",
			"cca3": "IRL",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"353"
			],
			"capital": {
				"city": "dublin",
				"accentcity": "Dublin",
				"population": null,
				"latitude": "52.5744444",
				"longitude": "-7.5502778"
			},
			"altSpellings": [
				"IE",
				"ire",
				"Republic of Ireland",
				"Poblacht na hireann"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Irish"
				},
				{
					"name": "English"
				}
			],
			"population": -1,
			"demonym": "Irish",
			"borders": [
				"GBR"
			]
		},
		{
			"name": "Isle of Man",
			"nativeName": "Isle of Man",
			"tld": [
				".im"
			],
			"cca2": "IM",
			"ccn3": "833",
			"cca3": "IMN",
			"currency": [
				"GBP"
			],
			"callingCode": [
				"44"
			],
			"capital": {
				"city": "douglas",
				"accentcity": "Douglas",
				"population": null,
				"latitude": "54.15",
				"longitude": "-4.483333"
			},
			"altSpellings": [
				"IM",
				"Ellan Vannin",
				"Mann",
				"Mannin"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Manx"
				}
			],
			"population": 84497,
			"demonym": "Manx",
			"borders": []
		},
		{
			"name": "Israel",
			"nativeName": "Yisr'el",
			"tld": [
				".il"
			],
			"cca2": "IL",
			"ccn3": "376",
			"cca3": "ISR",
			"currency": [
				"ILS"
			],
			"callingCode": [
				"972"
			],
			"capital": {
				"city": "jerusalem",
				"accentcity": "Jerusalem",
				"population": "714685",
				"latitude": "31.78",
				"longitude": "35.23"
			},
			"altSpellings": [
				"IL",
				"State of Israel",
				"Mednat Yisr'el"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Hebrew"
				},
				{
					"name": "Arabic"
				}
			],
			"population": 8092700,
			"demonym": "Israeli",
			"borders": [
				"EGY",
				"JOR",
				"LBN",
				"SYR"
			]
		},
		{
			"name": "Italy",
			"nativeName": "Italia",
			"tld": [
				".it"
			],
			"cca2": "IT",
			"ccn3": "380",
			"cca3": "ITA",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"39"
			],
			"capital": {
				"city": "rome",
				"accentcity": "Rome",
				"population": "2643736",
				"latitude": "41.9",
				"longitude": "12.483333"
			},
			"altSpellings": [
				"IT",
				"Italian Republic",
				"Repubblica italiana"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Italian"
				}
			],
			"population": 59829079,
			"demonym": "Italian",
			"borders": [
				"AUT",
				"FRA",
				"SMR",
				"SVN",
				"CHE",
				"VAT"
			]
		},
		{
			"name": "Jamaica",
			"nativeName": "Jamaica",
			"tld": [
				".jm"
			],
			"cca2": "JM",
			"ccn3": "388",
			"cca3": "JAM",
			"currency": [
				"JMD"
			],
			"callingCode": [
				"1876"
			],
			"capital": {
				"city": "kingston",
				"accentcity": "Kingston",
				"population": "583999",
				"latitude": "18.0",
				"longitude": "-76.8"
			},
			"altSpellings": [
				"JM"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "Jamaican English"
				}
			],
			"population": 2711476,
			"demonym": "Jamaican",
			"borders": []
		},
		{
			"name": "Japan",
			"nativeName": "",
			"tld": [
				".jp"
			],
			"cca2": "JP",
			"ccn3": "392",
			"cca3": "JPN",
			"currency": [
				"JPY"
			],
			"callingCode": [
				"81"
			],
			"capital": {
				"city": "tokyo",
				"accentcity": "Tokyo",
				"population": "31480498",
				"latitude": "35.685",
				"longitude": "139.7513889"
			},
			"altSpellings": [
				"JP",
				"Nippon",
				"Nihon"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Japanese"
				}
			],
			"population": 127290000,
			"demonym": "Japanese",
			"borders": []
		},
		{
			"name": "Jersey",
			"nativeName": "Jersey",
			"tld": [
				".je"
			],
			"cca2": "JE",
			"ccn3": "832",
			"cca3": "JEY",
			"currency": [
				"GBP"
			],
			"callingCode": [
				"44"
			],
			"capital": {
				"city": "saint helier",
				"accentcity": "Saint Helier",
				"population": null,
				"latitude": "49.183333",
				"longitude": "-2.1"
			},
			"altSpellings": [
				"JE",
				"Bailiwick of Jersey",
				"Bailliage de Jersey",
				"Bailliage d Jrri"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "French"
				}
			],
			"population": 97857,
			"demonym": "Channel Islander",
			"borders": []
		},
		{
			"name": "Jordan",
			"nativeName": "al-Urdun",
			"tld": [
				".jo"
			],
			"cca2": "JO",
			"ccn3": "400",
			"cca3": "JOR",
			"currency": [
				"JOD"
			],
			"callingCode": [
				"962"
			],
			"capital": {
				"city": "amman",
				"accentcity": "Amman",
				"population": null,
				"latitude": "31.95",
				"longitude": "35.9333333"
			},
			"altSpellings": [
				"JO",
				"Hashemite Kingdom of Jordan",
				"al-Mamlakah al-Urdunyah al-Hshimyah"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 6512600,
			"demonym": "Jordanian",
			"borders": [
				"IRQ",
				"ISR",
				"SAU",
				"SYR"
			]
		},
		{
			"name": "Kazakhstan",
			"nativeName": "",
			"tld": [
				".kz",
				"."
			],
			"cca2": "KZ",
			"ccn3": "398",
			"cca3": "KAZ",
			"currency": [
				"KZT"
			],
			"callingCode": [
				"76",
				"77"
			],
			"capital": {
				"city": "astana",
				"accentcity": "Astana",
				"population": "345621",
				"latitude": "51.181111",
				"longitude": "71.427778"
			},
			"altSpellings": [
				"KZ",
				"Qazaqstan",
				"",
				"Republic of Kazakhstan",
				" ",
				"Qazaqstan Respublkas",
				" ",
				"Respublika Kazakhstan"
			],
			"region": "Asia",
			"subregion": "Central Asia",
			"language": [
				{
					"name": "Kazakh"
				},
				{
					"name": "Russian"
				}
			],
			"population": 17099000,
			"demonym": "Kazakhstani",
			"borders": [
				"CHN",
				"KGZ",
				"RUS",
				"TKM",
				"UZB"
			]
		},
		{
			"name": "Kenya",
			"nativeName": "Kenya",
			"tld": [
				".ke"
			],
			"cca2": "KE",
			"ccn3": "404",
			"cca3": "KEN",
			"currency": [
				"KES"
			],
			"callingCode": [
				"254"
			],
			"capital": {
				"city": "nairobi",
				"accentcity": "Nairobi",
				"population": "2750561",
				"latitude": "-1.2833333",
				"longitude": "36.8166667"
			},
			"altSpellings": [
				"KE",
				"Republic of Kenya",
				"Jamhuri ya Kenya"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Swahili"
				},
				{
					"name": "English"
				}
			],
			"population": 44354000,
			"demonym": "Kenyan",
			"borders": [
				"ETH",
				"SOM",
				"SSD",
				"TZA",
				"UGA"
			]
		},
		{
			"name": "Kyrgyzstan",
			"nativeName": "",
			"tld": [
				".kg"
			],
			"cca2": "KG",
			"ccn3": "417",
			"cca3": "KGZ",
			"currency": [
				"KGS"
			],
			"callingCode": [
				"996"
			],
			"capital": {
				"city": "bishkek",
				"accentcity": "Bishkek",
				"population": null,
				"latitude": "42.8730556",
				"longitude": "74.6002778"
			},
			"altSpellings": [
				"KG",
				"",
				"Kyrgyz Republic",
				" ",
				"Kyrgyz Respublikasy"
			],
			"region": "Asia",
			"subregion": "Central Asia",
			"language": [
				{
					"name": "Kyrgyz"
				},
				{
					"name": "Russian"
				}
			],
			"population": 5551900,
			"demonym": "Kirghiz",
			"borders": [
				"CHN",
				"KAZ",
				"TJK",
				"UZB"
			]
		},
		{
			"name": "Laos",
			"nativeName": "",
			"tld": [
				".la"
			],
			"cca2": "LA",
			"ccn3": "418",
			"cca3": "LAO",
			"currency": [
				"LAK"
			],
			"callingCode": [
				"856"
			],
			"capital": {
				"city": "vientiane",
				"accentcity": "Vientiane",
				"population": "196644",
				"latitude": "17.966667",
				"longitude": "102.6"
			},
			"altSpellings": [
				"LA",
				"Lao",
				"Lao People's Democratic Republic",
				"Sathalanalat Paxathipatai Paxaxon Lao"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Lao"
				}
			],
			"population": 6580800,
			"demonym": "Laotian",
			"borders": [
				"MMR",
				"KHM",
				"CHN",
				"THA",
				"VNM"
			]
		},
		{
			"name": "Latvia",
			"nativeName": "Latvija",
			"tld": [
				".lv"
			],
			"cca2": "LV",
			"ccn3": "428",
			"cca3": "LVA",
			"currency": [
				"LVL"
			],
			"callingCode": [
				"371"
			],
			"capital": {
				"city": "riga",
				"accentcity": "Riga",
				"population": "742570",
				"latitude": "56.95",
				"longitude": "24.1"
			},
			"altSpellings": [
				"LV",
				"Republic of Latvia",
				"Latvijas Republika"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Latvian"
				}
			],
			"population": 2014000,
			"demonym": "Latvian",
			"borders": [
				"BLR",
				"EST",
				"LTU",
				"RUS"
			]
		},
		{
			"name": "Lebanon",
			"nativeName": "Libnn",
			"tld": [
				".lb"
			],
			"cca2": "LB",
			"ccn3": "422",
			"cca3": "LBN",
			"currency": [
				"LBP"
			],
			"callingCode": [
				"961"
			],
			"capital": {
				"city": "beirut",
				"accentcity": "Beirut",
				"population": "1252010",
				"latitude": "33.8719444",
				"longitude": "35.5097222"
			},
			"altSpellings": [
				"LB",
				"Lebanese Republic",
				"Al-Jumhryah Al-Libnnyah"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				},
				{
					"name": "French"
				}
			],
			"population": 4822000,
			"demonym": "Lebanese",
			"borders": [
				"ISR",
				"SYR"
			]
		},
		{
			"name": "Lesotho",
			"nativeName": "Lesotho",
			"tld": [
				".ls"
			],
			"cca2": "LS",
			"ccn3": "426",
			"cca3": "LSO",
			"currency": [
				"LSL",
				"ZAR"
			],
			"callingCode": [
				"266"
			],
			"capital": {
				"city": "maseru",
				"accentcity": "Maseru",
				"population": "194387",
				"latitude": "-29.3166667",
				"longitude": "27.4833333"
			},
			"altSpellings": [
				"LS",
				"Kingdom of Lesotho",
				"Muso oa Lesotho"
			],
			"region": "Africa",
			"subregion": "Southern Africa",
			"language": [
				{
					"name": "Sesotho"
				},
				{
					"name": "English"
				}
			],
			"population": 2074000,
			"demonym": "Mosotho",
			"borders": [
				"ZAF"
			]
		},
		{
			"name": "Liberia",
			"nativeName": "Liberia",
			"tld": [
				".lr"
			],
			"cca2": "LR",
			"ccn3": "430",
			"cca3": "LBR",
			"currency": [
				"LRD"
			],
			"callingCode": [
				"231"
			],
			"capital": {
				"city": "monrovia",
				"accentcity": "Monrovia",
				"population": "935427",
				"latitude": "6.3105556",
				"longitude": "-10.8047222"
			},
			"altSpellings": [
				"LR",
				"Republic of Liberia"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 4294000,
			"demonym": "Liberian",
			"borders": [
				"GIN",
				"CIV",
				"SLE"
			]
		},
		{
			"name": "Libya",
			"nativeName": "Lby",
			"tld": [
				".ly"
			],
			"cca2": "LY",
			"ccn3": "434",
			"cca3": "LBY",
			"currency": [
				"LYD"
			],
			"callingCode": [
				"218"
			],
			"capital": {
				"city": "tripoli",
				"accentcity": "Tripoli",
				"population": "1150990",
				"latitude": "32.8925",
				"longitude": "13.18"
			},
			"altSpellings": [
				"LY",
				"State of Libya",
				"Dawlat Libya"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 6202000,
			"demonym": "Libyan",
			"borders": [
				"DZA",
				"TCD",
				"EGY",
				"NER",
				"SDN",
				"TUN"
			]
		},
		{
			"name": "Liechtenstein",
			"nativeName": "Liechtenstein",
			"tld": [
				".li"
			],
			"cca2": "LI",
			"ccn3": "438",
			"cca3": "LIE",
			"currency": [
				"CHF"
			],
			"callingCode": [
				"423"
			],
			"capital": {
				"city": "vaduz",
				"accentcity": "Vaduz",
				"population": "5197",
				"latitude": "47.1333333",
				"longitude": "9.5166667"
			},
			"altSpellings": [
				"LI",
				"Principality of Liechtenstein",
				"Frstentum Liechtenstein"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "German"
				}
			],
			"population": 36842,
			"demonym": "Liechtensteiner",
			"borders": [
				"AUT",
				"CHE"
			]
		},
		{
			"name": "Lithuania",
			"nativeName": "Lietuva",
			"tld": [
				".lt"
			],
			"cca2": "LT",
			"ccn3": "440",
			"cca3": "LTU",
			"currency": [
				"LTL"
			],
			"callingCode": [
				"370"
			],
			"capital": {
				"city": "vilnius",
				"accentcity": "Vilnius",
				"population": "542381",
				"latitude": "54.6833333",
				"longitude": "25.3166667"
			},
			"altSpellings": [
				"LT",
				"Republic of Lithuania",
				"Lietuvos Respublika"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Lithuanian"
				}
			],
			"population": 2950684,
			"demonym": "Lithuanian",
			"borders": [
				"BLR",
				"LVA",
				"POL",
				"RUS"
			]
		},
		{
			"name": "Luxembourg",
			"nativeName": "Luxembourg",
			"tld": [
				".lu"
			],
			"cca2": "LU",
			"ccn3": "442",
			"cca3": "LUX",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"352"
			],
			"capital": {
				"city": "luxembourg",
				"accentcity": "Luxembourg",
				"population": null,
				"latitude": "49.6116667",
				"longitude": "6.13"
			},
			"altSpellings": [
				"LU",
				"Grand Duchy of Luxembourg",
				"Grand-Duch de Luxembourg",
				"Groherzogtum Luxemburg",
				"Groussherzogtum Ltzebuerg"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "French"
				},
				{
					"name": "German"
				},
				{
					"name": "Luxembourgish"
				}
			],
			"population": 537000,
			"demonym": "Luxembourger",
			"borders": [
				"BEL",
				"FRA",
				"DEU"
			]
		},
		{
			"name": "Macedonia",
			"nativeName": "",
			"tld": [
				".mk"
			],
			"cca2": "MK",
			"ccn3": "807",
			"cca3": "MKD",
			"currency": [
				"MKD"
			],
			"callingCode": [
				"389"
			],
			"capital": {
				"city": "skopje",
				"accentcity": "Skopje",
				"population": "474887",
				"latitude": "42.0",
				"longitude": "21.4333333"
			},
			"altSpellings": [
				"MK",
				"Republic of Macedonia",
				" "
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Macedonian"
				}
			],
			"population": -1,
			"demonym": "Macedonian",
			"borders": [
				"ALB",
				"BGR",
				"GRC",
				"KOS",
				"SRB"
			]
		},
		{
			"name": "Madagascar",
			"nativeName": "Madagasikara",
			"tld": [
				".mg"
			],
			"cca2": "MG",
			"ccn3": "450",
			"cca3": "MDG",
			"currency": [
				"MGA"
			],
			"callingCode": [
				"261"
			],
			"capital": {
				"city": "antananarivo",
				"accentcity": "Antananarivo",
				"population": null,
				"latitude": "-23.9833333",
				"longitude": "46.1833333"
			},
			"altSpellings": [
				"MG",
				"Republic of Madagascar",
				"Repoblikan'i Madagasikara",
				"Rpublique de Madagascar"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Malagasy"
				},
				{
					"name": "French"
				}
			],
			"population": 20696070,
			"demonym": "Malagasy",
			"borders": []
		},
		{
			"name": "Malawi",
			"nativeName": "Malawi",
			"tld": [
				".mw"
			],
			"cca2": "MW",
			"ccn3": "454",
			"cca3": "MWI",
			"currency": [
				"MWK"
			],
			"callingCode": [
				"265"
			],
			"capital": {
				"city": "lilongwe",
				"accentcity": "Lilongwe",
				"population": "646738",
				"latitude": "-13.9833333",
				"longitude": "33.7833333"
			},
			"altSpellings": [
				"MW",
				"Republic of Malawi"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Chichewa"
				},
				{
					"name": "English"
				}
			],
			"population": 16363000,
			"demonym": "Malawian",
			"borders": [
				"MOZ",
				"TZA",
				"ZMB"
			]
		},
		{
			"name": "Malaysia",
			"nativeName": "Malaysia",
			"tld": [
				".my"
			],
			"cca2": "MY",
			"ccn3": "458",
			"cca3": "MYS",
			"currency": [
				"MYR"
			],
			"callingCode": [
				"60"
			],
			"capital": {
				"city": "kuala lumpur",
				"accentcity": "Kuala Lumpur",
				"population": "1453978",
				"latitude": "3.1666667",
				"longitude": "101.7"
			},
			"altSpellings": [
				"MY"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Malaysian"
				}
			],
			"population": 29793600,
			"demonym": "Malaysian",
			"borders": [
				"BRN",
				"IDN",
				"THA"
			]
		},
		{
			"name": "Mali",
			"nativeName": "Mali",
			"tld": [
				".ml"
			],
			"cca2": "ML",
			"ccn3": "466",
			"cca3": "MLI",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"223"
			],
			"capital": {
				"city": "bamako",
				"accentcity": "Bamako",
				"population": "1297390",
				"latitude": "12.65",
				"longitude": "-8.0"
			},
			"altSpellings": [
				"ML",
				"Republic of Mali",
				"Rpublique du Mali"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 15302000,
			"demonym": "Malian",
			"borders": [
				"DZA",
				"BFA",
				"GIN",
				"CIV",
				"MRT",
				"NER",
				"SEN"
			]
		},
		{
			"name": "Malta",
			"nativeName": "Malta",
			"tld": [
				".mt"
			],
			"cca2": "MT",
			"ccn3": "470",
			"cca3": "MLT",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"356"
			],
			"capital": {
				"city": "valletta",
				"accentcity": "Valletta",
				"population": "6794",
				"latitude": "35.8997222",
				"longitude": "14.5147222"
			},
			"altSpellings": [
				"MT",
				"Republic of Malta",
				"Repubblika ta' Malta"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Maltese"
				},
				{
					"name": "English"
				}
			],
			"population": 416055,
			"demonym": "Maltese",
			"borders": []
		},
		{
			"name": "Marshall Islands",
			"nativeName": "Maje",
			"tld": [
				".mh"
			],
			"cca2": "MH",
			"ccn3": "584",
			"cca3": "MHL",
			"currency": [
				"USD"
			],
			"callingCode": [
				"692"
			],
			"capital": {
				"city": "majuro",
				"accentcity": "Majuro",
				"population": null,
				"latitude": "7.1",
				"longitude": "171.3833333"
			},
			"altSpellings": [
				"MH",
				"Republic of the Marshall Islands",
				"Aolepn Aorkin Maje"
			],
			"region": "Oceania",
			"subregion": "Micronesia",
			"language": [
				{
					"name": "Marshallese"
				},
				{
					"name": "English"
				}
			],
			"population": 56086,
			"demonym": "Marshallese",
			"borders": []
		},
		{
			"name": "Martinique",
			"nativeName": "Martinique",
			"tld": [
				".mq"
			],
			"cca2": "MQ",
			"ccn3": "474",
			"cca3": "MTQ",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"596"
			],
			"capital": {
				"city": "fort-de-france",
				"accentcity": "Fort-de-France",
				"population": "89997",
				"latitude": "14.6",
				"longitude": "-61.0833333"
			},
			"altSpellings": [
				"MQ"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 394173,
			"demonym": "French",
			"borders": []
		},
		{
			"name": "Mauritania",
			"nativeName": "Mrtny",
			"tld": [
				".mr"
			],
			"cca2": "MR",
			"ccn3": "478",
			"cca3": "MRT",
			"currency": [
				"MRO"
			],
			"callingCode": [
				"222"
			],
			"capital": {
				"city": "nouakchott",
				"accentcity": "Nouakchott",
				"population": "709835",
				"latitude": "18.0863889",
				"longitude": "-15.9752778"
			},
			"altSpellings": [
				"MR",
				"Islamic Republic of Mauritania",
				"al-Jumhriyyah al-Islmiyyah al-Mrtniyyah"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 3461041,
			"demonym": "Mauritanian",
			"borders": [
				"DZA",
				"MLI",
				"SEN",
				"ESH"
			]
		},
		{
			"name": "Mauritius",
			"nativeName": "Maurice",
			"tld": [
				".mu"
			],
			"cca2": "MU",
			"ccn3": "480",
			"cca3": "MUS",
			"currency": [
				"MUR"
			],
			"callingCode": [
				"230"
			],
			"capital": {
				"city": "port louis",
				"accentcity": "Port Louis",
				"population": "155226",
				"latitude": "-20.1619444",
				"longitude": "57.4988889"
			},
			"altSpellings": [
				"MU",
				"Republic of Mauritius",
				"Rpublique de Maurice"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 1257900,
			"demonym": "Mauritian",
			"borders": []
		},
		{
			"name": "Mayotte",
			"nativeName": "Mayotte",
			"tld": [
				".yt"
			],
			"cca2": "YT",
			"ccn3": "175",
			"cca3": "MYT",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"262"
			],
			"capital": {
				"city": "mamoudzou",
				"accentcity": "Mamoudzou",
				"population": "54837",
				"latitude": "-12.7794444",
				"longitude": "45.2272222"
			},
			"altSpellings": [
				"YT",
				"Department of Mayotte",
				"Dpartement de Mayotte"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 212600,
			"demonym": "French",
			"borders": []
		},
		{
			"name": "Micronesia",
			"nativeName": "Micronesia",
			"tld": [
				".fm"
			],
			"cca2": "FM",
			"ccn3": "583",
			"cca3": "FSM",
			"currency": [
				"USD"
			],
			"callingCode": [
				"691"
			],
			"capital": {
				"city": "palikir",
				"accentcity": "Palikir",
				"population": null,
				"latitude": "6.9166667",
				"longitude": "158.15"
			},
			"altSpellings": [
				"FM",
				"Federated States of Micronesia"
			],
			"region": "Oceania",
			"subregion": "Micronesia",
			"language": [
				{
					"name": "English"
				}
			],
			"population": -1,
			"demonym": "Micronesian",
			"borders": []
		},
		{
			"name": "Monaco",
			"nativeName": "Monaco",
			"tld": [
				".mc"
			],
			"cca2": "MC",
			"ccn3": "492",
			"cca3": "MCO",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"377"
			],
			"capital": {
				"city": "monaco",
				"accentcity": "Monaco",
				"population": null,
				"latitude": "43.7333333",
				"longitude": "7.4166667"
			},
			"altSpellings": [
				"MC",
				"Principality of Monaco",
				"Principaut de Monaco"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 36136,
			"demonym": "Monegasque",
			"borders": [
				"FRA"
			]
		},
		{
			"name": "Mongolia",
			"nativeName": " ",
			"tld": [
				".mn"
			],
			"cca2": "MN",
			"ccn3": "496",
			"cca3": "MNG",
			"currency": [
				"MNT"
			],
			"callingCode": [
				"976"
			],
			"capital": {
				"city": "ulan bator",
				"accentcity": "Ulan Bator",
				"population": null,
				"latitude": "47.9166667",
				"longitude": "106.9166667"
			},
			"altSpellings": [
				"MN"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Mongolian"
				}
			],
			"population": 2754685,
			"demonym": "Mongolian",
			"borders": [
				"CHN",
				"RUS"
			]
		},
		{
			"name": "Montenegro",
			"nativeName": " ",
			"tld": [
				".me"
			],
			"cca2": "ME",
			"ccn3": "499",
			"cca3": "MNE",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"382"
			],
			"capital": {
				"city": "podgorica",
				"accentcity": "Podgorica",
				"population": "156988",
				"latitude": "42.441111",
				"longitude": "19.263611"
			},
			"altSpellings": [
				"ME",
				"Crna Gora"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Montenegrin"
				}
			],
			"population": 620029,
			"demonym": "Montenegrin",
			"borders": [
				"ALB",
				"BIH",
				"HRV",
				"KOS",
				"SRB"
			]
		},
		{
			"name": "Montserrat",
			"nativeName": "Montserrat",
			"tld": [
				".ms"
			],
			"cca2": "MS",
			"ccn3": "500",
			"cca3": "MSR",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1664"
			],
			"capital": {
				"city": "plymouth",
				"accentcity": "Plymouth",
				"population": null,
				"latitude": "16.7",
				"longitude": "-62.2166667"
			},
			"altSpellings": [
				"MS"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 4922,
			"demonym": "Montserratian",
			"borders": []
		},
		{
			"name": "Morocco",
			"nativeName": "al-Marib",
			"tld": [
				".ma"
			],
			"cca2": "MA",
			"ccn3": "504",
			"cca3": "MAR",
			"currency": [
				"MAD"
			],
			"callingCode": [
				"212"
			],
			"capital": {
				"city": "rabat",
				"accentcity": "Rabat",
				"population": "1894386",
				"latitude": "34.0252778",
				"longitude": "-6.8361111"
			},
			"altSpellings": [
				"MA",
				"Kingdom of Morocco",
				"Al-Mamlakah al-Maribiyah"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Arabic"
				},
				{
					"name": "Tamazight"
				}
			],
			"population": 33087700,
			"demonym": "Moroccan",
			"borders": [
				"DZA",
				"ESH",
				"ESP"
			]
		},
		{
			"name": "Mozambique",
			"nativeName": "Moambique",
			"tld": [
				".mz"
			],
			"cca2": "MZ",
			"ccn3": "508",
			"cca3": "MOZ",
			"currency": [
				"MZN"
			],
			"callingCode": [
				"258"
			],
			"capital": {
				"city": "maputo",
				"accentcity": "Maputo",
				"population": null,
				"latitude": "-14.8475",
				"longitude": "40.7202778"
			},
			"altSpellings": [
				"MZ",
				"Republic of Mozambique",
				"Repblica de Moambique"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Portuguese"
				}
			],
			"population": 23700715,
			"demonym": "Mozambican",
			"borders": [
				"MWI",
				"ZAF",
				"SWZ",
				"TZA",
				"ZMB",
				"ZWE"
			]
		},
		{
			"name": "Namibia",
			"nativeName": "Namibia",
			"tld": [
				".na"
			],
			"cca2": "NA",
			"ccn3": "516",
			"cca3": "NAM",
			"currency": [
				"NAD",
				"ZAR"
			],
			"callingCode": [
				"264"
			],
			"capital": {
				"city": "windhoek",
				"accentcity": "Windhoek",
				"population": "268129",
				"latitude": "-22.57",
				"longitude": "17.0836111"
			},
			"altSpellings": [
				"NA",
				"Namibi",
				"Republic of Namibia"
			],
			"region": "Africa",
			"subregion": "Southern Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 2113077,
			"demonym": "Namibian",
			"borders": [
				"AGO",
				"BWA",
				"ZAF",
				"ZMB"
			]
		},
		{
			"name": "Nepal",
			"nativeName": "",
			"tld": [
				".np"
			],
			"cca2": "NP",
			"ccn3": "524",
			"cca3": "NPL",
			"currency": [
				"NPR"
			],
			"callingCode": [
				"977"
			],
			"capital": {
				"city": "kathmandu",
				"accentcity": "Kathmandu",
				"population": "790612",
				"latitude": "27.7166667",
				"longitude": "85.3166667"
			},
			"altSpellings": [
				"NP",
				"Federal Democratic Republic of Nepal",
				"Loktntrik Ganatantra Nepl"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Nepali"
				}
			],
			"population": 26494504,
			"demonym": "Nepalese",
			"borders": [
				"CHN",
				"IND"
			]
		},
		{
			"name": "Netherlands",
			"nativeName": "Nederland",
			"tld": [
				".nl"
			],
			"cca2": "NL",
			"ccn3": "528",
			"cca3": "NLD",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"31"
			],
			"capital": {
				"city": "amsterdam",
				"accentcity": "Amsterdam",
				"population": "745811",
				"latitude": "52.35",
				"longitude": "4.9166667"
			},
			"altSpellings": [
				"NL",
				"Holland",
				"Nederland"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "Dutch"
				}
			],
			"population": 16807300,
			"demonym": "Dutch",
			"borders": [
				"BEL",
				"DEU"
			]
		},
		{
			"name": "New Zealand",
			"nativeName": "New Zealand",
			"tld": [
				".nz"
			],
			"cca2": "NZ",
			"ccn3": "554",
			"cca3": "NZL",
			"currency": [
				"NZD"
			],
			"callingCode": [
				"64"
			],
			"capital": {
				"city": "wellington",
				"accentcity": "Wellington",
				"population": "179240",
				"latitude": "-41.3",
				"longitude": "174.783333"
			},
			"altSpellings": [
				"NZ",
				"Aotearoa"
			],
			"region": "Oceania",
			"subregion": [
				"Australia",
				"New Zealand"
			],
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Mori"
				},
				{
					"name": "New Zealand Sign Language"
				}
			],
			"population": 4478810,
			"demonym": "New Zealander",
			"borders": []
		},
		{
			"name": "Nicaragua",
			"nativeName": "Nicaragua",
			"tld": [
				".ni"
			],
			"cca2": "NI",
			"ccn3": "558",
			"cca3": "NIC",
			"currency": [
				"NIO"
			],
			"callingCode": [
				"505"
			],
			"capital": {
				"city": "managua",
				"accentcity": "Managua",
				"population": "1140499",
				"latitude": "12.1508333",
				"longitude": "-86.2683333"
			},
			"altSpellings": [
				"NI",
				"Republic of Nicaragua",
				"Repblica de Nicaragua"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 6071045,
			"demonym": "Nicaraguan",
			"borders": [
				"CRI",
				"HND"
			]
		},
		{
			"name": "Niger",
			"nativeName": "Niger",
			"tld": [
				".ne"
			],
			"cca2": "NE",
			"ccn3": "562",
			"cca3": "NER",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"227"
			],
			"capital": {
				"city": "niamey",
				"accentcity": "Niamey",
				"population": "774245",
				"latitude": "13.5166667",
				"longitude": "2.1166667"
			},
			"altSpellings": [
				"NE",
				"Nijar",
				"Republic of Niger",
				"Rpublique du Niger"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 17129076,
			"demonym": "Nigerian",
			"borders": [
				"DZA",
				"BEN",
				"BFA",
				"TCD",
				"LBY",
				"MLI",
				"NGA"
			]
		},
		{
			"name": "Nigeria",
			"nativeName": "Nigeria",
			"tld": [
				".ng"
			],
			"cca2": "NG",
			"ccn3": "566",
			"cca3": "NGA",
			"currency": [
				"NGN"
			],
			"callingCode": [
				"234"
			],
			"capital": {
				"city": "abuja",
				"accentcity": "Abuja",
				"population": "174152",
				"latitude": "9.1758333",
				"longitude": "7.1808333"
			},
			"altSpellings": [
				"NG",
				"Nijeriya",
				"Najr",
				"Federal Republic of Nigeria"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 173615000,
			"demonym": "Nigerian",
			"borders": [
				"BEN",
				"CMR",
				"TCD",
				"NER"
			]
		},
		{
			"name": "Niue",
			"nativeName": "Niu",
			"tld": [
				".nu"
			],
			"cca2": "NU",
			"ccn3": "570",
			"cca3": "NIU",
			"currency": [
				"NZD"
			],
			"callingCode": [
				"683"
			],
			"capital": {
				"city": "alofi",
				"accentcity": "Alofi",
				"population": "624",
				"latitude": "-19.0166667",
				"longitude": "-169.9166667"
			},
			"altSpellings": [
				"NU"
			],
			"region": "Oceania",
			"subregion": "Polynesia",
			"language": [
				{
					"name": "Niuean"
				},
				{
					"name": "English"
				}
			],
			"population": 1613,
			"demonym": "Niuean",
			"borders": []
		},
		{
			"name": "Norfolk Island",
			"nativeName": "Norfolk Island",
			"tld": [
				".nf"
			],
			"cca2": "NF",
			"ccn3": "574",
			"cca3": "NFK",
			"currency": [
				"AUD"
			],
			"callingCode": [
				"672"
			],
			"capital": {
				"city": "kingston",
				"accentcity": "Kingston",
				"population": null,
				"latitude": "-29.05",
				"longitude": "167.95"
			},
			"altSpellings": [
				"NF",
				"Territory of Norfolk Island",
				"Teratri of Norf'k Ailen"
			],
			"region": "Oceania",
			"subregion": [
				"Australia",
				"New Zealand"
			],
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Norfuk"
				}
			],
			"population": 2302,
			"demonym": "Norfolk Islander",
			"borders": []
		},
		{
			"name": "North Korea",
			"nativeName": "",
			"tld": [
				".kp"
			],
			"cca2": "KP",
			"ccn3": "408",
			"cca3": "PRK",
			"currency": [
				"KPW"
			],
			"callingCode": [
				"850"
			],
			"capital": {
				"city": "pyongyang",
				"accentcity": "Pyongyang",
				"population": null,
				"latitude": "39.0194444",
				"longitude": "125.7547222"
			},
			"altSpellings": [
				"KP",
				"Democratic People's Republic of Korea",
				"",
				"Chosn Minjujui Inmin Konghwaguk"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Korean"
				}
			],
			"population": 24895000,
			"demonym": "North Korean",
			"borders": []
		},
		{
			"name": "Norway",
			"nativeName": "Norge",
			"tld": [
				".no"
			],
			"cca2": "NO",
			"ccn3": "578",
			"cca3": "NOR",
			"currency": [
				"NOK"
			],
			"callingCode": [
				"47"
			],
			"capital": {
				"city": "oslo",
				"accentcity": "Oslo",
				"population": "808690",
				"latitude": "59.916667",
				"longitude": "10.75"
			},
			"altSpellings": [
				"NO",
				"Norge",
				"Noreg",
				"Kingdom of Norway",
				"Kongeriket Norge",
				"Kongeriket Noreg"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Norwegian"
				}
			],
			"population": 5077798,
			"demonym": "Norwegian",
			"borders": [
				"FIN",
				"SWE",
				"RUS"
			]
		},
		{
			"name": "Oman",
			"nativeName": "Umn",
			"tld": [
				".om"
			],
			"cca2": "OM",
			"ccn3": "512",
			"cca3": "OMN",
			"currency": [
				"OMR"
			],
			"callingCode": [
				"968"
			],
			"capital": {
				"city": "muscat",
				"accentcity": "Muscat",
				"population": "67445",
				"latitude": "23.6133333",
				"longitude": "58.5933333"
			},
			"altSpellings": [
				"OM",
				"Sultanate of Oman",
				"Salanat Umn"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 3929000,
			"demonym": "Omani",
			"borders": [
				"SAU",
				"ARE",
				"YEM"
			]
		},
		{
			"name": "Pakistan",
			"nativeName": "Pakistan",
			"tld": [
				".pk"
			],
			"cca2": "PK",
			"ccn3": "586",
			"cca3": "PAK",
			"currency": [
				"PKR"
			],
			"callingCode": [
				"92"
			],
			"capital": {
				"city": "islamabad",
				"accentcity": "Islamabad",
				"population": null,
				"latitude": "33.7",
				"longitude": "73.166667"
			},
			"altSpellings": [
				"PK",
				"Pkistn",
				"Islamic Republic of Pakistan",
				"Islm Jumhriya'eh Pkistn"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Urdu"
				}
			],
			"population": 184845000,
			"demonym": "Pakistani",
			"borders": [
				"AFG",
				"CHN",
				"IND",
				"IRN"
			]
		},
		{
			"name": "Palestine",
			"nativeName": "Filasin",
			"tld": [
				".ps"
			],
			"cca2": "PS",
			"ccn3": "275",
			"cca3": "PSE",
			"currency": [
				"ILS"
			],
			"callingCode": [
				"970"
			],
			"capital": {
				"city": "ramallah",
				"accentcity": "Ramallah",
				"population": null,
				"latitude": "31.9",
				"longitude": "35.2"
			},
			"altSpellings": [
				"PS",
				"State of Palestine",
				"Dawlat Filasin"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": -1,
			"demonym": "Palestinian",
			"borders": []
		},
		{
			"name": "Panama",
			"nativeName": "Panam",
			"tld": [
				".pa"
			],
			"cca2": "PA",
			"ccn3": "591",
			"cca3": "PAN",
			"currency": [
				"PAB",
				"USD"
			],
			"callingCode": [
				"507"
			],
			"capital": {
				"city": "panama city",
				"accentcity": "Panama City",
				"population": null,
				"latitude": "8.9666667",
				"longitude": "-79.5333333"
			},
			"altSpellings": [
				"PA",
				"Republic of Panama",
				"Repblica de Panam"
			],
			"region": "Americas",
			"subregion": "Central America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 3405813,
			"demonym": "Panamanian",
			"borders": [
				"COL",
				"CRI"
			]
		},
		{
			"name": "Papua New Guinea",
			"nativeName": "Papua Niugini",
			"tld": [
				".pg"
			],
			"cca2": "PG",
			"ccn3": "598",
			"cca3": "PNG",
			"currency": [
				"PGK"
			],
			"callingCode": [
				"675"
			],
			"capital": {
				"city": "port moresby",
				"accentcity": "Port Moresby",
				"population": "283733",
				"latitude": "-9.4647222",
				"longitude": "147.1925"
			},
			"altSpellings": [
				"PG",
				"Independent State of Papua New Guinea",
				"Independen Stet bilong Papua Niugini"
			],
			"region": "Oceania",
			"subregion": "Melanesia",
			"language": [
				{
					"name": "Hiri Motu"
				},
				{
					"name": "Tok Pisin"
				},
				{
					"name": "English"
				}
			],
			"population": 7059653,
			"demonym": "Papua New Guinean",
			"borders": [
				"IDN"
			]
		},
		{
			"name": "Peru",
			"nativeName": "Per",
			"tld": [
				".pe"
			],
			"cca2": "PE",
			"ccn3": "604",
			"cca3": "PER",
			"currency": [
				"PEN"
			],
			"callingCode": [
				"51"
			],
			"capital": {
				"city": "lima",
				"accentcity": "Lima",
				"population": null,
				"latitude": "-15.9833333",
				"longitude": "-69.5166667"
			},
			"altSpellings": [
				"PE",
				"Republic of Peru",
				" Repblica del Per"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				},
				{
					"name": "Quechua"
				},
				{
					"name": "Aymara"
				}
			],
			"population": 30475144,
			"demonym": "Peruvian",
			"borders": [
				"BOL",
				"BRA",
				"CHL",
				"COL",
				"ECU"
			]
		},
		{
			"name": "Philippines",
			"nativeName": "Pilipinas",
			"tld": [
				".ph"
			],
			"cca2": "PH",
			"ccn3": "608",
			"cca3": "PHL",
			"currency": [
				"PHP"
			],
			"callingCode": [
				"63"
			],
			"capital": {
				"city": "manila",
				"accentcity": "Manila",
				"population": "10443877",
				"latitude": "14.604167",
				"longitude": "120.982222"
			},
			"altSpellings": [
				"PH",
				"Republic of the Philippines",
				"Repblika ng Pilipinas"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Filipino"
				},
				{
					"name": "English"
				}
			],
			"population": 98678000,
			"demonym": "Filipino",
			"borders": []
		},
		{
			"name": "Pitcairn Islands",
			"nativeName": "Pitcairn Islands",
			"tld": [
				".pn"
			],
			"cca2": "PN",
			"ccn3": "612",
			"cca3": "PCN",
			"currency": [
				"NZD"
			],
			"callingCode": [
				"64"
			],
			"capital": {
				"city": "adamstown",
				"accentcity": "Adamstown",
				"population": null,
				"latitude": "-25.0666667",
				"longitude": "-130.0833333"
			},
			"altSpellings": [
				"PN",
				"Pitcairn Henderson Ducie and Oeno Islands"
			],
			"region": "Oceania",
			"subregion": "Polynesia",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 56,
			"demonym": "Pitcairn Islander",
			"borders": []
		},
		{
			"name": "Poland",
			"nativeName": "Polska",
			"tld": [
				".pl"
			],
			"cca2": "PL",
			"ccn3": "616",
			"cca3": "POL",
			"currency": [
				"PLN"
			],
			"callingCode": [
				"48"
			],
			"capital": {
				"city": "warsaw",
				"accentcity": "Warsaw",
				"population": "1651676",
				"latitude": "52.25",
				"longitude": "21"
			},
			"altSpellings": [
				"PL",
				"Republic of Poland",
				"Rzeczpospolita Polska"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Polish"
				}
			],
			"population": 38533299,
			"demonym": "Polish",
			"borders": [
				"BLR",
				"CZE",
				"DEU",
				"LTU",
				"RUS",
				"SVK",
				"UKR"
			]
		},
		{
			"name": "Portugal",
			"nativeName": "Portugal",
			"tld": [
				".pt"
			],
			"cca2": "PT",
			"ccn3": "620",
			"cca3": "PRT",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"351"
			],
			"capital": {
				"city": "lisbon",
				"accentcity": "Lisbon",
				"population": "517798",
				"latitude": "38.7166667",
				"longitude": "-9.1333333"
			},
			"altSpellings": [
				"PT",
				"Portuguesa",
				"Portuguese Republic",
				"Repblica Portuguesa"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Portuguese"
				}
			],
			"population": 10562178,
			"demonym": "Portuguese",
			"borders": [
				"ESP"
			]
		},
		{
			"name": "Qatar",
			"nativeName": "Qaar",
			"tld": [
				".qa"
			],
			"cca2": "QA",
			"ccn3": "634",
			"cca3": "QAT",
			"currency": [
				"QAR"
			],
			"callingCode": [
				"974"
			],
			"capital": {
				"city": "doha",
				"accentcity": "Doha",
				"population": "344939",
				"latitude": "25.2866667",
				"longitude": "51.5333333"
			},
			"altSpellings": [
				"QA",
				"State of Qatar",
				"Dawlat Qaar"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 2024707,
			"demonym": "Qatari",
			"borders": [
				"SAU"
			]
		},
		{
			"name": "Runion",
			"nativeName": "La Runion",
			"tld": [
				".re"
			],
			"cca2": "RE",
			"ccn3": "638",
			"cca3": "REU",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"262"
			],
			"capital": {
				"city": "saint-denis",
				"accentcity": "Saint-Denis",
				"population": "137198",
				"latitude": "-20.8666667",
				"longitude": "55.4666667"
			},
			"altSpellings": [
				"RE",
				"Reunion"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 821136,
			"demonym": "French",
			"borders": []
		},
		{
			"name": "Romania",
			"nativeName": "Romnia",
			"tld": [
				".ro"
			],
			"cca2": "RO",
			"ccn3": "642",
			"cca3": "ROU",
			"currency": [
				"RON"
			],
			"callingCode": [
				"40"
			],
			"capital": {
				"city": "bucharest",
				"accentcity": "Bucharest",
				"population": "1877155",
				"latitude": "44.433333",
				"longitude": "26.1"
			},
			"altSpellings": [
				"RO",
				"Rumania",
				"Roumania",
				"Romnia"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Romanian"
				}
			],
			"population": 20121641,
			"demonym": "Romanian",
			"borders": [
				"BGR",
				"HUN",
				"MDA",
				"SRB",
				"UKR"
			]
		},
		{
			"name": "Russia",
			"nativeName": "",
			"tld": [
				".ru"
			],
			"cca2": "RU",
			"ccn3": "643",
			"cca3": "RUS",
			"currency": [
				"RUB"
			],
			"callingCode": [
				"7"
			],
			"capital": {
				"city": "moscow",
				"accentcity": "Moscow",
				"population": "10381288",
				"latitude": "55.7522222",
				"longitude": "37.6155556"
			},
			"altSpellings": [
				"RU",
				"Rossiya",
				"Russian Federation",
				" ",
				"Rossiyskaya Federatsiya"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Russian"
				}
			],
			"population": 143500000,
			"demonym": "Russian",
			"borders": [
				"AZE",
				"BLR",
				"CHN",
				"EST",
				"FIN",
				"GEO",
				"KAZ",
				"PRK",
				"LVA",
				"LTU",
				"MNG",
				"NOR",
				"POL",
				"UKR"
			]
		},
		{
			"name": "Rwanda",
			"nativeName": "Rwanda",
			"tld": [
				".rw"
			],
			"cca2": "RW",
			"ccn3": "646",
			"cca3": "RWA",
			"currency": [
				"RWF"
			],
			"callingCode": [
				"250"
			],
			"capital": {
				"city": "kigali",
				"accentcity": "Kigali",
				"population": "745526",
				"latitude": "-1.9536111",
				"longitude": "30.0605556"
			},
			"altSpellings": [
				"RW",
				"Republic of Rwanda",
				"Repubulika y'u Rwanda",
				"Rpublique du Rwanda"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Kinyarwanda"
				},
				{
					"name": "French"
				},
				{
					"name": "English"
				}
			],
			"population": 10537222,
			"demonym": "Rwandan",
			"borders": [
				"BDI",
				"COD",
				"TZA",
				"UGA"
			]
		},
		{
			"name": "Saint Helena",
			"nativeName": "Saint Helena",
			"tld": [
				".sh"
			],
			"cca2": "SH",
			"ccn3": "654",
			"cca3": "SHN",
			"currency": [
				"SHP"
			],
			"callingCode": [
				"290"
			],
			"capital": {
				"city": "jamestown",
				"accentcity": "Jamestown",
				"population": "637",
				"latitude": "-15.9333333",
				"longitude": "-5.7166667"
			},
			"altSpellings": [
				"SH"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": -1,
			"demonym": "Saint Helenian",
			"borders": []
		},
		{
			"name": "Saint Kitts and Nevis",
			"nativeName": "Saint Kitts and Nevis",
			"tld": [
				".kn"
			],
			"cca2": "KN",
			"ccn3": "659",
			"cca3": "KNA",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1869"
			],
			"capital": {
				"city": "basseterre",
				"accentcity": "Basseterre",
				"population": "12920",
				"latitude": "17.3",
				"longitude": "-62.7166667"
			},
			"altSpellings": [
				"KN",
				"Federation of Saint Christopher and Nevis"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 54000,
			"demonym": "Kittian and Nevisian",
			"borders": []
		},
		{
			"name": "Saint Lucia",
			"nativeName": "Saint Lucia",
			"tld": [
				".lc"
			],
			"cca2": "LC",
			"ccn3": "662",
			"cca3": "LCA",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1758"
			],
			"capital": {
				"city": "castries",
				"accentcity": "Castries",
				"population": "12981",
				"latitude": "14.0",
				"longitude": "-61.0"
			},
			"altSpellings": [
				"LC"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 166526,
			"demonym": "Saint Lucian",
			"borders": []
		},
		{
			"name": "Saint Pierre and Miquelon",
			"nativeName": "Saint-Pierre-et-Miquelon",
			"tld": [
				".pm"
			],
			"cca2": "PM",
			"ccn3": "666",
			"cca3": "SPM",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"508"
			],
			"capital": {
				"city": "saint-pierre",
				"accentcity": "Saint-Pierre",
				"population": "6200",
				"latitude": "46.7666667",
				"longitude": "-56.1833333"
			},
			"altSpellings": [
				"PM",
				"Collectivit territoriale de Saint-Pierre-et-Miquelon"
			],
			"region": "Americas",
			"subregion": "Northern America",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 6081,
			"demonym": "French",
			"borders": []
		},
		{
			"name": "Saint Vincent and the Grenadines",
			"nativeName": "Saint Vincent and the Grenadines",
			"tld": [
				".vc"
			],
			"cca2": "VC",
			"ccn3": "670",
			"cca3": "VCT",
			"currency": [
				"XCD"
			],
			"callingCode": [
				"1784"
			],
			"capital": {
				"city": "kingstown",
				"accentcity": "Kingstown",
				"population": "17995",
				"latitude": "13.1333333",
				"longitude": "-61.2166667"
			},
			"altSpellings": [
				"VC"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 109000,
			"demonym": "Saint Vincentian",
			"borders": []
		},
		{
			"name": "Samoa",
			"nativeName": "Samoa",
			"tld": [
				".ws"
			],
			"cca2": "WS",
			"ccn3": "882",
			"cca3": "WSM",
			"currency": [
				"WST"
			],
			"callingCode": [
				"685"
			],
			"capital": {
				"city": "apia",
				"accentcity": "Apia",
				"population": "40407",
				"latitude": "-13.8333333",
				"longitude": "-171.7333333"
			},
			"altSpellings": [
				"WS",
				"Independent State of Samoa",
				"Malo Saoloto Tutoatasi o Smoa"
			],
			"region": "Oceania",
			"subregion": "Polynesia",
			"language": [
				{
					"name": "Samoan"
				},
				{
					"name": "English"
				}
			],
			"population": 187820,
			"demonym": "Samoan",
			"borders": []
		},
		{
			"name": "Saudi Arabia",
			"nativeName": "as-Sudiyyah",
			"tld": [
				".sa"
			],
			"cca2": "SA",
			"ccn3": "682",
			"cca3": "SAU",
			"currency": [
				"SAR"
			],
			"callingCode": [
				"966"
			],
			"capital": {
				"city": "riyadh",
				"accentcity": "Riyadh",
				"population": "3469290",
				"latitude": "24.6408333",
				"longitude": "46.7727778"
			},
			"altSpellings": [
				"SA",
				"Kingdom of Saudi Arabia",
				"Al-Mamlakah al-Arabiyyah as-Sudiyyah"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 29994272,
			"demonym": "Saudi Arabian",
			"borders": [
				"IRQ",
				"JOR",
				"KWT",
				"OMN",
				"QAT",
				"ARE",
				"YEM"
			]
		},
		{
			"name": "Senegal",
			"nativeName": "Sngal",
			"tld": [
				".sn"
			],
			"cca2": "SN",
			"ccn3": "686",
			"cca3": "SEN",
			"currency": [
				"XOF"
			],
			"callingCode": [
				"221"
			],
			"capital": {
				"city": "dakar",
				"accentcity": "Dakar",
				"population": "2702820",
				"latitude": "14.6708333",
				"longitude": "-17.4380556"
			},
			"altSpellings": [
				"SN",
				"Republic of Senegal",
				"Rpublique du Sngal"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "French"
				}
			],
			"population": 13567338,
			"demonym": "Senegalese",
			"borders": [
				"The Gambia",
				"GIN",
				"GNB",
				"MLI",
				"MRT"
			]
		},
		{
			"name": "Serbia",
			"nativeName": "",
			"tld": [
				".rs"
			],
			"cca2": "RS",
			"ccn3": "688",
			"cca3": "SRB",
			"currency": [
				"RSD"
			],
			"callingCode": [
				"381"
			],
			"capital": {
				"city": "belgrade",
				"accentcity": "Belgrade",
				"population": "1115200",
				"latitude": "44.818611",
				"longitude": "20.468056"
			},
			"altSpellings": [
				"RS",
				"Srbija",
				"Republic of Serbia",
				" ",
				"Republika Srbija"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Serbian"
				}
			],
			"population": 7181505,
			"demonym": "Serbian",
			"borders": [
				"BIH",
				"BGR",
				"HRV",
				"HUN",
				"KOS",
				"MKD",
				"MNE",
				"ROU"
			]
		},
		{
			"name": "Seychelles",
			"nativeName": "Seychelles",
			"tld": [
				".sc"
			],
			"cca2": "SC",
			"ccn3": "690",
			"cca3": "SYC",
			"currency": [
				"SCR"
			],
			"callingCode": [
				"248"
			],
			"capital": {
				"city": "victoria",
				"accentcity": "Victoria",
				"population": "26361",
				"latitude": "-4.6166667",
				"longitude": "55.45"
			},
			"altSpellings": [
				"SC",
				"Republic of Seychelles",
				"Repiblik Sesel",
				"Rpublique des Seychelles"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "French"
				},
				{
					"name": "English"
				},
				{
					"name": "Seychellois Creole"
				}
			],
			"population": 90945,
			"demonym": "Seychellois",
			"borders": []
		},
		{
			"name": "Sierra Leone",
			"nativeName": "Sierra Leone",
			"tld": [
				".sl"
			],
			"cca2": "SL",
			"ccn3": "694",
			"cca3": "SLE",
			"currency": [
				"SLL"
			],
			"callingCode": [
				"232"
			],
			"capital": {
				"city": "freetown",
				"accentcity": "Freetown",
				"population": "1190761",
				"latitude": "8.49",
				"longitude": "-13.2341667"
			},
			"altSpellings": [
				"SL",
				"Republic of Sierra Leone"
			],
			"region": "Africa",
			"subregion": "Western Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 6190280,
			"demonym": "Sierra Leonean",
			"borders": [
				"GIN",
				"LBR"
			]
		},
		{
			"name": "Singapore",
			"nativeName": "Singapore",
			"tld": [
				".sg"
			],
			"cca2": "SG",
			"ccn3": "702",
			"cca3": "SGP",
			"currency": [
				"SGD"
			],
			"callingCode": [
				"65"
			],
			"capital": {
				"city": "singapore",
				"accentcity": "Singapore",
				"population": "3547809",
				"latitude": "1.2930556",
				"longitude": "103.8558333"
			},
			"altSpellings": [
				"SG",
				"Singapura",
				"Republik Singapura",
				""
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Malay"
				},
				{
					"name": "Mandarin"
				},
				{
					"name": "Tamil"
				}
			],
			"population": 5399200,
			"demonym": "Singaporean",
			"borders": []
		},
		{
			"name": "Slovakia",
			"nativeName": "Slovensko",
			"tld": [
				".sk"
			],
			"cca2": "SK",
			"ccn3": "703",
			"cca3": "SVK",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"421"
			],
			"capital": {
				"city": "bratislava",
				"accentcity": "Bratislava",
				"population": "423737",
				"latitude": "48.15",
				"longitude": "17.1166667"
			},
			"altSpellings": [
				"SK",
				"Slovak Republic",
				"Slovensk republika"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Slovak"
				}
			],
			"population": 5412008,
			"demonym": "Slovak",
			"borders": [
				"AUT",
				"CZE",
				"HUN",
				"POL",
				"UKR"
			]
		},
		{
			"name": "Slovenia",
			"nativeName": "Slovenija",
			"tld": [
				".si"
			],
			"cca2": "SI",
			"ccn3": "705",
			"cca3": "SVN",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"386"
			],
			"capital": {
				"city": "ljubljana",
				"accentcity": "Ljubljana",
				"population": "255115",
				"latitude": "46.0552778",
				"longitude": "14.5144444"
			},
			"altSpellings": [
				"SI",
				"Republic of Slovenia",
				"Republika Slovenija"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Slovene"
				}
			],
			"population": 2061405,
			"demonym": "Slovene",
			"borders": [
				"AUT",
				"HRV",
				"ITA",
				"HUN"
			]
		},
		{
			"name": "Solomon Islands",
			"nativeName": "Solomon Islands",
			"tld": [
				".sb"
			],
			"cca2": "SB",
			"ccn3": "090",
			"cca3": "SLB",
			"currency": [
				"SDB"
			],
			"callingCode": [
				"677"
			],
			"capital": {
				"city": "honiara",
				"accentcity": "Honiara",
				"population": "56312",
				"latitude": "-9.4333333",
				"longitude": "159.95"
			},
			"altSpellings": [
				"SB"
			],
			"region": "Oceania",
			"subregion": "Melanesia",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 561000,
			"demonym": "Solomon Islander",
			"borders": []
		},
		{
			"name": "Somalia",
			"nativeName": "Soomaaliya",
			"tld": [
				".so"
			],
			"cca2": "SO",
			"ccn3": "706",
			"cca3": "SOM",
			"currency": [
				"SOS"
			],
			"callingCode": [
				"252"
			],
			"capital": {
				"city": "mogadishu",
				"accentcity": "Mogadishu",
				"population": "2590180",
				"latitude": "2.0666667",
				"longitude": "45.3666667"
			},
			"altSpellings": [
				"SO",
				"a-ml",
				"Federal Republic of Somalia",
				"Jamhuuriyadda Federaalka Soomaaliya",
				"Jumhriyyat a-ml al-Fiderliyya"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Somali"
				},
				{
					"name": "Arabic"
				}
			],
			"population": 10496000,
			"demonym": "Somali",
			"borders": [
				"DJI",
				"ETH",
				"KEN"
			]
		},
		{
			"name": "South Africa",
			"nativeName": "South Africa",
			"tld": [
				".za"
			],
			"cca2": "ZA",
			"ccn3": "710",
			"cca3": "ZAF",
			"currency": [
				"ZAR"
			],
			"callingCode": [
				"27"
			],
			"capital": {
				"city": "cape town",
				"accentcity": "Cape Town",
				"population": "3433504",
				"latitude": "-33.9166667",
				"longitude": "18.4166667"
			},
			"altSpellings": [
				"ZA",
				"RSA",
				"Suid-Afrika",
				"Republic of South Africa"
			],
			"region": "Africa",
			"subregion": "Southern Africa",
			"language": [
				{
					"name": "Afrikaans"
				},
				{
					"name": "English"
				},
				{
					"name": "Southern Ndebele"
				},
				{
					"name": "Northern Sotho"
				},
				{
					"name": "Southern Sotho"
				},
				{
					"name": "Swazi"
				},
				{
					"name": "Tsonga"
				},
				{
					"name": "Tswana"
				},
				{
					"name": "Venda"
				},
				{
					"name": "Xhosa"
				},
				{
					"name": "Zulu"
				}
			],
			"population": 52981991,
			"demonym": "South African",
			"borders": [
				"BWA",
				"LSO",
				"MOZ",
				"NAM",
				"SWZ",
				"ZWE"
			]
		},
		{
			"name": "South Korea",
			"nativeName": "",
			"tld": [
				".kr"
			],
			"cca2": "KR",
			"ccn3": "410",
			"cca3": "KOR",
			"currency": [
				"KRW"
			],
			"callingCode": [
				"82"
			],
			"capital": {
				"city": "seoul",
				"accentcity": "Seoul",
				"population": "10323448",
				"latitude": "37.5663889",
				"longitude": "126.9997222"
			},
			"altSpellings": [
				"KR",
				"Republic of Korea"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Korean"
				}
			],
			"population": 50219669,
			"demonym": "South Korean",
			"borders": []
		},
		{
			"name": "Spain",
			"nativeName": "Espaa",
			"tld": [
				".es"
			],
			"cca2": "ES",
			"ccn3": "724",
			"cca3": "ESP",
			"currency": [
				"EUR"
			],
			"callingCode": [
				"34"
			],
			"capital": {
				"city": "madrid",
				"accentcity": "Madrid",
				"population": "3102644",
				"latitude": "40.4",
				"longitude": "-3.683333"
			},
			"altSpellings": [
				"ES",
				"Kingdom of Spain",
				"Reino de Espaa"
			],
			"region": "Europe",
			"subregion": "Southern Europe",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 46704314,
			"demonym": "Spanish",
			"borders": [
				"AND",
				"FRA",
				"GIB",
				"PRT",
				"MAR"
			]
		},
		{
			"name": "Sri Lanka",
			"nativeName": "r lakva",
			"tld": [
				".lk"
			],
			"cca2": "LK",
			"ccn3": "144",
			"cca3": "LKA",
			"currency": [
				"LKR"
			],
			"callingCode": [
				"94"
			],
			"capital": {
				"city": "colombo",
				"accentcity": "Colombo",
				"population": "648119",
				"latitude": "6.9319444",
				"longitude": "79.8477778"
			},
			"altSpellings": [
				"LK",
				"ilakai",
				"Democratic Socialist Republic of Sri Lanka"
			],
			"region": "Asia",
			"subregion": "Southern Asia",
			"language": [
				{
					"name": "Sinhala"
				},
				{
					"name": "Tamil"
				}
			],
			"population": 20277597,
			"demonym": "Sri Lankan",
			"borders": [
				"IND"
			]
		},
		{
			"name": "Sudan",
			"nativeName": "as-Sdn",
			"tld": [
				".sd"
			],
			"cca2": "SD",
			"ccn3": "729",
			"cca3": "SDN",
			"currency": [
				"SDG"
			],
			"callingCode": [
				"249"
			],
			"capital": {
				"city": "khartoum",
				"accentcity": "Khartoum",
				"population": "1974780",
				"latitude": "15.5880556",
				"longitude": "32.5341667"
			},
			"altSpellings": [
				"SD",
				"Republic of the Sudan",
				"Jumhryat as-Sdn"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Arabic"
				},
				{
					"name": "English"
				}
			],
			"population": 37964000,
			"demonym": "Sudanese",
			"borders": [
				"CAF",
				"TCD",
				"EGY",
				"ERI",
				"ETH",
				"LBY",
				"SSD"
			]
		},
		{
			"name": "Suriname",
			"nativeName": "Suriname",
			"tld": [
				".sr"
			],
			"cca2": "SR",
			"ccn3": "740",
			"cca3": "SUR",
			"currency": [
				"SRD"
			],
			"callingCode": [
				"597"
			],
			"capital": {
				"city": "paramaribo",
				"accentcity": "Paramaribo",
				"population": "220306",
				"latitude": "5.8333333",
				"longitude": "-55.1666667"
			},
			"altSpellings": [
				"SR",
				"Sarnam",
				"Sranangron",
				"Republic of Suriname",
				"Republiek Suriname"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Dutch"
				}
			],
			"population": 534189,
			"demonym": "Surinamer",
			"borders": [
				"BRA",
				"GUF",
				"FRA",
				"GUY"
			]
		},
		{
			"name": "Svalbard and Jan Mayen",
			"nativeName": "Svalbard og Jan Mayen",
			"tld": [
				".sj"
			],
			"cca2": "SJ",
			"ccn3": "744",
			"cca3": "SJM",
			"currency": [
				"NOK"
			],
			"callingCode": [
				"4779"
			],
			"capital": {
				"city": "longyearbyen",
				"accentcity": "Longyearbyen",
				"population": "1232",
				"latitude": "78.2166667",
				"longitude": "15.6333333"
			},
			"altSpellings": [
				"SJ",
				"Svalbard and Jan Mayen Islands"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Norwegian"
				}
			],
			"population": 2655,
			"demonym": "Norwegian",
			"borders": []
		},
		{
			"name": "Swaziland",
			"nativeName": "Swaziland",
			"tld": [
				".sz"
			],
			"cca2": "SZ",
			"ccn3": "748",
			"cca3": "SWZ",
			"currency": [
				"SZL"
			],
			"callingCode": [
				"268"
			],
			"capital": {
				"city": "lobamba",
				"accentcity": "Lobamba",
				"population": "4557",
				"latitude": "-26.4666667",
				"longitude": "31.2"
			},
			"altSpellings": [
				"SZ",
				"weSwatini",
				"Swatini",
				"Ngwane",
				"Kingdom of Swaziland",
				"Umbuso waseSwatini"
			],
			"region": "Africa",
			"subregion": "Southern Africa",
			"language": [
				{
					"name": "Swazi"
				},
				{
					"name": "English"
				}
			],
			"population": 1250000,
			"demonym": "Swazi",
			"borders": [
				"MOZ",
				"ZAF"
			]
		},
		{
			"name": "Sweden",
			"nativeName": "Sverige",
			"tld": [
				".se"
			],
			"cca2": "SE",
			"ccn3": "752",
			"cca3": "SWE",
			"currency": [
				"SEK"
			],
			"callingCode": [
				"46"
			],
			"capital": {
				"city": "stockholm",
				"accentcity": "Stockholm",
				"population": null,
				"latitude": "56.1333333",
				"longitude": "13.4166667"
			},
			"altSpellings": [
				"SE",
				"Kingdom of Sweden",
				"Konungariket Sverige"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "Swedish"
				}
			],
			"population": 9625444,
			"demonym": "Swedish",
			"borders": [
				"FIN",
				"NOR"
			]
		},
		{
			"name": "Switzerland",
			"nativeName": "Schweiz",
			"tld": [
				".ch"
			],
			"cca2": "CH",
			"ccn3": "756",
			"cca3": "CHE",
			"currency": [
				"CHE",
				"CHF",
				"CHW"
			],
			"callingCode": [
				"41"
			],
			"capital": {
				"city": "bern",
				"accentcity": "Bern",
				"population": "123018",
				"latitude": "46.916667",
				"longitude": "7.466667"
			},
			"altSpellings": [
				"CH",
				"Swiss Confederation",
				"Schweiz",
				"Suisse",
				"Svizzera",
				"Svizra"
			],
			"region": "Europe",
			"subregion": "Western Europe",
			"language": [
				{
					"name": "German"
				},
				{
					"name": "French"
				},
				{
					"name": "Italian"
				},
				{
					"name": "Romansh"
				}
			],
			"population": 8085300,
			"demonym": "Swiss",
			"borders": [
				"AUT",
				"FRA",
				"ITA",
				"LIE",
				"DEU"
			]
		},
		{
			"name": "Syria",
			"nativeName": "Sriy",
			"tld": [
				".sy"
			],
			"cca2": "SY",
			"ccn3": "760",
			"cca3": "SYR",
			"currency": [
				"SYP"
			],
			"callingCode": [
				"963"
			],
			"capital": {
				"city": "damascus",
				"accentcity": "Damascus",
				"population": "1576843",
				"latitude": "33.5",
				"longitude": "36.3"
			},
			"altSpellings": [
				"SY",
				"Syrian Arab Republic",
				"Al-Jumhryah Al-Arabyah As-Sryah"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 21898000,
			"demonym": "Syrian",
			"borders": [
				"IRQ",
				"ISR",
				"JOR",
				"LBN",
				"TUR"
			]
		},
		{
			"name": "Taiwan",
			"nativeName": "",
			"tld": [
				".tw"
			],
			"cca2": "TW",
			"ccn3": "158",
			"cca3": "TWN",
			"currency": [
				"TWD"
			],
			"callingCode": [
				"886"
			],
			"capital": {
				"city": "taipei",
				"accentcity": "Taipei",
				"population": "2514794",
				"latitude": "25.0391667",
				"longitude": "121.525"
			},
			"altSpellings": [
				"TW",
				"Tiwn",
				"Republic of China",
				"",
				"Zhnghu Mngu"
			],
			"region": "Asia",
			"subregion": "Eastern Asia",
			"language": [
				{
					"name": "Standard Chinese"
				}
			],
			"population": 23361147,
			"demonym": "Taiwanese",
			"borders": []
		},
		{
			"name": "Tajikistan",
			"nativeName": "",
			"tld": [
				".tj"
			],
			"cca2": "TJ",
			"ccn3": "762",
			"cca3": "TJK",
			"currency": [
				"TJS"
			],
			"callingCode": [
				"992"
			],
			"capital": {
				"city": "dushanbe",
				"accentcity": "Dushanbe",
				"population": "543105",
				"latitude": "38.56",
				"longitude": "68.7738889"
			},
			"altSpellings": [
				"TJ",
				"Toikiston",
				"Republic of Tajikistan",
				" ",
				"umhuriyi Toikiston"
			],
			"region": "Asia",
			"subregion": "Central Asia",
			"language": [
				{
					"name": "Tajik"
				}
			],
			"population": 8000000,
			"demonym": "Tadzhik",
			"borders": [
				"AFG",
				"CHN",
				"KGZ",
				"UZB"
			]
		},
		{
			"name": "Tanzania",
			"nativeName": "Tanzania",
			"tld": [
				".tz"
			],
			"cca2": "TZ",
			"ccn3": "834",
			"cca3": "TZA",
			"currency": [
				"TZS"
			],
			"callingCode": [
				"255"
			],
			"capital": {
				"city": "dodoma",
				"accentcity": "Dodoma",
				"population": null,
				"latitude": "-10.6333333",
				"longitude": "35.8166667"
			},
			"altSpellings": [
				"TZ",
				"United Republic of Tanzania",
				"Jamhuri ya Muungano wa Tanzania"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Swahili"
				},
				{
					"name": "English"
				}
			],
			"population": 44928923,
			"demonym": "Tanzanian",
			"borders": [
				"BDI",
				"COD",
				"KEN",
				"MWI",
				"MOZ",
				"RWA",
				"UGA",
				"ZMB"
			]
		},
		{
			"name": "Thailand",
			"nativeName": "",
			"tld": [
				".th"
			],
			"cca2": "TH",
			"ccn3": "764",
			"cca3": "THA",
			"currency": [
				"THB"
			],
			"callingCode": [
				"66"
			],
			"capital": {
				"city": "bangkok",
				"accentcity": "Bangkok",
				"population": "5104475",
				"latitude": "13.75",
				"longitude": "100.516667"
			},
			"altSpellings": [
				"TH",
				"Prathet",
				"Thai",
				"Kingdom of Thailand",
				"",
				"Ratcha Anachak Thai"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Thai"
				}
			],
			"population": 65926261,
			"demonym": "Thai",
			"borders": [
				"Burma",
				"KHM",
				"LAO",
				"MYS"
			]
		},
		{
			"name": "Tunisia",
			"nativeName": "Tnis",
			"tld": [
				".tn"
			],
			"cca2": "TN",
			"ccn3": "788",
			"cca3": "TUN",
			"currency": [
				"TND"
			],
			"callingCode": [
				"216"
			],
			"capital": {
				"city": "tunis",
				"accentcity": "Tunis",
				"population": "692816",
				"latitude": "36.8027778",
				"longitude": "10.1797222"
			},
			"altSpellings": [
				"TN",
				"Republic of Tunisia",
				"al-Jumhriyyah at-Tnisiyyah"
			],
			"region": "Africa",
			"subregion": "Northern Africa",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 10833431,
			"demonym": "Tunisian",
			"borders": [
				"DZA",
				"LBY"
			]
		},
		{
			"name": "Turkey",
			"nativeName": "Trkiye",
			"tld": [
				".tr"
			],
			"cca2": "TR",
			"ccn3": "792",
			"cca3": "TUR",
			"currency": [
				"TRY"
			],
			"callingCode": [
				"90"
			],
			"capital": {
				"city": "ankara",
				"accentcity": "Ankara",
				"population": "3519177",
				"latitude": "39.927222",
				"longitude": "32.864444"
			},
			"altSpellings": [
				"TR",
				"Turkiye",
				"Republic of Turkey",
				"Trkiye Cumhuriyeti"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Turkish"
				}
			],
			"population": 75627384,
			"demonym": "Turkish",
			"borders": [
				"ARM",
				"AZE",
				"BGR",
				"GEO",
				"GRC",
				"IRN",
				"IRQ",
				"SYR"
			]
		},
		{
			"name": "Turkmenistan",
			"nativeName": "Trkmenistan",
			"tld": [
				".tm"
			],
			"cca2": "TM",
			"ccn3": "795",
			"cca3": "TKM",
			"currency": [
				"TMT"
			],
			"callingCode": [
				"993"
			],
			"capital": {
				"city": "ashgabat",
				"accentcity": "Ashgabat",
				"population": null,
				"latitude": "37.95",
				"longitude": "58.3833333"
			},
			"altSpellings": [
				"TM"
			],
			"region": "Asia",
			"subregion": "Central Asia",
			"language": [
				{
					"name": "Turkmen"
				}
			],
			"population": 5240000,
			"demonym": "Turkmen",
			"borders": [
				"AFG",
				"IRN",
				"KAZ",
				"UZB"
			]
		},
		{
			"name": "Turks and Caicos Islands",
			"nativeName": "Turks and Caicos Islands",
			"tld": [
				".tc"
			],
			"cca2": "TC",
			"ccn3": "796",
			"cca3": "TCA",
			"currency": [
				"USD"
			],
			"callingCode": [
				"1649"
			],
			"capital": {
				"city": "cockburn town",
				"accentcity": "Cockburn Town",
				"population": "5525",
				"latitude": "21.4666667",
				"longitude": "-71.1333333"
			},
			"altSpellings": [
				"TC"
			],
			"region": "Americas",
			"subregion": "Caribbean",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 31458,
			"demonym": "Turks and Caicos Islander",
			"borders": []
		},
		{
			"name": "Tuvalu",
			"nativeName": "Tuvalu",
			"tld": [
				".tv"
			],
			"cca2": "TV",
			"ccn3": "798",
			"cca3": "TUV",
			"currency": [
				"AUD"
			],
			"callingCode": [
				"688"
			],
			"capital": {
				"city": "funafuti",
				"accentcity": "Funafuti",
				"population": null,
				"latitude": "-8.5166667",
				"longitude": "179.2166667"
			},
			"altSpellings": [
				"TV"
			],
			"region": "Oceania",
			"subregion": "Polynesia",
			"language": [
				{
					"name": "Tuvaluan"
				},
				{
					"name": "English"
				}
			],
			"population": 11323,
			"demonym": "Tuvaluan",
			"borders": []
		},
		{
			"name": "Uganda",
			"nativeName": "Uganda",
			"tld": [
				".ug"
			],
			"cca2": "UG",
			"ccn3": "800",
			"cca3": "UGA",
			"currency": [
				"UGX"
			],
			"callingCode": [
				"256"
			],
			"capital": {
				"city": "kampala",
				"accentcity": "Kampala",
				"population": "1353236",
				"latitude": "0.3155556",
				"longitude": "32.5655556"
			},
			"altSpellings": [
				"UG",
				"Republic of Uganda",
				"Jamhuri ya Uganda"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "English"
				},
				{
					"name": "Swahili"
				}
			],
			"population": 35357000,
			"demonym": "Ugandan",
			"borders": [
				"COD",
				"KEN",
				"RWA",
				"SSD",
				"TZA"
			]
		},
		{
			"name": "Ukraine",
			"nativeName": "",
			"tld": [
				".ua"
			],
			"cca2": "UA",
			"ccn3": "804",
			"cca3": "UKR",
			"currency": [
				"UAH"
			],
			"callingCode": [
				"380"
			],
			"capital": {
				"city": "kiev",
				"accentcity": "Kiev",
				"population": "2514227",
				"latitude": "50.433333",
				"longitude": "30.516667"
			},
			"altSpellings": [
				"UA",
				"Ukrayina"
			],
			"region": "Europe",
			"subregion": "Eastern Europe",
			"language": [
				{
					"name": "Ukrainian"
				}
			],
			"population": 45461627,
			"demonym": "Ukrainian",
			"borders": [
				"BLR",
				"HUN",
				"MDA",
				"POL",
				"ROU",
				"RUS",
				"SVK"
			]
		},
		{
			"name": "United Arab Emirates",
			"nativeName": "Dawlat al-Imrt al-Arabiyyah al-Muttaidah",
			"tld": [
				".ae"
			],
			"cca2": "AE",
			"ccn3": "784",
			"cca3": "ARE",
			"currency": [
				"AED"
			],
			"callingCode": [
				"971"
			],
			"capital": {
				"city": "abu dhabi",
				"accentcity": "Abu Dhabi",
				"population": "603687",
				"latitude": "24.4666667",
				"longitude": "54.3666667"
			},
			"altSpellings": [
				"AE",
				"UAE"
			],
			"region": "Asia",
			"subregion": "Western Asia",
			"language": [
				{
					"name": "Arabic"
				}
			],
			"population": 8264070,
			"demonym": "Emirian",
			"borders": [
				"OMN",
				"SAU"
			]
		},
		{
			"name": "United Kingdom",
			"nativeName": "United Kingdom",
			"tld": [
				".uk"
			],
			"cca2": "GB",
			"ccn3": "826",
			"cca3": "GBR",
			"currency": [
				"GBP"
			],
			"callingCode": [
				"44"
			],
			"capital": {
				"city": "london",
				"accentcity": "London",
				"population": "7421228",
				"latitude": "51.5002",
				"longitude": "-0.1262"
			},
			"altSpellings": [
				"GB",
				"UK",
				"Great Britain"
			],
			"region": "Europe",
			"subregion": "Northern Europe",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 63705000,
			"demonym": "British",
			"borders": [
				"IRL"
			]
		},
		{
			"name": "United States",
			"nativeName": "United States",
			"tld": [
				".us"
			],
			"cca2": "US",
			"ccn3": "840",
			"cca3": "USA",
			"currency": [
				"USD",
				"USN",
				"USS"
			],
			"callingCode": [
				"1"
			],
			"capital": {
				"city": "washington d.c.",
				"accentcity": "Washington D.C.",
				"population": null,
				"latitude": "38.9000000",
				"longitude": "-77.0166667"
			},
			"altSpellings": [
				"US",
				"USA",
				"United States of America"
			],
			"region": "Americas",
			"subregion": "Northern America",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 317101000,
			"demonym": "American",
			"borders": [
				"CAN",
				"MEX"
			]
		},
		{
			"name": "Uruguay",
			"nativeName": "Uruguay",
			"tld": [
				".uy"
			],
			"cca2": "UY",
			"ccn3": "858",
			"cca3": "URY",
			"currency": [
				"UYI",
				"UYU"
			],
			"callingCode": [
				"598"
			],
			"capital": {
				"city": "montevideo",
				"accentcity": "Montevideo",
				"population": "1305865",
				"latitude": "-34.8580556",
				"longitude": "-56.1708333"
			},
			"altSpellings": [
				"UY",
				"Oriental Republic of Uruguay",
				"Repblica Oriental del Uruguay"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 3286314,
			"demonym": "Uruguayan",
			"borders": [
				"ARG",
				"BRA"
			]
		},
		{
			"name": "Uzbekistan",
			"nativeName": "Ozbekiston",
			"tld": [
				".uz"
			],
			"cca2": "UZ",
			"ccn3": "860",
			"cca3": "UZB",
			"currency": [
				"UZS"
			],
			"callingCode": [
				"998"
			],
			"capital": {
				"city": "tashkent",
				"accentcity": "Tashkent",
				"population": null,
				"latitude": "40.1333333",
				"longitude": "68.3666667"
			},
			"altSpellings": [
				"UZ",
				"Republic of Uzbekistan",
				"Ozbekiston Respublikasi",
				" "
			],
			"region": "Asia",
			"subregion": "Central Asia",
			"language": [
				{
					"name": "Uzbek"
				}
			],
			"population": 30183400,
			"demonym": "Uzbekistani",
			"borders": [
				"AFG",
				"KAZ",
				"KGZ",
				"TJK",
				"TKM"
			]
		},
		{
			"name": "Venezuela",
			"nativeName": "Venezuela",
			"tld": [
				".ve"
			],
			"cca2": "VE",
			"ccn3": "862",
			"cca3": "VEN",
			"currency": [
				"VEF"
			],
			"callingCode": [
				"58"
			],
			"capital": {
				"city": "caracas",
				"accentcity": "Caracas",
				"population": "1815681",
				"latitude": "10.5",
				"longitude": "-66.9166667"
			},
			"altSpellings": [
				"VE",
				"Bolivarian Republic of Venezuela",
				"Repblica Bolivariana de Venezuela"
			],
			"region": "Americas",
			"subregion": "South America",
			"language": [
				{
					"name": "Spanish"
				}
			],
			"population": 28946101,
			"demonym": "Venezuelan",
			"borders": [
				"BRA",
				"COL",
				"GUY"
			]
		},
		{
			"name": "Vietnam",
			"nativeName": "Vit Nam",
			"tld": [
				".vn"
			],
			"cca2": "VN",
			"ccn3": "704",
			"cca3": "VNM",
			"currency": [
				"VND"
			],
			"callingCode": [
				"84"
			],
			"capital": {
				"city": "hanoi",
				"accentcity": "Hanoi",
				"population": "1431377",
				"latitude": "21.0333333",
				"longitude": "105.85"
			},
			"altSpellings": [
				"VN",
				"Socialist Republic of Vietnam",
				"Cng ha X hi ch ngha Vit Nam"
			],
			"region": "Asia",
			"subregion": "South-Eastern Asia",
			"language": [
				{
					"name": "Vietnamese"
				}
			],
			"population": 90388000,
			"demonym": "Vietnamese",
			"borders": [
				"KHM",
				"CHN",
				"LAO"
			]
		},
		{
			"name": "Zambia",
			"nativeName": "Zambia",
			"tld": [
				".zm"
			],
			"cca2": "ZM",
			"ccn3": "894",
			"cca3": "ZMB",
			"currency": [
				"ZMK"
			],
			"callingCode": [
				"260"
			],
			"capital": {
				"city": "lusaka",
				"accentcity": "Lusaka",
				"population": "1267458",
				"latitude": "-15.4166667",
				"longitude": "28.2833333"
			},
			"altSpellings": [
				"ZM",
				"Republic of Zambia"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "English"
				}
			],
			"population": 13092666,
			"demonym": "Zambian",
			"borders": [
				"AGO",
				"BWA",
				"COD",
				"MWI",
				"MOZ",
				"NAM",
				"TZA",
				"ZWE"
			]
		},
		{
			"name": "Zimbabwe",
			"nativeName": "Zimbabwe",
			"tld": [
				".zw"
			],
			"cca2": "ZW",
			"ccn3": "716",
			"cca3": "ZWE",
			"currency": [
				"ZWL"
			],
			"callingCode": [
				"263"
			],
			"capital": {
				"city": "harare",
				"accentcity": "Harare",
				"population": "2213701",
				"latitude": "-17.8177778",
				"longitude": "31.0447222"
			},
			"altSpellings": [
				"ZW",
				"Republic of Zimbabwe"
			],
			"region": "Africa",
			"subregion": "Eastern Africa",
			"language": [
				{
					"name": "Chewa"
				},
				{
					"name": "Chibarwe"
				},
				{
					"name": "English"
				},
				{
					"name": "Kalanga"
				},
				{
					"name": "Koisan"
				},
				{
					"name": "Nambya"
				},
				{
					"name": "Ndau"
				},
				{
					"name": "Ndebele"
				},
				{
					"name": "Shangani"
				},
				{
					"name": "Shona"
				},
				{
					"name": "Zimbabwean sign language"
				},
				{
					"name": "Sotho"
				},
				{
					"name": "Tonga"
				},
				{
					"name": "Tswana"
				},
				{
					"name": "Venda"
				},
				{
					"name": "Xhosa"
				}
			],
			"population": 12973808,
			"demonym": "Zimbabwean",
			"borders": [
				"BWA",
				"MOZ",
				"ZAF",
				"ZMB"
			]
		}
	]

/***/ }
/******/ ]);
//# sourceMappingURL=vendor.bundle.js.map